F401 `requests` imported but unused; consider using `importlib.util.find_spec` to test for availability
   --> admin\tools\critical_flows_test.py:737:16
    |
735 |     # Check requests installed
736 |     try:
737 |         import requests
    |                ^^^^^^^^
738 |     except ImportError:
739 |         print("ÔØî Modulo 'requests' non installato!")
    |
help: Remove unused import: `requests`

SIM115 Use a context manager for opening files
  --> app\core\lock_manager.py:39:33
   |
38 |             # Open file
39 |             self._lock_handle = open(self.lock_path, "wb+")
   |                                 ^^^^
40 |
41 |             # Apply OS-level lock (Non-blocking)
   |

I001 [*] Import block is un-sorted or un-formatted
  --> desktop_app\services\toast_service.py:6:1
   |
 4 |   """
 5 |
 6 | / import contextlib
 7 | | import tkinter as tk
 8 | | from collections import deque
 9 | |
10 | | from typing import ClassVar
   | |___________________________^
   |
help: Organize imports

F821 Undefined name `e`
  --> desktop_app\views\audit_view.py:83:95
   |
81 |                     self.after(
82 |                         0,
83 |                         lambda: messagebox.showerror("Errore", f"Impossibile caricare i log: {e}"),
   |                                                                                               ^
84 |                     )
   |

F821 Undefined name `e`
   --> desktop_app\views\chat_view.py:103:77
    |
102 |         except Exception:
103 |             self.after(0, lambda: self.append_message("Sistema", f"Errore: {e}"))
    |                                                                             ^
    |

F821 Undefined name `e`
   --> desktop_app\views\database_view.py:207:85
    |
205 |             except Exception:
206 |                 if self.winfo_exists():
207 |                     self.after(0, lambda: messagebox.showerror("Errore", f"Errore: {e}"))
    |                                                                                     ^
208 |
209 |         threading.Thread(target=fetch, daemon=True).start()
    |

F821 Undefined name `e`
   --> desktop_app\views\dipendenti_view.py:152:90
    |
150 |                 if self.winfo_exists():
151 |                     self.after(
152 |                         0, lambda: messagebox.showerror("Errore", f"Errore caricamento: {e}")
    |                                                                                          ^
153 |                     )
    |

E722 Do not use bare `except`
  --> desktop_app\views\edit_certificato_dialog.py:33:9
   |
31 |             y = parent.winfo_rooty() + (parent.winfo_height() // 2) - (275)
32 |             self.geometry(f"+{x}+{y}")
33 |         except:
   |         ^^^^^^
34 |             pass  # Fallback if parent not fully drawn
   |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> desktop_app\views\import_view.py:236:17
    |
234 |             if e.response.status_code == 409:
235 |                 self.log(f"SKIP: {os.path.basename(file_path)} -> Gi├á presente.")
236 |                 raise Exception("409: Gi├á presente")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
237 |             else:
238 |                 self.log(f"ERRORE HTTP: {os.path.basename(file_path)} -> {e}")
    |

F821 Undefined name `e`
   --> desktop_app\views\import_view.py:337:73
    |
335 |                     self.after(0, lambda: self._on_sync_complete(False, sync_res.text))
336 |             except Exception:
337 |                 self.after(0, lambda: self._on_sync_complete(False, str(e)))
    |                                                                         ^
338 |
339 |         thread = threading.Thread(target=sync_task, daemon=True)
    |

E722 Do not use bare `except`
   --> desktop_app\views\scadenzario_view.py:203:17
    |
201 |                 try:
202 |                     return int(val) if val != "N/D" else 99999
203 |                 except:
    |                 ^^^^^^
204 |                     return 99999
    |

F821 Undefined name `e`
   --> desktop_app\views\scadenzario_view.py:242:78
    |
240 |             except Exception:
241 |                 if self.winfo_exists():
242 |                     self.after(0, lambda: messagebox.showerror("Errore", str(e)))
    |                                                                              ^
243 |
244 |         threading.Thread(target=fetch, daemon=True).start()
    |

E722 Do not use bare `except`
   --> desktop_app\views\scadenzario_view.py:340:17
    |
338 |                     delta = (dt - today).days
339 |                     days_str = str(delta)
340 |                 except:
    |                 ^^^^^^
341 |                     pass
342 |             else:
    |

F821 Undefined name `e`
   --> desktop_app\views\validation_view.py:480:78
    |
478 |             except Exception:
479 |                 if self.winfo_exists():
480 |                     self.after(0, lambda: messagebox.showerror("Errore", str(e)))
    |                                                                              ^
481 |
482 |         threading.Thread(target=fetch, daemon=True).start()
    |

I001 [*] Import block is un-sorted or un-formatted
  --> launcher.py:1:1
   |
 1 | / import argparse
 2 | | import logging
 3 | | import logging.handlers
 4 | | import os
 5 | | import socket
 6 | | import sys
 7 | | import threading
 8 | | import time
 9 | | import traceback as tb
10 | |
11 | | import uvicorn
12 | | from app.core.path_resolver import get_base_path, get_license_path
   | |__________________________________________________________________^
13 |
14 |   # REMOVED: sys.setrecursionlimit(5000) - Code smell removed.
   |
help: Organize imports

E741 Ambiguous variable name: `l`
  --> tests\app\api\routers\test_audit_edge_cases.py:31:44
   |
29 |     data = res.json()
30 |     assert len(data) >= 1
31 |     assert any(l["username"] == "late" for l in data)
   |                                            ^
   |

E741 Ambiguous variable name: `l`
  --> tests\app\api\test_audit_advanced.py:60:45
   |
58 |     data = resp.json()
59 |     assert len(data) == 2
60 |     assert all(l["username"] == "user1" for l in data)
   |                                             ^
61 |
62 |     # 3. Filter by Date Range (User 1 only recent)
   |

E741 Ambiguous variable name: `l`
  --> tests\app\api\test_audit_advanced.py:75:44
   |
73 |     data = resp.json()
74 |     assert len(data) == 2
75 |     assert all(l["category"] == "AUTH" for l in data)
   |                                            ^
76 |
77 |     # 5. Create Log via POST
   |

PERF401 Use `list.extend` to create a transformed list
  --> tests\app\api\test_update_cert_file_sync.py:74:17
   |
72 |         for root, _dirs, files in os.walk(str(test_dirs)):
73 |             for f in files:
74 |                 all_files.append(os.path.join(root, f))
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
75 |         raise AssertionError(
76 |             f"Expected file not found at {expected_new_path}. Actual files in system: {all_files}"
   |
help: Replace for loop with list.extend

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_db_security_advanced.py:90:5
   |
88 |       """Test that cleanup releases the lock."""
89 |       # We mock save_to_disk to avoid complexity
90 | /     with patch.object(db_manager, "save_to_disk") as mock_save:
91 | |         with patch.object(db_manager, "release_lock") as mock_release:
   | |______________________________________________________________________^
92 |               db_manager.cleanup()
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\app\core\test_db_security_advanced.py:132:5
    |
130 |       mock_file.__enter__.return_value = mock_file
131 |
132 | /     with (
133 | |         patch("pathlib.Path.exists", return_value=True),
134 | |         patch("builtins.open", return_value=mock_file),
135 | |         patch("psutil.pid_exists", return_value=False),
136 | |     ):
137 | |         with patch.object(db_manager, "_force_remove_lock") as mock_remove:
    | |___________________________________________________________________________^
138 |               db_manager._check_and_recover_stale_lock()
    |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_db_security_coverage.py:91:5
   |
89 |       mock_conn.deserialize.side_effect = Exception("Deserialize error")
90 |
91 | /     with patch("sqlite3.connect", return_value=mock_conn):
92 | |         with pytest.raises(RuntimeError, match="Failed to deserialize database"):
   | |_________________________________________________________________________________^
93 |               manager.get_connection()
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\app\core\test_db_security_coverage.py:103:5
    |
101 |       del mock_conn.deserialize  # Simula mancanza metodo (vecchio python/sqlite)
102 |
103 | /     with patch("sqlite3.connect", return_value=mock_conn):
104 | |         with pytest.raises(RuntimeError, match="does not support 'deserialize'"):
    | |_________________________________________________________________________________^
105 |               manager.get_connection()
    |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_db_security_deep_edges.py:63:5
   |
61 |       manager.db_path.write_text("data")
62 |
63 | /     with patch("builtins.open", side_effect=Exception("Read Error")):
64 | |         with pytest.raises(RuntimeError, match="Could not read database"):
   | |__________________________________________________________________________^
65 |               manager.load_memory_db()
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_db_security_failures.py:46:9
   |
45 |           # Mock opening the lock file with corrupt JSON
46 | /         with patch("builtins.open", mock_open(read_data=b"L{invalid_json")):
47 | |             # Patch os.remove on the module to ensure we catch the call
48 | |             with patch.object(db_security_module.os, "remove") as m_remove:
   | |___________________________________________________________________________^
49 |                   # Initialize manager (triggering the check)
50 |                   DBSecurityManager()
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_db_security_failures.py:61:9
   |
59 |           mock_file_content = b"L" + lock_data
60 |
61 | /         with patch("builtins.open", mock_open(read_data=mock_file_content)):
62 | |             with patch.object(db_security_module.psutil, "pid_exists", return_value=False):
   | |___________________________________________________________________________________________^
63 |                   with patch.object(db_security_module.os, "remove") as m_remove:
64 |                       DBSecurityManager()
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_db_security_failures.py:73:9
   |
71 |           mock_file_content = b"L" + lock_data
72 |
73 | /         with patch("builtins.open", mock_open(read_data=mock_file_content)):
74 | |             with patch.object(db_security_module.psutil, "pid_exists", return_value=True):
   | |__________________________________________________________________________________________^
75 |                   with patch.object(db_security_module.psutil, "Process") as m_proc:
76 |                       m_proc.return_value.name.return_value = "chrome.exe"
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_db_security_failures.py:86:9
   |
84 |           mock_file_content = b"L" + lock_data
85 |
86 | /         with patch("builtins.open", mock_open(read_data=mock_file_content)):
87 | |             with patch.object(db_security_module.psutil, "pid_exists", return_value=True):
   | |__________________________________________________________________________________________^
88 |                   with patch.object(db_security_module.psutil, "Process") as m_proc:
89 |                       m_proc.return_value.name.return_value = "python.exe"
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\app\core\test_db_security_failures.py:125:9
    |
123 |           mgr.db_path = MagicMock(exists=lambda: True)
124 |
125 | /         with patch("builtins.open", side_effect=PermissionError("Access Denied")):
126 | |             with self.assertRaises(RuntimeError):
    | |_________________________________________________^
127 |                   mgr.load_memory_db()
    |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\app\core\test_db_security_failures.py:161:9
    |
159 |           mgr.db_path = Path("/tmp/mock_data/db.db")
160 |
161 | /         with patch("builtins.open", mock_open()):
162 | |             with patch.object(db_security_module.os, "replace") as m_replace:
    | |_____________________________________________________________________________^
163 |                   # First 2 calls fail, 3rd succeeds
164 |                   m_replace.side_effect = [PermissionError, PermissionError, None]
    |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\app\core\test_db_security_failures.py:175:9
    |
173 |           mgr = DBSecurityManager()
174 |
175 | /         with patch("builtins.open", mock_open(read_data=b"NOT_A_DB_HEADER")):
176 | |             with patch("sqlite3.connect") as m_connect:
    | |_______________________________________________________^
177 |                   mock_conn = MagicMock()
178 |                   mock_cursor = MagicMock()
    |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_path_resolver.py:54:9
   |
52 |           fake_meipass = Path("C:/Temp/MEI123456")
53 |
54 | /         with patch.object(sys, "frozen", True, create=True):
55 | |             with patch.object(sys, "_MEIPASS", str(fake_meipass), create=True):
   | |_______________________________________________________________________________^
56 |                   # Reimport to pick up mocked values
57 |                   import app.core.path_resolver as pr
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\core\test_path_resolver.py:74:9
   |
72 |           expected_base = fake_exe.parent
73 |
74 | /         with patch.object(sys, "frozen", True, create=True):
75 | |             # Ensure _MEIPASS is NOT present (Nuitka mode)
76 | |             with patch.object(sys, "executable", str(fake_exe)):
   | |________________________________________________________________^
77 |                   # Remove _MEIPASS if it exists
78 |                   if hasattr(sys, "_MEIPASS"):
   |
help: Combine `with` statements

PERF401 Use a list comprehension to create a transformed list
  --> tests\app\db\test_db_infrastructure.py:69:13
   |
67 |     for call in mock_db.execute.mock_calls:
68 |         if call.args:
69 |             sql_executed.append(str(call.args[0]))
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |
71 |     assert any("previous_login" in sql for sql in sql_executed)
   |
help: Replace for loop with list comprehension

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\services\test_ai_extraction_extended.py:8:5
   |
 6 |   def test_gemini_client_singleton():
 7 |       GeminiClient._instance = None
 8 | /     with patch("app.services.ai_extraction.genai.GenerativeModel"):
 9 | |         with patch("app.services.ai_extraction.settings") as mock_settings:
   | |___________________________________________________________________________^
10 |               mock_settings.GEMINI_API_KEY_ANALYSIS = "fake_key"
11 |               c1 = GeminiClient()
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\services\test_ai_extraction_robustness.py:16:5
   |
14 |   def test_gemini_client_singleton():
15 |       GeminiClient._instance = None
16 | /     with patch("app.services.ai_extraction.genai.GenerativeModel"):
17 | |         with patch("app.services.ai_extraction.settings") as mock_settings:
   | |___________________________________________________________________________^
18 |               mock_settings.GEMINI_API_KEY_ANALYSIS = "key"
19 |               c1 = GeminiClient()
   |
help: Combine `with` statements

E721 Use `is` and `is not` for type comparisons, or `isinstance()` for isinstance checks
  --> tests\app\services\test_certificate_logic.py:28:12
   |
26 |     expiration_date = calculate_expiration_date(issue_date, validity_months)
27 |     # This assertion should fail before the fix because it will return a datetime object
28 |     assert type(expiration_date) == date
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

B018 Found useless attribute access. Either assign it to a variable or remove it.
   --> tests\app\services\test_certificate_logic.py:247:5
    |
245 |     # Per sicurezza, usiamo date relative a 'today' per il test robusto,
246 |     # ma per seguire lo scenario utente usiamo date fisse future per l'ultimo.
247 |     date.today().year
    |     ^^^^^^^^^^^^^^^^^
248 |     # Se siamo nel 2025 o dopo, questo funziona. Se siamo nel 2024, 2025 ├¿ futuro.
249 |     # Forziamo date relative per garantire il test passi sempre.
    |

SIM103 Return the condition directly
  --> tests\app\services\test_sync_service_orphans.py:32:9
   |
31 |       def side_effect_exists(path):
32 | /         if path == orphan_path:
33 | |             return True
34 | |         return False  # Destination does not exist
   | |____________________^
35 |
36 |       with (
   |
help: Inline condition

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\test_main_full.py:69:5
   |
67 |   @pytest.mark.anyio
68 |   async def test_lifespan_seeding_failure():
69 | /     with patch("app.main.db_security"):
70 | |         with patch("app.main.seed_database", side_effect=Exception("Seed Fail")):
   | |_________________________________________________________________________________^
71 |               with patch("app.main.AsyncIOScheduler"):
72 |                   async with lifespan(app):
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
   --> tests\app\test_main_full.py:99:5
    |
 97 |   def test_maintenance_task_failure():
 98 |       # If SessionLocal fails, it should propagate (or handle if we added handling)
 99 | /     with patch("app.main.SessionLocal", side_effect=Exception("DB Fail")):
100 | |         with pytest.raises(Exception, match="DB Fail"):
    | |_______________________________________________________^
101 |               run_maintenance_task()
    |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\app\test_new_category.py:24:5
   |
22 |       # Mock content preview (must be > 50 chars)
23 |       dummy_text = "Questo ├¿ un documento di nomina ufficiale per la sicurezza sul lavoro. " * 5
24 | /     with patch("app.utils.file_security.get_pdf_text_preview", return_value=dummy_text):
25 | |         # Mock the singleton instance return
26 | |         with patch("app.services.ai_extraction.GeminiClient") as mock_client_class:
   | |___________________________________________________________________________________^
27 |               mock_client = MagicMock()
28 |               mock_client.model = MagicMock()  # Ensure not None
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\core\test_path_resolver.py:21:5
   |
20 |   def test_get_base_path_pyinstaller():
21 | /     with patch.object(sys, "frozen", True, create=True):
22 | |         with patch.object(sys, "_MEIPASS", "/tmp/fake_meipass", create=True):
   | |_____________________________________________________________________________^
23 |               base = path_resolver.get_base_path()
24 |               assert base == Path("/tmp/fake_meipass")
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\core\test_path_resolver.py:40:5
   |
39 |   def test_get_user_data_path_windows():
40 | /     with patch("sys.platform", "win32"):
41 | |         with patch.dict(os.environ, {"LOCALAPPDATA": r"C:\FakeAppData"}):
   | |_________________________________________________________________________^
42 |               # Mock mkdir to avoid creating real folders
43 |               with patch("pathlib.Path.mkdir"):
   |
help: Combine `with` statements

SIM117 Use a single `with` statement with multiple contexts instead of nested `with` statements
  --> tests\core\test_path_resolver.py:57:5
   |
55 |       (base_path / "Licenza").mkdir(parents=True)
56 |
57 | /     with patch("app.core.path_resolver.get_user_data_path", return_value=user_data):
58 | |         with patch("app.core.path_resolver.get_base_path", return_value=base_path):
   | |___________________________________________________________________________________^
59 |               # 1. Neither has config.dat -> returns user_data/Licenza (default)
60 |               res = path_resolver.get_license_path()
   |
help: Combine `with` statements

E741 Ambiguous variable name: `l`
   --> tests\desktop_app\mock_qt.py:501:34
    |
499 |         pass
500 |
501 |     def setContentsMargins(self, l, t, r, b):  # NOSONAR
    |                                  ^
502 |         # Mock implementation
503 |         pass
    |

E722 Do not use bare `except`
    --> tests\desktop_app\mock_qt.py:1035:9
     |
1033 |                 d = datetime.datetime.strptime(s, "%d/%m/%Y").date()
1034 |                 return DummyQDate(d)
1035 |         except:
     |         ^^^^^^
1036 |             pass
1037 |         return DummyQDate()
     |

SIM103 Return the condition directly
  --> tests\tools\test_build_guide.py:18:9
   |
16 |           if "guide_frontend" in path and "dist" not in path:
17 |               return True  # guide dir exists
18 | /         if "index.html" in path:
19 | |             return True  # build result exists
20 | |         return False
   | |____________________^
21 |
22 |       mock_exists.side_effect = exists_side_effect
   |
help: Inline condition

Found 48 errors.
[*] 2 fixable with the `--fix` option.
