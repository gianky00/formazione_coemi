# üîß SonarCloud ULTRA-COMPLETE Fix Guide

**Progetto:** gianky00_formazione_coemi
**Data:** 2025-12-07 19:28
**Totale issues:** 665
**Tempo stimato totale:** 7g 6h 2min

## Istruzioni per Jules

Questo documento contiene **TUTTE** le informazioni per correggere ogni issue:
- üìç **Posizione esatta** (file + riga + colonne)
- üíª **Codice attuale** (snippet con contesto)
- ‚ùì **Perch√© √® un problema** (root cause)
- ‚úÖ **Come risolverlo** (con esempi di codice)
- üìö **Risorse** (link documentazione)

## Statistiche

| Categoria | Issues | Tempo | Descrizione |
|-----------|--------|-------|-------------|
| üî¥ RELIABILITY | 42 | 3h 30min | Bug che possono causare crash o comportamenti errati |
| üü° MAINTAINABILITY | 623 | 7g 2h 32min | Code smell che rendono il codice difficile da mantenere |

## Priorit√†

1. üü£ **SECURITY** - Vulnerabilit√† (rischio sicurezza)
2. üî¥ **RELIABILITY** - Bug (crash/errori)
3. üü° **MAINTAINABILITY** - Code smell

---

## üìÑ `guide_frontend/src/components/DashboardSimulator.jsx`
**18 issue(s)** | Effort: 1h 26min

‚ö†Ô∏è **üî¥ 10 RELIABILITY**

### Riga 97 üî¥ üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-112 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     95:       {/* Table Header */}
     96:       &lt;div className="grid grid-cols-5 bg-gray-100 p-3 text-xs font-bold text-gray-500 uppercase tracking-wider border-b border-gray-200"&gt;
 >>> 97:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('dipendente')}&gt;
     98:             Dipendente {getSortIcon('dipendente')}
     99:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 97 üî¥ üü¢ MINOR

**üéØ Problema:** Visible, non-interactive elements with click handlers must have at least one keyboard listener.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1082` - Mouse events should have corresponding keyboard events |
| Categoria | RELIABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-112 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     95:       {/* Table Header */}
     96:       &lt;div className="grid grid-cols-5 bg-gray-100 p-3 text-xs font-bold text-gray-500 uppercase tracking-wider border-b border-gray-200"&gt;
 >>> 97:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('dipendente')}&gt;
     98:             Dipendente {getSortIcon('dipendente')}
     99:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Offering the same experience with the mouse and the keyboard allow users to pick their preferred devices.

Additionally, users of assistive technology will also be able to browse the site even if they cannot use the mouse.

This rules detects the following issues:

 - when `onClick` is not accompanied by at least one of the following: `onKeyUp`, `onKeyDown`,
 `onKeyPress`. 

 - when `onmouseover`/`onmouseout` are not paired by `onfocus`/`onblur`.

**‚úÖ Come risolvere:**

Add at least one of the following event handlers `onKeyUp`, `onKeyDown`, `onKeyPress` to the element when using
`onClick` event handler. Add corresponding event handlers `onfocus`/`onblur` to the element when using
`onmouseover`/`onmouseout` event handlers.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;

&lt;div onMouseOver={ () =&gt; {}} } /&gt;
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} onKeyDown={this.handleKeyDown} /&gt;

&lt;div onMouseOver={ () =&gt; {} } onFocus={ () =&gt; {} } /&gt;
```

### Exceptions

This does not apply for interactive or hidden elements, eg. when using `aria-hidden="true"` attribute.

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [mouse-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/mouse-events-have-key-events.md)
 

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [click-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/click-events-have-key-events.md)
 

 - SCR2 - [Using redundant keyboard and mouse event handlers](https://www.w3.org/TR/WCAG20-TECHS/SCR2.html) 

 - G90 - [...

---

### Riga 100 üî¥ üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-107 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     98:             Dipendente {getSortIcon('dipendente')}
     99:         &lt;/div&gt;
 >>> 100:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('corso')}&gt;
     101:             Documento {getSortIcon('corso')}
     102:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 100 üî¥ üü¢ MINOR

**üéØ Problema:** Visible, non-interactive elements with click handlers must have at least one keyboard listener.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1082` - Mouse events should have corresponding keyboard events |
| Categoria | RELIABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-107 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     98:             Dipendente {getSortIcon('dipendente')}
     99:         &lt;/div&gt;
 >>> 100:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('corso')}&gt;
     101:             Documento {getSortIcon('corso')}
     102:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Offering the same experience with the mouse and the keyboard allow users to pick their preferred devices.

Additionally, users of assistive technology will also be able to browse the site even if they cannot use the mouse.

This rules detects the following issues:

 - when `onClick` is not accompanied by at least one of the following: `onKeyUp`, `onKeyDown`,
 `onKeyPress`. 

 - when `onmouseover`/`onmouseout` are not paired by `onfocus`/`onblur`.

**‚úÖ Come risolvere:**

Add at least one of the following event handlers `onKeyUp`, `onKeyDown`, `onKeyPress` to the element when using
`onClick` event handler. Add corresponding event handlers `onfocus`/`onblur` to the element when using
`onmouseover`/`onmouseout` event handlers.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;

&lt;div onMouseOver={ () =&gt; {}} } /&gt;
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} onKeyDown={this.handleKeyDown} /&gt;

&lt;div onMouseOver={ () =&gt; {} } onFocus={ () =&gt; {} } /&gt;
```

### Exceptions

This does not apply for interactive or hidden elements, eg. when using `aria-hidden="true"` attribute.

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [mouse-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/mouse-events-have-key-events.md)
 

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [click-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/click-events-have-key-events.md)
 

 - SCR2 - [Using redundant keyboard and mouse event handlers](https://www.w3.org/TR/WCAG20-TECHS/SCR2.html) 

 - G90 - [...

---

### Riga 103 üî¥ üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-106 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     101:             Documento {getSortIcon('corso')}
     102:         &lt;/div&gt;
 >>> 103:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('data')}&gt;
     104:             Data Ril. {getSortIcon('data')}
     105:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 103 üî¥ üü¢ MINOR

**üéØ Problema:** Visible, non-interactive elements with click handlers must have at least one keyboard listener.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1082` - Mouse events should have corresponding keyboard events |
| Categoria | RELIABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-106 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     101:             Documento {getSortIcon('corso')}
     102:         &lt;/div&gt;
 >>> 103:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('data')}&gt;
     104:             Data Ril. {getSortIcon('data')}
     105:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Offering the same experience with the mouse and the keyboard allow users to pick their preferred devices.

Additionally, users of assistive technology will also be able to browse the site even if they cannot use the mouse.

This rules detects the following issues:

 - when `onClick` is not accompanied by at least one of the following: `onKeyUp`, `onKeyDown`,
 `onKeyPress`. 

 - when `onmouseover`/`onmouseout` are not paired by `onfocus`/`onblur`.

**‚úÖ Come risolvere:**

Add at least one of the following event handlers `onKeyUp`, `onKeyDown`, `onKeyPress` to the element when using
`onClick` event handler. Add corresponding event handlers `onfocus`/`onblur` to the element when using
`onmouseover`/`onmouseout` event handlers.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;

&lt;div onMouseOver={ () =&gt; {}} } /&gt;
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} onKeyDown={this.handleKeyDown} /&gt;

&lt;div onMouseOver={ () =&gt; {} } onFocus={ () =&gt; {} } /&gt;
```

### Exceptions

This does not apply for interactive or hidden elements, eg. when using `aria-hidden="true"` attribute.

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [mouse-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/mouse-events-have-key-events.md)
 

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [click-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/click-events-have-key-events.md)
 

 - SCR2 - [Using redundant keyboard and mouse event handlers](https://www.w3.org/TR/WCAG20-TECHS/SCR2.html) 

 - G90 - [...

---

### Riga 106 üî¥ üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-110 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     104:             Data Ril. {getSortIcon('data')}
     105:         &lt;/div&gt;
 >>> 106:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('scadenza')}&gt;
     107:             Scadenza {getSortIcon('scadenza')}
     108:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 106 üî¥ üü¢ MINOR

**üéØ Problema:** Visible, non-interactive elements with click handlers must have at least one keyboard listener.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1082` - Mouse events should have corresponding keyboard events |
| Categoria | RELIABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-110 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     104:             Data Ril. {getSortIcon('data')}
     105:         &lt;/div&gt;
 >>> 106:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('scadenza')}&gt;
     107:             Scadenza {getSortIcon('scadenza')}
     108:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Offering the same experience with the mouse and the keyboard allow users to pick their preferred devices.

Additionally, users of assistive technology will also be able to browse the site even if they cannot use the mouse.

This rules detects the following issues:

 - when `onClick` is not accompanied by at least one of the following: `onKeyUp`, `onKeyDown`,
 `onKeyPress`. 

 - when `onmouseover`/`onmouseout` are not paired by `onfocus`/`onblur`.

**‚úÖ Come risolvere:**

Add at least one of the following event handlers `onKeyUp`, `onKeyDown`, `onKeyPress` to the element when using
`onClick` event handler. Add corresponding event handlers `onfocus`/`onblur` to the element when using
`onmouseover`/`onmouseout` event handlers.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;

&lt;div onMouseOver={ () =&gt; {}} } /&gt;
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} onKeyDown={this.handleKeyDown} /&gt;

&lt;div onMouseOver={ () =&gt; {} } onFocus={ () =&gt; {} } /&gt;
```

### Exceptions

This does not apply for interactive or hidden elements, eg. when using `aria-hidden="true"` attribute.

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [mouse-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/mouse-events-have-key-events.md)
 

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [click-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/click-events-have-key-events.md)
 

 - SCR2 - [Using redundant keyboard and mouse event handlers](https://www.w3.org/TR/WCAG20-TECHS/SCR2.html) 

 - G90 - [...

---

### Riga 152 üî¥ üü° MAJOR

**üéØ Problema:** Ambiguous spacing before next element span

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6772` - Spacing between inline elements should be explicit |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Tags | react |

**üíª Codice attuale:**
```jsx
     150:           &lt;div className="flex gap-2"&gt;
     151:              &lt;span className="w-2 h-2 rounded-full bg-green-500 inline-block"&gt;&lt;/span&gt; Attivo
 >>> 152:              &lt;span className="w-2 h-2 rounded-full bg-yellow-500 inline-block"&gt;&lt;/span&gt; In Scadenza
     153:              &lt;span className="w-2 h-2 rounded-full bg-red-500 inline-block"&gt;&lt;/span&gt; Scaduto
     154:           &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

React JSX differs from the HTML standard in the way it handles newline characters and surrounding whitespace. HTML collapses multiple whitespace
characters (including newlines) into a single whitespace, but JSX removes such sequences completely, leaving no space between inline elements
separated by the line break. This difference in behavior can be confusing and may result in unintended layout, for example, missing whitespace between
the link content and the surrounding text.

To avoid such issues, you should never rely on newline characters in JSX, and explicitly specify whether you want whitespace between inline
elements separated by a line break.

```
&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 Here is some
 &lt;a&gt;space&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 &lt;a&gt;No space&lt;/a&gt;
 between these
&lt;/div&gt;
```

To fix the issue, either insert an explicit JSX space as a string expression `{' '}`, or insert an empty comment expres...

**üìù Descrizione:**

### Why is this an issue?

React JSX differs from the HTML standard in the way it handles newline characters and surrounding whitespace. HTML collapses multiple whitespace
characters (including newlines) into a single whitespace, but JSX removes such sequences completely, leaving no space between inline elements
separated by the line break. This difference in behavior can be confusing and may result in unintended layout, for example, missing whitespace between
the link content and the surrounding text.

To avoid such issues, you should never rely on newline characters in JSX, and explicitly specify whether you want whitespace between inline
elements separated by a line break.

```
&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 Here is some
 &lt;a&gt;space&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 &lt;a&gt;No space&lt;/a&gt;
 between these
&lt;/div&gt;
```

To fix the issue, either insert an explicit JSX space as a string expression `{' '}`, or ins...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [jsx-child-element-spacing](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/jsx-child-element-spacing.md) 

 - React Documentation - [Writing markup with JSX](https://react.dev/learn#writing-markup-with-jsx) 

 - MDN web docs - Spaces
 in between inline and inline-block elements

---

### Riga 153 üî¥ üü° MAJOR

**üéØ Problema:** Ambiguous spacing before next element span

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6772` - Spacing between inline elements should be explicit |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Tags | react |

**üíª Codice attuale:**
```jsx
     151:              &lt;span className="w-2 h-2 rounded-full bg-green-500 inline-block"&gt;&lt;/span&gt; Attivo
     152:              &lt;span className="w-2 h-2 rounded-full bg-yellow-500 inline-block"&gt;&lt;/span&gt; In Scadenza
 >>> 153:              &lt;span className="w-2 h-2 rounded-full bg-red-500 inline-block"&gt;&lt;/span&gt; Scaduto
     154:           &lt;/div&gt;
     155:       &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

React JSX differs from the HTML standard in the way it handles newline characters and surrounding whitespace. HTML collapses multiple whitespace
characters (including newlines) into a single whitespace, but JSX removes such sequences completely, leaving no space between inline elements
separated by the line break. This difference in behavior can be confusing and may result in unintended layout, for example, missing whitespace between
the link content and the surrounding text.

To avoid such issues, you should never rely on newline characters in JSX, and explicitly specify whether you want whitespace between inline
elements separated by a line break.

```
&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 Here is some
 &lt;a&gt;space&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 &lt;a&gt;No space&lt;/a&gt;
 between these
&lt;/div&gt;
```

To fix the issue, either insert an explicit JSX space as a string expression `{' '}`, or insert an empty comment expres...

**üìù Descrizione:**

### Why is this an issue?

React JSX differs from the HTML standard in the way it handles newline characters and surrounding whitespace. HTML collapses multiple whitespace
characters (including newlines) into a single whitespace, but JSX removes such sequences completely, leaving no space between inline elements
separated by the line break. This difference in behavior can be confusing and may result in unintended layout, for example, missing whitespace between
the link content and the surrounding text.

To avoid such issues, you should never rely on newline characters in JSX, and explicitly specify whether you want whitespace between inline
elements separated by a line break.

```
&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 Here is some
 &lt;a&gt;space&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 &lt;a&gt;No space&lt;/a&gt;
 between these
&lt;/div&gt;
```

To fix the issue, either insert an explicit JSX space as a string expression `{' '}`, or ins...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [jsx-child-element-spacing](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/jsx-child-element-spacing.md) 

 - React Documentation - [Writing markup with JSX](https://react.dev/learn#writing-markup-with-jsx) 

 - MDN web docs - Spaces
 in between inline and inline-block elements

---

### Riga 2 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'AnimatePresence'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 17-32 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     1: import React, { useState } from 'react';
 >>> 2: import { motion, AnimatePresence } from 'framer-motion';
     3: import { Search, Filter, RefreshCw, Edit2, Trash2 } from 'lucide-react';
     4: import Badge from './ui/Badge';
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 97 üü° üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-112 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     95:       {/* Table Header */}
     96:       &lt;div className="grid grid-cols-5 bg-gray-100 p-3 text-xs font-bold text-gray-500 uppercase tracking-wider border-b border-gray-200"&gt;
 >>> 97:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('dipendente')}&gt;
     98:             Dipendente {getSortIcon('dipendente')}
     99:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 100 üü° üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-107 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     98:             Dipendente {getSortIcon('dipendente')}
     99:         &lt;/div&gt;
 >>> 100:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('corso')}&gt;
     101:             Documento {getSortIcon('corso')}
     102:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 103 üü° üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-106 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     101:             Documento {getSortIcon('corso')}
     102:         &lt;/div&gt;
 >>> 103:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('data')}&gt;
     104:             Data Ril. {getSortIcon('data')}
     105:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 106 üü° üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-110 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     104:             Data Ril. {getSortIcon('data')}
     105:         &lt;/div&gt;
 >>> 106:         &lt;div className="col-span-1 cursor-pointer hover:text-gray-700" onClick={() =&gt; handleSort('scadenza')}&gt;
     107:             Scadenza {getSortIcon('scadenza')}
     108:         &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 133 üü° üü° MAJOR

**üéØ Problema:** Extract this nested ternary operation into an independent statement.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S3358` - Ternary operators should not be nested |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 72-122 |
| Tags | confusing |

**üíª Codice attuale:**
```jsx
     131:                 &lt;div className="col-span-1 text-gray-500 flex items-center text-xs font-mono"&gt;{row.scadenza}&lt;/div&gt;
     132:                 &lt;div className="col-span-1 flex items-center justify-center"&gt;
 >>> 133:                    &lt;Badge variant={row.stato === 'attivo' ? 'success' : row.stato === 'in_scadenza' ? 'warning' : 'danger'}&gt;
     134:                       {row.stato.replace('_', ' ').toUpperCase()}
     135:                    &lt;/Badge&gt;
```

**‚ùì Perch√© √® un problema:**

Nested ternaries are hard to read and can make the order of operations complex to understand.

```
function getReadableStatus(job) {
 return job.isRunning() ? "Running" : job.hasErrors() ? "Failed" : "Succeeded "; // Noncompliant
}
```

Instead, use another line to express the nested operation in a separate statement.

```
function getReadableStatus(job) {
 if (job.isRunning()) {
 return "Running";
 }
 return job.hasErrors() ? "Failed" : "Succeeded";
}
```

#### Exceptions

This rule does not apply in JSX expressions to support conditional rendering and conditional attributes as long as the nesting happens in separate
JSX expression containers, i.e. JSX elements embedding JavaScript code, as shown below:

```
return (
&lt;&gt;
 {isLoading ? (
 &lt;Loader active /&gt;
 ) : (
 &lt;Panel label={isEditing ? 'Open' : 'Not open'}&gt;
 &lt;a&gt;{isEditing ? 'Close now' : 'Start now'}&lt;/a&gt;
 &lt;Checkbox onClick={!saving ? setSaving(saving =&gt; !saving) : null} /&gt;
 &lt;/Panel&gt;
 )}
&...

**üìù Descrizione:**

### Why is this an issue?

Nested ternaries are hard to read and can make the order of operations complex to understand.

```
function getReadableStatus(job) {
 return job.isRunning() ? "Running" : job.hasErrors() ? "Failed" : "Succeeded "; // Noncompliant
}
```

Instead, use another line to express the nested operation in a separate statement.

```
function getReadableStatus(job) {
 if (job.isRunning()) {
 return "Running";
 }
 return job.hasErrors() ? "Failed" : "Succeeded";
}
```

#### Exceptions

This rule does not apply in JSX expressions to support conditional rendering and conditional attributes as long as the nesting happens in separate
JSX expression containers, i.e. JSX elements embedding JavaScript code, as shown below:

```
return (
&lt;&gt;
 {isLoading ? (
 &lt;Loader active /&gt;
 ) : (
 &lt;Panel label={isEditing ? 'Open' : 'Not open'}&gt;
 &lt;a&gt;{isEditing ? 'Close now' : 'Start now'}&lt;/a&gt;
 &lt;Checkbox onClick={!saving ? setSaving(saving =&gt; !saving) : null} ...

**üìö Risorse:**

#### Articles & blog posts

 - Sonar - [Stop nesting ternaries in JavaScript](https://www.sonarsource.com/blog/stop-nesting-ternaries-javascript/)

---

### Riga 152 üü° üü° MAJOR

**üéØ Problema:** Ambiguous spacing before next element span

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6772` - Spacing between inline elements should be explicit |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Tags | react |

**üíª Codice attuale:**
```jsx
     150:           &lt;div className="flex gap-2"&gt;
     151:              &lt;span className="w-2 h-2 rounded-full bg-green-500 inline-block"&gt;&lt;/span&gt; Attivo
 >>> 152:              &lt;span className="w-2 h-2 rounded-full bg-yellow-500 inline-block"&gt;&lt;/span&gt; In Scadenza
     153:              &lt;span className="w-2 h-2 rounded-full bg-red-500 inline-block"&gt;&lt;/span&gt; Scaduto
     154:           &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

React JSX differs from the HTML standard in the way it handles newline characters and surrounding whitespace. HTML collapses multiple whitespace
characters (including newlines) into a single whitespace, but JSX removes such sequences completely, leaving no space between inline elements
separated by the line break. This difference in behavior can be confusing and may result in unintended layout, for example, missing whitespace between
the link content and the surrounding text.

To avoid such issues, you should never rely on newline characters in JSX, and explicitly specify whether you want whitespace between inline
elements separated by a line break.

```
&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 Here is some
 &lt;a&gt;space&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 &lt;a&gt;No space&lt;/a&gt;
 between these
&lt;/div&gt;
```

To fix the issue, either insert an explicit JSX space as a string expression `{' '}`, or insert an empty comment expres...

**üìù Descrizione:**

### Why is this an issue?

React JSX differs from the HTML standard in the way it handles newline characters and surrounding whitespace. HTML collapses multiple whitespace
characters (including newlines) into a single whitespace, but JSX removes such sequences completely, leaving no space between inline elements
separated by the line break. This difference in behavior can be confusing and may result in unintended layout, for example, missing whitespace between
the link content and the surrounding text.

To avoid such issues, you should never rely on newline characters in JSX, and explicitly specify whether you want whitespace between inline
elements separated by a line break.

```
&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 Here is some
 &lt;a&gt;space&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 &lt;a&gt;No space&lt;/a&gt;
 between these
&lt;/div&gt;
```

To fix the issue, either insert an explicit JSX space as a string expression `{' '}`, or ins...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [jsx-child-element-spacing](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/jsx-child-element-spacing.md) 

 - React Documentation - [Writing markup with JSX](https://react.dev/learn#writing-markup-with-jsx) 

 - MDN web docs - Spaces
 in between inline and inline-block elements

---

### Riga 153 üü° üü° MAJOR

**üéØ Problema:** Ambiguous spacing before next element span

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6772` - Spacing between inline elements should be explicit |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Tags | react |

**üíª Codice attuale:**
```jsx
     151:              &lt;span className="w-2 h-2 rounded-full bg-green-500 inline-block"&gt;&lt;/span&gt; Attivo
     152:              &lt;span className="w-2 h-2 rounded-full bg-yellow-500 inline-block"&gt;&lt;/span&gt; In Scadenza
 >>> 153:              &lt;span className="w-2 h-2 rounded-full bg-red-500 inline-block"&gt;&lt;/span&gt; Scaduto
     154:           &lt;/div&gt;
     155:       &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

React JSX differs from the HTML standard in the way it handles newline characters and surrounding whitespace. HTML collapses multiple whitespace
characters (including newlines) into a single whitespace, but JSX removes such sequences completely, leaving no space between inline elements
separated by the line break. This difference in behavior can be confusing and may result in unintended layout, for example, missing whitespace between
the link content and the surrounding text.

To avoid such issues, you should never rely on newline characters in JSX, and explicitly specify whether you want whitespace between inline
elements separated by a line break.

```
&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 Here is some
 &lt;a&gt;space&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 &lt;a&gt;No space&lt;/a&gt;
 between these
&lt;/div&gt;
```

To fix the issue, either insert an explicit JSX space as a string expression `{' '}`, or insert an empty comment expres...

**üìù Descrizione:**

### Why is this an issue?

React JSX differs from the HTML standard in the way it handles newline characters and surrounding whitespace. HTML collapses multiple whitespace
characters (including newlines) into a single whitespace, but JSX removes such sequences completely, leaving no space between inline elements
separated by the line break. This difference in behavior can be confusing and may result in unintended layout, for example, missing whitespace between
the link content and the surrounding text.

To avoid such issues, you should never rely on newline characters in JSX, and explicitly specify whether you want whitespace between inline
elements separated by a line break.

```
&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 Here is some
 &lt;a&gt;space&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;{/* Noncompliant: ambiguous spacing */}
 &lt;a&gt;No space&lt;/a&gt;
 between these
&lt;/div&gt;
```

To fix the issue, either insert an explicit JSX space as a string expression `{' '}`, or ins...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [jsx-child-element-spacing](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/jsx-child-element-spacing.md) 

 - React Documentation - [Writing markup with JSX](https://react.dev/learn#writing-markup-with-jsx) 

 - MDN web docs - Spaces
 in between inline and inline-block elements

---

## üìÑ `guide_frontend/src/components/ui/Accordion.jsx`
**14 issue(s)** | Effort: 1h 6min

‚ö†Ô∏è **üî¥ 6 RELIABILITY**

### Riga 6 üî¥ üü° MAJOR

**üéØ Problema:** 'title' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 25-30 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     4: import clsx from 'clsx';
     5: 
 >>> 6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
     7:   return (
     8:     &lt;div className="border border-gray-200 rounded-lg bg-white overflow-hidden mb-3 shadow-sm hover:shadow-md transition-shadow"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 6 üî¥ üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 32-40 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     4: import clsx from 'clsx';
     5: 
 >>> 6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
     7:   return (
     8:     &lt;div className="border border-gray-200 rounded-lg bg-white overflow-hidden mb-3 shadow-sm hover:shadow-md transition-shadow"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 6 üî¥ üü° MAJOR

**üéØ Problema:** 'isOpen' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 42-48 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     4: import clsx from 'clsx';
     5: 
 >>> 6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
     7:   return (
     8:     &lt;div className="border border-gray-200 rounded-lg bg-white overflow-hidden mb-3 shadow-sm hover:shadow-md transition-shadow"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 6 üî¥ üü° MAJOR

**üéØ Problema:** 'onClick' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 50-57 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     4: import clsx from 'clsx';
     5: 
 >>> 6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
     7:   return (
     8:     &lt;div className="border border-gray-200 rounded-lg bg-white overflow-hidden mb-3 shadow-sm hover:shadow-md transition-shadow"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 40 üî¥ üü° MAJOR

**üéØ Problema:** 'items' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-26 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     38: };
     39: 
 >>> 40: const Accordion = ({ items }) =&gt; {
     41:   const [openIndex, setOpenIndex] = useState(null);
     42: 
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 49 üî¥ üü° MAJOR

**üéØ Problema:** 'items.map' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 13-16 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     47:   return (
     48:     &lt;div className="w-full"&gt;
 >>> 49:       {items.map((item, index) =&gt; (
     50:         &lt;AccordionItem
     51:           key={index}
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'clsx'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 7-11 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     2: import { motion, AnimatePresence } from 'framer-motion';
     3: import { ChevronDown } from 'lucide-react';
 >>> 4: import clsx from 'clsx';
     5: 
     6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 6 üü° üü° MAJOR

**üéØ Problema:** 'title' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 25-30 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     4: import clsx from 'clsx';
     5: 
 >>> 6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
     7:   return (
     8:     &lt;div className="border border-gray-200 rounded-lg bg-white overflow-hidden mb-3 shadow-sm hover:shadow-md transition-shadow"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 6 üü° üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 32-40 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     4: import clsx from 'clsx';
     5: 
 >>> 6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
     7:   return (
     8:     &lt;div className="border border-gray-200 rounded-lg bg-white overflow-hidden mb-3 shadow-sm hover:shadow-md transition-shadow"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 6 üü° üü° MAJOR

**üéØ Problema:** 'isOpen' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 42-48 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     4: import clsx from 'clsx';
     5: 
 >>> 6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
     7:   return (
     8:     &lt;div className="border border-gray-200 rounded-lg bg-white overflow-hidden mb-3 shadow-sm hover:shadow-md transition-shadow"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 6 üü° üü° MAJOR

**üéØ Problema:** 'onClick' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 50-57 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     4: import clsx from 'clsx';
     5: 
 >>> 6: const AccordionItem = ({ title, children, isOpen, onClick }) =&gt; {
     7:   return (
     8:     &lt;div className="border border-gray-200 rounded-lg bg-white overflow-hidden mb-3 shadow-sm hover:shadow-md transition-shadow"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 40 üü° üü° MAJOR

**üéØ Problema:** 'items' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-26 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     38: };
     39: 
 >>> 40: const Accordion = ({ items }) =&gt; {
     41:   const [openIndex, setOpenIndex] = useState(null);
     42: 
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 49 üü° üü° MAJOR

**üéØ Problema:** 'items.map' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 13-16 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     47:   return (
     48:     &lt;div className="w-full"&gt;
 >>> 49:       {items.map((item, index) =&gt; (
     50:         &lt;AccordionItem
     51:           key={index}
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 51 üü° üü° MAJOR

**üéØ Problema:** Do not use Array index in keys

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6479` - JSX list components should not use array indexes as key |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 15-20 |
| Tags | jsx, performance, react |

**üíª Codice attuale:**
```jsx
     49:       {items.map((item, index) =&gt; (
     50:         &lt;AccordionItem
 >>> 51:           key={index}
     52:           title={item.title}
     53:           isOpen={openIndex === index}
```

**‚ùì Perch√© √® un problema:**

To optimize the rendering of React list components, a unique identifier (UID) is required for each list item. This UID lets React identify the item
throughout its lifetime. Avoid array indexes since the order of the items may change, which will cause keys to not match up between renders,
recreating the DOM. It can negatively impact performance and may cause issues with the component state.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((post, index) =&gt;
 &lt;li key={index}&gt; &lt;!-- Noncompliant: When 'posts' are reordered, React will need to recreate the list DOM --&gt;
 {post.title}
 &lt;/li&gt;
 )}
 &lt;/ul&gt;
 );
}
```

To fix it, use a string or a number that uniquely identifies the list item. The key must be unique among its siblings, not globally.

If the data comes from a database, database IDs are already unique and are the best option. Otherwise, use a counter or a UUID generator.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((p...

**üìù Descrizione:**

### Why is this an issue?

To optimize the rendering of React list components, a unique identifier (UID) is required for each list item. This UID lets React identify the item
throughout its lifetime. Avoid array indexes since the order of the items may change, which will cause keys to not match up between renders,
recreating the DOM. It can negatively impact performance and may cause issues with the component state.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((post, index) =&gt;
 &lt;li key={index}&gt; &lt;!-- Noncompliant: When 'posts' are reordered, React will need to recreate the list DOM --&gt;
 {post.title}
 &lt;/li&gt;
 )}
 &lt;/ul&gt;
 );
}
```

To fix it, use a string or a number that uniquely identifies the list item. The key must be unique among its siblings, not globally.

If the data comes from a database, database IDs are already unique and are the best option. Otherwise, use a counter or a UUID generator.

```
function Blog(props) {
 return (
 &lt;...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [no-array-index-key](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/no-array-index-key.md) 

 - React Documentation - [Rendering lists](https://react.dev/learn/rendering-lists#rules-of-keys) 

 - React Documentation - [Recursing On Children](https://reactjs.org/docs/reconciliation.html#recursing-on-children) 

 - MDN web docs - [Crypto: randomUUID() method](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID) 

 - Wikipedia - [UUID](https://en.wikipedia....

---

## üìÑ `guide_frontend/src/components/Sidebar.jsx`
**15 issue(s)** | Effort: 59min

‚ö†Ô∏è **üî¥ 5 RELIABILITY**

### Riga 23 üî¥ üü° MAJOR

**üéØ Problema:** 'icon' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-33 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     21: import clsx from 'clsx';
     22: 
 >>> 23: const SidebarItem = ({ icon: Icon, label, to, collapsed }) =&gt; {
     24:   const location = useLocation();
     25:   const isActive = location.pathname === to;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 23 üî¥ üü° MAJOR

**üéØ Problema:** 'label' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 35-40 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     21: import clsx from 'clsx';
     22: 
 >>> 23: const SidebarItem = ({ icon: Icon, label, to, collapsed }) =&gt; {
     24:   const location = useLocation();
     25:   const isActive = location.pathname === to;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 23 üî¥ üü° MAJOR

**üéØ Problema:** 'to' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 42-44 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     21: import clsx from 'clsx';
     22: 
 >>> 23: const SidebarItem = ({ icon: Icon, label, to, collapsed }) =&gt; {
     24:   const location = useLocation();
     25:   const isActive = location.pathname === to;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 23 üî¥ üü° MAJOR

**üéØ Problema:** 'collapsed' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 46-55 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     21: import clsx from 'clsx';
     22: 
 >>> 23: const SidebarItem = ({ icon: Icon, label, to, collapsed }) =&gt; {
     24:   const location = useLocation();
     25:   const isActive = location.pathname === to;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 64 üî¥ üü° MAJOR

**üéØ Problema:** Either remove this useless object instantiation of "window.QWebChannel" or use it.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1848` - Objects should not be created to be dropped immediately without being used |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 6-28 |

**üíª Codice attuale:**
```jsx
     62:   useEffect(() =&gt; {
     63:     if (window.qt &amp;&amp; window.qt.webChannelTransport) {
 >>> 64:       new window.QWebChannel(window.qt.webChannelTransport, function(channel) {
     65:         if (channel.objects.bridge) {
     66:             setBridge(channel.objects.bridge);
```

**‚ùì Perch√© √® un problema:**

Creating an object without assigning it to a variable or using it in any function means the object is essentially created for no reason and may be
dropped immediately without being used. Most of the time, this is due to a missing piece of code and could lead to an unexpected behavior.

If it‚Äôs intended because the constructor has side effects, that side effect should be moved into a separate method and called directly. This can
help to improve the performance and readability of the code.

```
new MyConstructor(); // Noncompliant: object may be dropped
```

Determine if the objects are necessary for the code to function correctly. If they are not required, remove them from the code. Otherwise, assign
them to a variable for later use.

```
let something = new MyConstructor();
```

#### Exceptions

 - Creating new objects inside a `try` block is ignored. 

```
try {
 new MyConstructor();
} catch (e) {
 /* ... */
}
```

 - Known constructors with side effects like `Notification` or `Vue` a...

**üìù Descrizione:**

### Why is this an issue?

Creating an object without assigning it to a variable or using it in any function means the object is essentially created for no reason and may be
dropped immediately without being used. Most of the time, this is due to a missing piece of code and could lead to an unexpected behavior.

If it‚Äôs intended because the constructor has side effects, that side effect should be moved into a separate method and called directly. This can
help to improve the performance and readability of the code.

```
new MyConstructor(); // Noncompliant: object may be dropped
```

Determine if the objects are necessary for the code to function correctly. If they are not required, remove them from the code. Otherwise, assign
them to a variable for later use.

```
let something = new MyConstructor();
```

#### Exceptions

 - Creating new objects inside a `try` block is ignored. 

```
try {
 new MyConstructor();
} catch (e) {
 /* ... */
}
```

 - Known constructors with side effects lik...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`Object.prototype.constructor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) 

 - MDN web docs - [constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor) 

 - MDN web docs - [`new` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new)

---

### Riga 20 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'AnimatePresence'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 17-32 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     18:   Keyboard
     19: } from 'lucide-react';
 >>> 20: import { motion, AnimatePresence } from 'framer-motion';
     21: import clsx from 'clsx';
     22: 
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 23 üü° üü° MAJOR

**üéØ Problema:** 'icon' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-33 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     21: import clsx from 'clsx';
     22: 
 >>> 23: const SidebarItem = ({ icon: Icon, label, to, collapsed }) =&gt; {
     24:   const location = useLocation();
     25:   const isActive = location.pathname === to;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 23 üü° üü° MAJOR

**üéØ Problema:** 'label' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 35-40 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     21: import clsx from 'clsx';
     22: 
 >>> 23: const SidebarItem = ({ icon: Icon, label, to, collapsed }) =&gt; {
     24:   const location = useLocation();
     25:   const isActive = location.pathname === to;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 23 üü° üü° MAJOR

**üéØ Problema:** 'to' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 42-44 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     21: import clsx from 'clsx';
     22: 
 >>> 23: const SidebarItem = ({ icon: Icon, label, to, collapsed }) =&gt; {
     24:   const location = useLocation();
     25:   const isActive = location.pathname === to;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 23 üü° üü° MAJOR

**üéØ Problema:** 'collapsed' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 46-55 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     21: import clsx from 'clsx';
     22: 
 >>> 23: const SidebarItem = ({ icon: Icon, label, to, collapsed }) =&gt; {
     24:   const location = useLocation();
     25:   const isActive = location.pathname === to;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 63 üü° üü¢ MINOR

**üéØ Problema:** Prefer `globalThis` over `window`.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S7764` - Use "globalThis" instead of "window", "self", or "global" |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-14 |
| Tags | es2020, portability |

**üíª Codice attuale:**
```jsx
     61: 
     62:   useEffect(() =&gt; {
 >>> 63:     if (window.qt &amp;&amp; window.qt.webChannelTransport) {
     64:       new window.QWebChannel(window.qt.webChannelTransport, function(channel) {
     65:         if (channel.objects.bridge) {
```

**‚ùì Perch√© √® un problema:**

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
properties.

#### What is the potential impact?

Using environment-specific global references reduces code portability and can cause runtime errors when code is moved between different...

**üìù Descrizione:**

This rule raises an issue when code uses `window`, `self`, or `global` to access the global object, except for
environment-specific APIs and events.

### Why is this an issue?

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
propert...

---

### Riga 63 üü° üü° MAJOR

**üéØ Problema:** Prefer using an optional chain expression instead, as it's more concise and easier to read.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6582` - Optional chaining should be preferred |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-50 |

**üíª Codice attuale:**
```jsx
     61: 
     62:   useEffect(() =&gt; {
 >>> 63:     if (window.qt &amp;&amp; window.qt.webChannelTransport) {
     64:       new window.QWebChannel(window.qt.webChannelTransport, function(channel) {
     65:         if (channel.objects.bridge) {
```

**‚ùì Perch√© √® un problema:**

Optional chaining allows to safely access nested properties or methods of an object without having to check for the existence of each intermediate
property manually. It provides a concise and safe way to access nested properties or methods without having to write complex and error-prone
`null`/`undefined` checks.

This rule flags logical operations that can be safely replaced with the `?.` optional chaining operator.

**‚úÖ Come risolvere:**

Replace with `?.` optional chaining the logical expression that checks for `null`/`undefined` before accessing the
property of an object, the element of an array, or calling a function.

##### Noncompliant code example

```
function foo(obj, arr, fn) {
 if (obj &amp;&amp; obj.value) {}
 if (arr &amp;&amp; arr[0]) {}
 if (fn &amp;&amp; fn(42)) {}
}
```

##### Compliant solution

```
function foo(obj, arr, fn) {
 if (obj?.value) {}
 if (arr?.[0]) {}
 if (fn?.(42)) {}
}
```

**üìö Risorse:**

#### Documentation

 - [typescript-eslint](https://typescript-eslint.io/) - Rule [prefer-optional-chain](https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/prefer-optional-chain.mdx) 

 - MDN web docs - [Optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)

---

### Riga 63 üü° üü¢ MINOR

**üéØ Problema:** Prefer `globalThis` over `window`.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S7764` - Use "globalThis" instead of "window", "self", or "global" |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 21-27 |
| Tags | es2020, portability |

**üíª Codice attuale:**
```jsx
     61: 
     62:   useEffect(() =&gt; {
 >>> 63:     if (window.qt &amp;&amp; window.qt.webChannelTransport) {
     64:       new window.QWebChannel(window.qt.webChannelTransport, function(channel) {
     65:         if (channel.objects.bridge) {
```

**‚ùì Perch√© √® un problema:**

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
properties.

#### What is the potential impact?

Using environment-specific global references reduces code portability and can cause runtime errors when code is moved between different...

**üìù Descrizione:**

This rule raises an issue when code uses `window`, `self`, or `global` to access the global object, except for
environment-specific APIs and events.

### Why is this an issue?

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
propert...

---

### Riga 64 üü° üü¢ MINOR

**üéØ Problema:** Prefer `globalThis` over `window`.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S7764` - Use "globalThis" instead of "window", "self", or "global" |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 10-16 |
| Tags | es2020, portability |

**üíª Codice attuale:**
```jsx
     62:   useEffect(() =&gt; {
     63:     if (window.qt &amp;&amp; window.qt.webChannelTransport) {
 >>> 64:       new window.QWebChannel(window.qt.webChannelTransport, function(channel) {
     65:         if (channel.objects.bridge) {
     66:             setBridge(channel.objects.bridge);
```

**‚ùì Perch√© √® un problema:**

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
properties.

#### What is the potential impact?

Using environment-specific global references reduces code portability and can cause runtime errors when code is moved between different...

**üìù Descrizione:**

This rule raises an issue when code uses `window`, `self`, or `global` to access the global object, except for
environment-specific APIs and events.

### Why is this an issue?

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
propert...

---

### Riga 64 üü° üü¢ MINOR

**üéØ Problema:** Prefer `globalThis` over `window`.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S7764` - Use "globalThis" instead of "window", "self", or "global" |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 29-35 |
| Tags | es2020, portability |

**üíª Codice attuale:**
```jsx
     62:   useEffect(() =&gt; {
     63:     if (window.qt &amp;&amp; window.qt.webChannelTransport) {
 >>> 64:       new window.QWebChannel(window.qt.webChannelTransport, function(channel) {
     65:         if (channel.objects.bridge) {
     66:             setBridge(channel.objects.bridge);
```

**‚ùì Perch√© √® un problema:**

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
properties.

#### What is the potential impact?

Using environment-specific global references reduces code portability and can cause runtime errors when code is moved between different...

**üìù Descrizione:**

This rule raises an issue when code uses `window`, `self`, or `global` to access the global object, except for
environment-specific APIs and events.

### Why is this an issue?

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
propert...

---

## üìÑ `guide_frontend/src/components/ui/GuideCard.jsx`
**10 issue(s)** | Effort: 50min

‚ö†Ô∏è **üî¥ 5 RELIABILITY**

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-29 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'className' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 31-40 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'title' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 42-47 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'icon' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 49-59 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'delay' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 61-70 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-29 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'className' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 31-40 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'title' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 42-47 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'icon' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 49-59 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'delay' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 61-70 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const GuideCard = ({ children, className, title, icon: Icon, delay = 0 }) =&gt; {
     6:   return (
     7:     &lt;motion.div
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

## üìÑ `guide_frontend/src/pages/ShortcutsGuide.jsx`
**7 issue(s)** | Effort: 35min

‚ö†Ô∏è **üî¥ 3 RELIABILITY**

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'keys' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-27 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import { Keyboard, Command } from 'lucide-react';
     4: 
 >>> 5: const ShortcutRow = ({ keys, desc }) =&gt; (
     6:   &lt;div className="flex items-center justify-between py-3 border-b border-gray-100 last:border-0 hover:bg-gray-50 px-2 rounded-lg transition-colors"&gt;
     7:       &lt;span className="text-gray-700 font-medium text-sm"&gt;{desc}&lt;/span&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'desc' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 29-33 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import { Keyboard, Command } from 'lucide-react';
     4: 
 >>> 5: const ShortcutRow = ({ keys, desc }) =&gt; (
     6:   &lt;div className="flex items-center justify-between py-3 border-b border-gray-100 last:border-0 hover:bg-gray-50 px-2 rounded-lg transition-colors"&gt;
     7:       &lt;span className="text-gray-700 font-medium text-sm"&gt;{desc}&lt;/span&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 9 üî¥ üü° MAJOR

**üéØ Problema:** 'keys.map' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 16-19 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     7:       &lt;span className="text-gray-700 font-medium text-sm"&gt;{desc}&lt;/span&gt;
     8:       &lt;div className="flex gap-1"&gt;
 >>> 9:           {keys.map((k, i) =&gt; (
     10:               &lt;span key={i} className="kbd"&gt;{k}&lt;/span&gt;
     11:           ))}
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'keys' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-27 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import { Keyboard, Command } from 'lucide-react';
     4: 
 >>> 5: const ShortcutRow = ({ keys, desc }) =&gt; (
     6:   &lt;div className="flex items-center justify-between py-3 border-b border-gray-100 last:border-0 hover:bg-gray-50 px-2 rounded-lg transition-colors"&gt;
     7:       &lt;span className="text-gray-700 font-medium text-sm"&gt;{desc}&lt;/span&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'desc' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 29-33 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import { Keyboard, Command } from 'lucide-react';
     4: 
 >>> 5: const ShortcutRow = ({ keys, desc }) =&gt; (
     6:   &lt;div className="flex items-center justify-between py-3 border-b border-gray-100 last:border-0 hover:bg-gray-50 px-2 rounded-lg transition-colors"&gt;
     7:       &lt;span className="text-gray-700 font-medium text-sm"&gt;{desc}&lt;/span&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 9 üü° üü° MAJOR

**üéØ Problema:** 'keys.map' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 16-19 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     7:       &lt;span className="text-gray-700 font-medium text-sm"&gt;{desc}&lt;/span&gt;
     8:       &lt;div className="flex gap-1"&gt;
 >>> 9:           {keys.map((k, i) =&gt; (
     10:               &lt;span key={i} className="kbd"&gt;{k}&lt;/span&gt;
     11:           ))}
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 10 üü° üü° MAJOR

**üéØ Problema:** Do not use Array index in keys

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6479` - JSX list components should not use array indexes as key |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 25-26 |
| Tags | jsx, performance, react |

**üíª Codice attuale:**
```jsx
     8:       &lt;div className="flex gap-1"&gt;
     9:           {keys.map((k, i) =&gt; (
 >>> 10:               &lt;span key={i} className="kbd"&gt;{k}&lt;/span&gt;
     11:           ))}
     12:       &lt;/div&gt;
```

**‚ùì Perch√© √® un problema:**

To optimize the rendering of React list components, a unique identifier (UID) is required for each list item. This UID lets React identify the item
throughout its lifetime. Avoid array indexes since the order of the items may change, which will cause keys to not match up between renders,
recreating the DOM. It can negatively impact performance and may cause issues with the component state.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((post, index) =&gt;
 &lt;li key={index}&gt; &lt;!-- Noncompliant: When 'posts' are reordered, React will need to recreate the list DOM --&gt;
 {post.title}
 &lt;/li&gt;
 )}
 &lt;/ul&gt;
 );
}
```

To fix it, use a string or a number that uniquely identifies the list item. The key must be unique among its siblings, not globally.

If the data comes from a database, database IDs are already unique and are the best option. Otherwise, use a counter or a UUID generator.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((p...

**üìù Descrizione:**

### Why is this an issue?

To optimize the rendering of React list components, a unique identifier (UID) is required for each list item. This UID lets React identify the item
throughout its lifetime. Avoid array indexes since the order of the items may change, which will cause keys to not match up between renders,
recreating the DOM. It can negatively impact performance and may cause issues with the component state.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((post, index) =&gt;
 &lt;li key={index}&gt; &lt;!-- Noncompliant: When 'posts' are reordered, React will need to recreate the list DOM --&gt;
 {post.title}
 &lt;/li&gt;
 )}
 &lt;/ul&gt;
 );
}
```

To fix it, use a string or a number that uniquely identifies the list item. The key must be unique among its siblings, not globally.

If the data comes from a database, database IDs are already unique and are the best option. Otherwise, use a counter or a UUID generator.

```
function Blog(props) {
 return (
 &lt;...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [no-array-index-key](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/no-array-index-key.md) 

 - React Documentation - [Rendering lists](https://react.dev/learn/rendering-lists#rules-of-keys) 

 - React Documentation - [Recursing On Children](https://reactjs.org/docs/reconciliation.html#recursing-on-children) 

 - MDN web docs - [Crypto: randomUUID() method](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID) 

 - Wikipedia - [UUID](https://en.wikipedia....

---

## üìÑ `guide_frontend/src/components/ui/Badge.jsx`
**6 issue(s)** | Effort: 30min

‚ö†Ô∏è **üî¥ 3 RELIABILITY**

### Riga 4 üî¥ üü° MAJOR

**üéØ Problema:** 'className' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 48-57 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     2: import clsx from 'clsx';
     3: 
 >>> 4: const Badge = ({ children, variant = 'default', className }) =&gt; {
     5:   const styles = {
     6:     default: 'bg-gray-100 text-gray-800 border-gray-200',
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 4 üî¥ üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 17-25 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     2: import clsx from 'clsx';
     3: 
 >>> 4: const Badge = ({ children, variant = 'default', className }) =&gt; {
     5:   const styles = {
     6:     default: 'bg-gray-100 text-gray-800 border-gray-200',
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 4 üî¥ üü° MAJOR

**üéØ Problema:** 'variant' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 27-46 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     2: import clsx from 'clsx';
     3: 
 >>> 4: const Badge = ({ children, variant = 'default', className }) =&gt; {
     5:   const styles = {
     6:     default: 'bg-gray-100 text-gray-800 border-gray-200',
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 4 üü° üü° MAJOR

**üéØ Problema:** 'className' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 48-57 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     2: import clsx from 'clsx';
     3: 
 >>> 4: const Badge = ({ children, variant = 'default', className }) =&gt; {
     5:   const styles = {
     6:     default: 'bg-gray-100 text-gray-800 border-gray-200',
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 4 üü° üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 17-25 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     2: import clsx from 'clsx';
     3: 
 >>> 4: const Badge = ({ children, variant = 'default', className }) =&gt; {
     5:   const styles = {
     6:     default: 'bg-gray-100 text-gray-800 border-gray-200',
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 4 üü° üü° MAJOR

**üéØ Problema:** 'variant' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 27-46 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     2: import clsx from 'clsx';
     3: 
 >>> 4: const Badge = ({ children, variant = 'default', className }) =&gt; {
     5:   const styles = {
     6:     default: 'bg-gray-100 text-gray-800 border-gray-200',
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

## üìÑ `guide_frontend/src/components/ui/Note.jsx`
**6 issue(s)** | Effort: 30min

‚ö†Ô∏è **üî¥ 3 RELIABILITY**

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 31-39 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const Note = ({ type = 'info', children, title }) =&gt; {
     6:   const styles = {
     7:     info: {
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'type' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 16-29 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const Note = ({ type = 'info', children, title }) =&gt; {
     6:   const styles = {
     7:     info: {
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üî¥ üü° MAJOR

**üéØ Problema:** 'title' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 41-46 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const Note = ({ type = 'info', children, title }) =&gt; {
     6:   const styles = {
     7:     info: {
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 31-39 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const Note = ({ type = 'info', children, title }) =&gt; {
     6:   const styles = {
     7:     info: {
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'type' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 16-29 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const Note = ({ type = 'info', children, title }) =&gt; {
     6:   const styles = {
     7:     info: {
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 5 üü° üü° MAJOR

**üéØ Problema:** 'title' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 41-46 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     3: import clsx from 'clsx';
     4: 
 >>> 5: const Note = ({ type = 'info', children, title }) =&gt; {
     6:   const styles = {
     7:     info: {
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

## üìÑ `guide_frontend/src/components/ui/Step.jsx`
**6 issue(s)** | Effort: 30min

‚ö†Ô∏è **üî¥ 3 RELIABILITY**

### Riga 3 üî¥ üü° MAJOR

**üéØ Problema:** 'number' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
     2: 
 >>> 3: const Step = ({ number, title, children }) =&gt; {
     4:   return (
     5:     &lt;div className="flex gap-4 mb-8 last:mb-0 relative"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 3 üî¥ üü° MAJOR

**üéØ Problema:** 'title' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 24-29 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
     2: 
 >>> 3: const Step = ({ number, title, children }) =&gt; {
     4:   return (
     5:     &lt;div className="flex gap-4 mb-8 last:mb-0 relative"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 3 üî¥ üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 31-39 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
     2: 
 >>> 3: const Step = ({ number, title, children }) =&gt; {
     4:   return (
     5:     &lt;div className="flex gap-4 mb-8 last:mb-0 relative"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 3 üü° üü° MAJOR

**üéØ Problema:** 'number' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
     2: 
 >>> 3: const Step = ({ number, title, children }) =&gt; {
     4:   return (
     5:     &lt;div className="flex gap-4 mb-8 last:mb-0 relative"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 3 üü° üü° MAJOR

**üéØ Problema:** 'title' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 24-29 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
     2: 
 >>> 3: const Step = ({ number, title, children }) =&gt; {
     4:   return (
     5:     &lt;div className="flex gap-4 mb-8 last:mb-0 relative"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

### Riga 3 üü° üü° MAJOR

**üéØ Problema:** 'children' is missing in props validation

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6774` - React components should validate prop types |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 31-39 |
| Tags | react |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
     2: 
 >>> 3: const Step = ({ number, title, children }) =&gt; {
     4:   return (
     5:     &lt;div className="flex gap-4 mb-8 last:mb-0 relative"&gt;
```

**‚ùì Perch√© √® un problema:**

In JavaScript, props are typically passed as plain objects, which can lead to errors and confusion when working with components that have specific
prop requirements. However, it lacks of type safety and clarity when passing props to components in a codebase.

By defining types for component props, developers can enforce type safety and provide clear documentation for the expected props of a component.
This helps catch potential errors at compile-time. It also improves code maintainability by making it easier to understand how components should be
used and what props they accept.

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;; // Noncompliant: 'lastname' type is missing
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
};
```

##### Compliant solution

```
import PropTypes from 'prop-types';

function Hello({ firstname, lastname }) {
 return &lt;div&gt;Hello {firstname} {lastname}&lt;/div&gt;;
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};

// Using legacy APIs

class Hello extends React.Component {
 render() {
 return &lt;div&gt;Hello {this.props.firstname} {this.props.lastname}&lt;/div&gt;;
 }
}
Hello.propTypes = {
 firstname: PropTypes.string.isRequired,
 lastname: PropTypes.string.isRequired,
};
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [prop-types](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/prop-types.md) 

 - React Documentation - [static propTypes](https://react.dev/reference/react/Component#static-proptypes) 

 - Flow.js Documentation - [React](https://flow.org/en/docs/react/)

---

## üìÑ `guide_frontend/src/components/ImportSimulator.jsx`
**8 issue(s)** | Effort: 32min

‚ö†Ô∏è **üî¥ 2 RELIABILITY**

### Riga 82 üî¥ üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 14-15 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     80:               className="text-center w-full max-w-md"
     81:             &gt;
 >>> 82:               &lt;div
 >>> 83:                 onClick={simulateProcess}
 >>> 84:                 className="border-2 border-dashed border-blue-300 rounded-xl p-10 bg-blue-50/50 hover:bg-blue-50 hover:border-blue-500 transition-all cursor-pointer group"
 >>> 85:               &gt;
     86:                 &lt;UploadCloud size={48} className="mx-auto text-blue-400 group-hover:text-blue-600 mb-4 transition-colors" /&gt;
     87:                 &lt;h3 className="text-lg font-bold text-gray-700 mb-2"&gt;Trascina qui i tuoi file PDF&lt;/h3&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 82 üî¥ üü¢ MINOR

**üéØ Problema:** Visible, non-interactive elements with click handlers must have at least one keyboard listener.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1082` - Mouse events should have corresponding keyboard events |
| Categoria | RELIABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 14-15 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     80:               className="text-center w-full max-w-md"
     81:             &gt;
 >>> 82:               &lt;div
 >>> 83:                 onClick={simulateProcess}
 >>> 84:                 className="border-2 border-dashed border-blue-300 rounded-xl p-10 bg-blue-50/50 hover:bg-blue-50 hover:border-blue-500 transition-all cursor-pointer group"
 >>> 85:               &gt;
     86:                 &lt;UploadCloud size={48} className="mx-auto text-blue-400 group-hover:text-blue-600 mb-4 transition-colors" /&gt;
     87:                 &lt;h3 className="text-lg font-bold text-gray-700 mb-2"&gt;Trascina qui i tuoi file PDF&lt;/h3&gt;
```

**‚ùì Perch√© √® un problema:**

Offering the same experience with the mouse and the keyboard allow users to pick their preferred devices.

Additionally, users of assistive technology will also be able to browse the site even if they cannot use the mouse.

This rules detects the following issues:

 - when `onClick` is not accompanied by at least one of the following: `onKeyUp`, `onKeyDown`,
 `onKeyPress`. 

 - when `onmouseover`/`onmouseout` are not paired by `onfocus`/`onblur`.

**‚úÖ Come risolvere:**

Add at least one of the following event handlers `onKeyUp`, `onKeyDown`, `onKeyPress` to the element when using
`onClick` event handler. Add corresponding event handlers `onfocus`/`onblur` to the element when using
`onmouseover`/`onmouseout` event handlers.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;

&lt;div onMouseOver={ () =&gt; {}} } /&gt;
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} onKeyDown={this.handleKeyDown} /&gt;

&lt;div onMouseOver={ () =&gt; {} } onFocus={ () =&gt; {} } /&gt;
```

### Exceptions

This does not apply for interactive or hidden elements, eg. when using `aria-hidden="true"` attribute.

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [mouse-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/mouse-events-have-key-events.md)
 

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [click-events-have-key-events](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/click-events-have-key-events.md)
 

 - SCR2 - [Using redundant keyboard and mouse event handlers](https://www.w3.org/TR/WCAG20-TECHS/SCR2.html) 

 - G90 - [...

---

### Riga 1 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'useEffect'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 26-35 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
 >>> 1: import React, { useState, useEffect } from 'react';
     2: import { motion, AnimatePresence } from 'framer-motion';
     3: import { UploadCloud, FileText, CheckCircle, AlertTriangle, FolderOpen, RefreshCcw } from 'lucide-react';
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Badge'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 7-12 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     2: import { motion, AnimatePresence } from 'framer-motion';
     3: import { UploadCloud, FileText, CheckCircle, AlertTriangle, FolderOpen, RefreshCcw } from 'lucide-react';
 >>> 4: import Badge from './ui/Badge';
     5: 
     6: const ImportSimulator = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 82 üü° üü° MAJOR

**üéØ Problema:** Avoid non-native interactive elements. If using native HTML is not possible, add an appropriate role and support for tabbing, mouse, keyboard, and touch inputs to an interactive content element.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6848` - Non-interactive DOM elements should not have an interactive handler |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 14-15 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     80:               className="text-center w-full max-w-md"
     81:             &gt;
 >>> 82:               &lt;div
 >>> 83:                 onClick={simulateProcess}
 >>> 84:                 className="border-2 border-dashed border-blue-300 rounded-xl p-10 bg-blue-50/50 hover:bg-blue-50 hover:border-blue-500 transition-all cursor-pointer group"
 >>> 85:               &gt;
     86:                 &lt;UploadCloud size={48} className="mx-auto text-blue-400 group-hover:text-blue-600 mb-4 transition-colors" /&gt;
     87:                 &lt;h3 className="text-lg font-bold text-gray-700 mb-2"&gt;Trascina qui i tuoi file PDF&lt;/h3&gt;
```

**‚ùì Perch√© √® un problema:**

Non-interactive DOM elements are HTML elements that are not designed to be interacted with by the user, for instance `<div>`,
`<span>`, and `<footer>`, etc. They are typically used to structure content and do not have built-in interactivity
or keyboard accessibility.

Interactive handlers, on the other hand, are event handlers that respond to user interactions. These include handlers like `onClick`,
`onKeyDown`, `onMouseUp`, and more. When these handlers are added to an HTML element, they make the element respond to the
specified user interaction.

When non-interactive elements have interactive handlers, it can lead to several problems:

 - Unexpected behavior: Non-interactive elements are not designed to be interactive, so adding interactive handlers can cause unexpected behavior.
 For example, non-interactive elements do not naturally receive keyboard focus, so keyboard users might not be able to activate the handler. 

 - Confusing for assistive technologies: Assistive technologies ...

**‚úÖ Come risolvere:**

The simplest and most recommended way is to replace the non-interactive elements with interactive ones. If for some reason you can‚Äôt replace the
non-interactive element, you can add an interactive `role` attribute to it and manually manage its keyboard event handlers and focus.
Common interactive roles include `button`, `link`, `checkbox`, `menuitem`, `menuitemcheckbox`,
`menuitemradio`, `option`, `radio`, `searchbox`, `switch`, and `textbox`.

##### Noncompliant code example

```
&lt;div onClick={() =&gt; {}} /&gt;; // Noncompliant
```

##### Compliant solution

```
&lt;div onClick={() =&gt; {}} role="button" /&gt;;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [no-static-element-interactions](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/no-static-element-interactions.md) 

 - WCAG - [Name, Role, Value](https://www.w3.org/WAI/WCAG21/Understanding/name-role-value) 

 - MDN web docs - [WAI-ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

---

### Riga 130 üü° üü° MAJOR

**üéØ Problema:** Extract this nested ternary operation into an independent statement.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S3358` - Ternary operators should not be nested |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 22-37 |
| Tags | confusing |

**üíª Codice attuale:**
```jsx
     128:                     className={`mb-1.5 flex items-center gap-2 ${
     129:                       log.type === 'error' ? 'text-red-400' :
 >>> 130:                       log.type === 'warning' ? 'text-orange-300' :
 >>> 131:                       log.type === 'success' ? 'text-green-400' :
 >>> 132:                       log.type === 'done' ? 'text-blue-300 font-bold' :
 >>> 133:                       'text-gray-300'
     134:                     }`}
     135:                   &gt;
```

**‚ùì Perch√© √® un problema:**

Nested ternaries are hard to read and can make the order of operations complex to understand.

```
function getReadableStatus(job) {
 return job.isRunning() ? "Running" : job.hasErrors() ? "Failed" : "Succeeded "; // Noncompliant
}
```

Instead, use another line to express the nested operation in a separate statement.

```
function getReadableStatus(job) {
 if (job.isRunning()) {
 return "Running";
 }
 return job.hasErrors() ? "Failed" : "Succeeded";
}
```

#### Exceptions

This rule does not apply in JSX expressions to support conditional rendering and conditional attributes as long as the nesting happens in separate
JSX expression containers, i.e. JSX elements embedding JavaScript code, as shown below:

```
return (
&lt;&gt;
 {isLoading ? (
 &lt;Loader active /&gt;
 ) : (
 &lt;Panel label={isEditing ? 'Open' : 'Not open'}&gt;
 &lt;a&gt;{isEditing ? 'Close now' : 'Start now'}&lt;/a&gt;
 &lt;Checkbox onClick={!saving ? setSaving(saving =&gt; !saving) : null} /&gt;
 &lt;/Panel&gt;
 )}
&...

**üìù Descrizione:**

### Why is this an issue?

Nested ternaries are hard to read and can make the order of operations complex to understand.

```
function getReadableStatus(job) {
 return job.isRunning() ? "Running" : job.hasErrors() ? "Failed" : "Succeeded "; // Noncompliant
}
```

Instead, use another line to express the nested operation in a separate statement.

```
function getReadableStatus(job) {
 if (job.isRunning()) {
 return "Running";
 }
 return job.hasErrors() ? "Failed" : "Succeeded";
}
```

#### Exceptions

This rule does not apply in JSX expressions to support conditional rendering and conditional attributes as long as the nesting happens in separate
JSX expression containers, i.e. JSX elements embedding JavaScript code, as shown below:

```
return (
&lt;&gt;
 {isLoading ? (
 &lt;Loader active /&gt;
 ) : (
 &lt;Panel label={isEditing ? 'Open' : 'Not open'}&gt;
 &lt;a&gt;{isEditing ? 'Close now' : 'Start now'}&lt;/a&gt;
 &lt;Checkbox onClick={!saving ? setSaving(saving =&gt; !saving) : null} ...

**üìö Risorse:**

#### Articles & blog posts

 - Sonar - [Stop nesting ternaries in JavaScript](https://www.sonarsource.com/blog/stop-nesting-ternaries-javascript/)

---

### Riga 131 üü° üü° MAJOR

**üéØ Problema:** Extract this nested ternary operation into an independent statement.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S3358` - Ternary operators should not be nested |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 22-37 |
| Tags | confusing |

**üíª Codice attuale:**
```jsx
     129:                       log.type === 'error' ? 'text-red-400' :
     130:                       log.type === 'warning' ? 'text-orange-300' :
 >>> 131:                       log.type === 'success' ? 'text-green-400' :
 >>> 132:                       log.type === 'done' ? 'text-blue-300 font-bold' :
 >>> 133:                       'text-gray-300'
     134:                     }`}
     135:                   &gt;
```

**‚ùì Perch√© √® un problema:**

Nested ternaries are hard to read and can make the order of operations complex to understand.

```
function getReadableStatus(job) {
 return job.isRunning() ? "Running" : job.hasErrors() ? "Failed" : "Succeeded "; // Noncompliant
}
```

Instead, use another line to express the nested operation in a separate statement.

```
function getReadableStatus(job) {
 if (job.isRunning()) {
 return "Running";
 }
 return job.hasErrors() ? "Failed" : "Succeeded";
}
```

#### Exceptions

This rule does not apply in JSX expressions to support conditional rendering and conditional attributes as long as the nesting happens in separate
JSX expression containers, i.e. JSX elements embedding JavaScript code, as shown below:

```
return (
&lt;&gt;
 {isLoading ? (
 &lt;Loader active /&gt;
 ) : (
 &lt;Panel label={isEditing ? 'Open' : 'Not open'}&gt;
 &lt;a&gt;{isEditing ? 'Close now' : 'Start now'}&lt;/a&gt;
 &lt;Checkbox onClick={!saving ? setSaving(saving =&gt; !saving) : null} /&gt;
 &lt;/Panel&gt;
 )}
&...

**üìù Descrizione:**

### Why is this an issue?

Nested ternaries are hard to read and can make the order of operations complex to understand.

```
function getReadableStatus(job) {
 return job.isRunning() ? "Running" : job.hasErrors() ? "Failed" : "Succeeded "; // Noncompliant
}
```

Instead, use another line to express the nested operation in a separate statement.

```
function getReadableStatus(job) {
 if (job.isRunning()) {
 return "Running";
 }
 return job.hasErrors() ? "Failed" : "Succeeded";
}
```

#### Exceptions

This rule does not apply in JSX expressions to support conditional rendering and conditional attributes as long as the nesting happens in separate
JSX expression containers, i.e. JSX elements embedding JavaScript code, as shown below:

```
return (
&lt;&gt;
 {isLoading ? (
 &lt;Loader active /&gt;
 ) : (
 &lt;Panel label={isEditing ? 'Open' : 'Not open'}&gt;
 &lt;a&gt;{isEditing ? 'Close now' : 'Start now'}&lt;/a&gt;
 &lt;Checkbox onClick={!saving ? setSaving(saving =&gt; !saving) : null} ...

**üìö Risorse:**

#### Articles & blog posts

 - Sonar - [Stop nesting ternaries in JavaScript](https://www.sonarsource.com/blog/stop-nesting-ternaries-javascript/)

---

### Riga 132 üü° üü° MAJOR

**üéØ Problema:** Extract this nested ternary operation into an independent statement.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S3358` - Ternary operators should not be nested |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 22-37 |
| Tags | confusing |

**üíª Codice attuale:**
```jsx
     130:                       log.type === 'warning' ? 'text-orange-300' :
     131:                       log.type === 'success' ? 'text-green-400' :
 >>> 132:                       log.type === 'done' ? 'text-blue-300 font-bold' :
 >>> 133:                       'text-gray-300'
     134:                     }`}
     135:                   &gt;
```

**‚ùì Perch√© √® un problema:**

Nested ternaries are hard to read and can make the order of operations complex to understand.

```
function getReadableStatus(job) {
 return job.isRunning() ? "Running" : job.hasErrors() ? "Failed" : "Succeeded "; // Noncompliant
}
```

Instead, use another line to express the nested operation in a separate statement.

```
function getReadableStatus(job) {
 if (job.isRunning()) {
 return "Running";
 }
 return job.hasErrors() ? "Failed" : "Succeeded";
}
```

#### Exceptions

This rule does not apply in JSX expressions to support conditional rendering and conditional attributes as long as the nesting happens in separate
JSX expression containers, i.e. JSX elements embedding JavaScript code, as shown below:

```
return (
&lt;&gt;
 {isLoading ? (
 &lt;Loader active /&gt;
 ) : (
 &lt;Panel label={isEditing ? 'Open' : 'Not open'}&gt;
 &lt;a&gt;{isEditing ? 'Close now' : 'Start now'}&lt;/a&gt;
 &lt;Checkbox onClick={!saving ? setSaving(saving =&gt; !saving) : null} /&gt;
 &lt;/Panel&gt;
 )}
&...

**üìù Descrizione:**

### Why is this an issue?

Nested ternaries are hard to read and can make the order of operations complex to understand.

```
function getReadableStatus(job) {
 return job.isRunning() ? "Running" : job.hasErrors() ? "Failed" : "Succeeded "; // Noncompliant
}
```

Instead, use another line to express the nested operation in a separate statement.

```
function getReadableStatus(job) {
 if (job.isRunning()) {
 return "Running";
 }
 return job.hasErrors() ? "Failed" : "Succeeded";
}
```

#### Exceptions

This rule does not apply in JSX expressions to support conditional rendering and conditional attributes as long as the nesting happens in separate
JSX expression containers, i.e. JSX elements embedding JavaScript code, as shown below:

```
return (
&lt;&gt;
 {isLoading ? (
 &lt;Loader active /&gt;
 ) : (
 &lt;Panel label={isEditing ? 'Open' : 'Not open'}&gt;
 &lt;a&gt;{isEditing ? 'Close now' : 'Start now'}&lt;/a&gt;
 &lt;Checkbox onClick={!saving ? setSaving(saving =&gt; !saving) : null} ...

**üìö Risorse:**

#### Articles & blog posts

 - Sonar - [Stop nesting ternaries in JavaScript](https://www.sonarsource.com/blog/stop-nesting-ternaries-javascript/)

---

## üìÑ `tests/desktop_app/views/test_scadenzario_logic.py`
**2 issue(s)** | Effort: 10min

‚ö†Ô∏è **üî¥ 1 RELIABILITY**

### Riga 42 üî¥ üü° MAJOR

**üéØ Problema:** Do not perform equality checks with floating point values.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1244` - Floating point numbers should not be tested for equality |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 11-46 |
| Tags | data-science, numpy, pytorch, suspicious |

**üíª Codice attuale:**
```python
     40:     assert scadenzario_view is not None
     41:     assert scadenzario_view.gantt_scene is not None
 >>> 42:     assert scadenzario_view.zoom_months == 3.0
     43: 
     44: def test_load_data_trigger(scadenzario_view):
```

**‚ùì Perch√© √® un problema:**

Floating point math is imprecise because of the challenges of storing such values in a binary representation.

In base 10, the fraction `1/3` is represented as `0.333‚Ä¶‚Äã` which, for a given number of significant digit, will never exactly
be `1/3`. The same problem happens when trying to represent `1/10` in base 2, with leads to the infinitely repeating fraction
`0.0001100110011‚Ä¶‚Äã`. This makes floating point representations inherently imprecise.

Even worse, floating point math is not associative; push a `float` through a series of simple mathematical operations and the answer
will be different based on the order of those operation because of the rounding that takes place at each step.

Even simple floating point assignments are not simple, as can be vizualized using the `format` function to check for significant
digits:

```
&gt;&gt;&gt; format(0.1, ".17g")
'0.10000000000000001'
```

This can also be vizualized as a fraction using the `as_integer_ratio` method:

```
&gt;&gt;&gt; my_floa...

**‚úÖ Come risolvere:**

Whenever attempting to compare float values, it is important to consider the inherent imprecision of floating-point arithmetic.

One common solution to this problem is to use a tolerance value (also called epsilon) to define an acceptable range of difference between two
floats. A tolerance value may be relative (based on the magnitude of the numbers being compared) or absolute. Note that comparing a value to 0 is a
special case: as it has no magnitude, it is important to use an absolute tolerance value.

The `math.isclose` function allows to compare floats with a relative and absolute tolerance. One should however be careful when
comparing values to 0, as by default, the absolute tolerance of `math.isclose` is `0.0` (this case is covered by rule
S6727) . Depending on the library you‚Äôre using, equivalent functions exist, with possibly different default tolerances (e.g
`numpy.isclose` or `torch.isclose` which are respectively designed to work with `numpy` arrays and
`pytorch` tensors).

If precise decimal arithmetic is needed, another option is to use the `Decimal` class of the `decimal` module, which allows
for exact decimal arithmetic.

##### Noncompliant code example

```
def foo(a, b):
 return a == b - 0.1
```

##### Compliant solution

```
import math
def foo(a, b):
 return math.isclose(a, b - 0.1, rel_tol=1e-09, abs_tol=1e-09)
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - Floating Point Arithmetic: Issues and
 Limitations 

 - Python Documentation - Decimal fixed point and floating point
 arithmetic 

 - NumPy Documentation - [numpy.isclose](https://numpy.org/doc/stable/reference/generated/numpy.isclose.html) 

 - PyTorch Documentation - [torch.isclose](https://pytorch.org/docs/stable/generated/torch.isclose.html) 

#### Related rules

 - S6727 - The `abs_tol` parameter should be provided when using `math.isclose` to compare values to
 `0`

---

### Riga 88 üü° üü¢ MINOR

**üéØ Problema:** Replace set constructor call with a set comprehension.

| Campo | Valore |
|-------|--------|
| Regola | `python:S7494` - Comprehensions should be used instead of constructors around generator expressions |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 25-28 |

**üíª Codice attuale:**
```python
     86:     
     87:     # Verify categories are assigned colors
 >>> 88:     categories_in_data = set(item['categoria'] for item in scadenzario_view.certificates)
     89:     assert len(categories_in_data) &gt;= 1, "At least one category should be present"
     90: 
```

**‚ùì Perch√© √® un problema:**

Using `list()`, `set()`, or `dict()` around a generator expression is redundant when a corresponding comprehension
can directly express the same operation. Comprehensions are clearer, more concise, and often more readable than the equivalent constructor/generator
expression combination.

This principle applies to all three built-in collection types: `list`, `set`, and `dict`:

 - Use `[f(x) for x in foo]` instead of `list(f(x) for x in foo)` 

 - Use `{f(x) for x in foo}` instead of `set(f(x) for x in foo)` 

 - Use `{k: v for k, v in items}` instead of `dict((k, v) for k, v in items)` 

#### Exceptions

If the generator expression doesn‚Äôt filter or modify the collection, the rule does not raise. For example, `list(x for x in foo)` is
simply copying the iterable `foo` into a list, which is equivalent to `list(foo)` and covered by a different rule.

**‚úÖ Come risolvere:**

Replace the collection constructor with the appropriate comprehension syntax.

##### Noncompliant code example

```
def f(x):
 return x * 2

list(f(x) for x in range(5)) # Noncompliant
```

##### Compliant solution

```
def f(x):
 return x * 2

[f(x) for x in range(5)] # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [List Comprehensions](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) 

 - Python Documentation - [Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) 

 - Python Documentation - [Sets](https://docs.python.org/3/tutorial/datastructures.html#sets)

---

## üìÑ `guide_frontend/src/pages/SettingsGuide.jsx`
**2 issue(s)** | Effort: 6min

‚ö†Ô∏è **üî¥ 1 RELIABILITY**

### Riga 26 üî¥ üü° MAJOR

**üéØ Problema:** A form label must be associated with a control.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6853` - Label elements should have a text label and an associated control |
| Categoria | RELIABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 22-27 |
| Tags | accessibility, react |

**üíª Codice attuale:**
```jsx
     24:              &lt;div className="flex gap-4 mb-6"&gt;
     25:                  &lt;div className="flex-1"&gt;
 >>> 26:                      &lt;label className="block text-sm font-medium text-gray-700 mb-1"&gt;Preset Rapidi&lt;/label&gt;
     27:                      &lt;select className="w-full border-gray-300 rounded-md shadow-sm bg-gray-50 p-2 text-sm" disabled&gt;
     28:                          &lt;option&gt;Gmail (OAuth/App Password)&lt;/option&gt;
```

**‚ùì Perch√© √® un problema:**

When a label element lacks a text label or an associated control, it can lead to several issues:

 - **Poor Accessibility**: Screen readers rely on correctly associated labels to describe the function of the form control. If the
 label is not properly associated with a control, it can make the form difficult or impossible for visually impaired users to understand or interact
 with. 

 - **Confusing User Interface**: Labels provide users with clear instructions about what information is required in a form control.
 Without a properly associated label, users might not understand what input is expected, leading to confusion and potential misuse of the form. 

 - **Code Maintainability**: Properly structured and labeled code is easier to read, understand, and maintain. When labels are not
 correctly associated, it can make the code more difficult to navigate and debug, especially for new developers or those unfamiliar with the
 codebase. 

Control elements are: * `<input>` * `<meter>` * `<...

**‚úÖ Come risolvere:**

If you have a pair of control and `<label>` elements, make sure that the `<label>` wraps the control element. If
you lack a control element, add one.

It is strongly recommended to avoid using generated `id`s since they must be deterministic.

##### Noncompliant code example

```
&lt;input type="text" /&gt;
&lt;label&gt;Favorite food&lt;/label&gt;
```

##### Compliant solution

```
&lt;label&gt;
 &lt;input type="text" /&gt;
 Favorite food
&lt;/label&gt;
```

##### Noncompliant code example

```
&lt;label&gt;Favorite food&lt;/label&gt;
```

##### Compliant solution

```
&lt;label&gt;
 &lt;MyCustomInput /&gt;
 Favorite food
&lt;/label&gt;
```

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) - Rule [label-has-associated-control](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/label-has-associated-control.md)
 

 - MDN web docs - [The Label element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label) 

 - W3C - [Info and Relationships](https://www.w3.org/WAI/WCAG21/Understanding/info-and-relationships) 

 - W3C - [Labels or Instructions](https://www.w3.org/WAI/WCAG21/Understanding/labels-or-instructions) # end::resources[]

---

### Riga 5 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Sliders'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 9-16 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     3: import Note from '../components/ui/Note';
     4: import Step from '../components/ui/Step';
 >>> 5: import { Sliders, Mail, Bell, Monitor } from 'lucide-react';
     6: 
     7: const SettingsGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

## üìÑ `tests/desktop_app/mock_qt.py`
**259 issue(s)** | Effort: 2g 1h 10min

### Riga 35 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     33: 
     34: class DummyQObject:
 >>> 35:     def __init__(self, parent=None):
     36:         pass
     37:     def moveToThread(self, thread):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 37 üü° üü¢ MINOR

**üéØ Problema:** Rename method "moveToThread" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | convention |

**üíª Codice attuale:**
```python
     35:     def __init__(self, parent=None):
     36:         pass
 >>> 37:     def moveToThread(self, thread):
     38:         pass
     39:     def deleteLater(self):
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 37 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     35:     def __init__(self, parent=None):
     36:         pass
 >>> 37:     def moveToThread(self, thread):
     38:         pass
     39:     def deleteLater(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 39 üü° üü¢ MINOR

**üéØ Problema:** Rename method "deleteLater" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | convention |

**üíª Codice attuale:**
```python
     37:     def moveToThread(self, thread):
     38:         pass
 >>> 39:     def deleteLater(self):
     40:         pass
     41:     def parent(self):
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 39 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     37:     def moveToThread(self, thread):
     38:         pass
 >>> 39:     def deleteLater(self):
     40:         pass
     41:     def parent(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 45 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "StyledPanel" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     43: 
     44: class DummyEnum:
 >>> 45:     StyledPanel = 1
     46:     Sunken = 1
     47:     Password = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 46 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Sunken" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-10 |
| Tags | convention |

**üíª Codice attuale:**
```python
     44: class DummyEnum:
     45:     StyledPanel = 1
 >>> 46:     Sunken = 1
     47:     Password = 1
     48:     Plain = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 47 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Password" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-12 |
| Tags | convention |

**üíª Codice attuale:**
```python
     45:     StyledPanel = 1
     46:     Sunken = 1
 >>> 47:     Password = 1
     48:     Plain = 0
     49:     HLine = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 48 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Plain" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-9 |
| Tags | convention |

**üíª Codice attuale:**
```python
     46:     Sunken = 1
     47:     Password = 1
 >>> 48:     Plain = 0
     49:     HLine = 1
     50:     Ok = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 49 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "HLine" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-9 |
| Tags | convention |

**üíª Codice attuale:**
```python
     47:     Password = 1
     48:     Plain = 0
 >>> 49:     HLine = 1
     50:     Ok = 1
     51:     Cancel = 2
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 50 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Ok" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-6 |
| Tags | convention |

**üíª Codice attuale:**
```python
     48:     Plain = 0
     49:     HLine = 1
 >>> 50:     Ok = 1
     51:     Cancel = 2
     52:     Yes = 3
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 51 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Cancel" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-10 |
| Tags | convention |

**üíª Codice attuale:**
```python
     49:     HLine = 1
     50:     Ok = 1
 >>> 51:     Cancel = 2
     52:     Yes = 3
     53:     No = 4
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 52 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Yes" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-7 |
| Tags | convention |

**üíª Codice attuale:**
```python
     50:     Ok = 1
     51:     Cancel = 2
 >>> 52:     Yes = 3
     53:     No = 4
     54:     AdjustToContents = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 53 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "No" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-6 |
| Tags | convention |

**üíª Codice attuale:**
```python
     51:     Cancel = 2
     52:     Yes = 3
 >>> 53:     No = 4
     54:     AdjustToContents = 0
     55:     WindowMaximizeButtonHint = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 54 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AdjustToContents" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-20 |
| Tags | convention |

**üíª Codice attuale:**
```python
     52:     Yes = 3
     53:     No = 4
 >>> 54:     AdjustToContents = 0
     55:     WindowMaximizeButtonHint = 0
     56:     AlignCenter = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 55 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WindowMaximizeButtonHint" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-28 |
| Tags | convention |

**üíª Codice attuale:**
```python
     53:     No = 4
     54:     AdjustToContents = 0
 >>> 55:     WindowMaximizeButtonHint = 0
     56:     AlignCenter = 0
     57:     AlignLeft = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 56 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignCenter" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     54:     AdjustToContents = 0
     55:     WindowMaximizeButtonHint = 0
 >>> 56:     AlignCenter = 0
     57:     AlignLeft = 0
     58:     AlignTop = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 57 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignLeft" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-13 |
| Tags | convention |

**üíª Codice attuale:**
```python
     55:     WindowMaximizeButtonHint = 0
     56:     AlignCenter = 0
 >>> 57:     AlignLeft = 0
     58:     AlignTop = 0
     59:     AlignRight = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 58 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignTop" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-12 |
| Tags | convention |

**üíª Codice attuale:**
```python
     56:     AlignCenter = 0
     57:     AlignLeft = 0
 >>> 58:     AlignTop = 0
     59:     AlignRight = 0
     60:     AlignBottom = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 59 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignRight" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-14 |
| Tags | convention |

**üíª Codice attuale:**
```python
     57:     AlignLeft = 0
     58:     AlignTop = 0
 >>> 59:     AlignRight = 0
     60:     AlignBottom = 0
     61:     PointingHandCursor = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 60 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignBottom" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     58:     AlignTop = 0
     59:     AlignRight = 0
 >>> 60:     AlignBottom = 0
     61:     PointingHandCursor = 0
     62:     Horizontal = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 61 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "PointingHandCursor" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-22 |
| Tags | convention |

**üíª Codice attuale:**
```python
     59:     AlignRight = 0
     60:     AlignBottom = 0
 >>> 61:     PointingHandCursor = 0
     62:     Horizontal = 1
     63:     Vertical = 2
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 62 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Horizontal" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-14 |
| Tags | convention |

**üíª Codice attuale:**
```python
     60:     AlignBottom = 0
     61:     PointingHandCursor = 0
 >>> 62:     Horizontal = 1
     63:     Vertical = 2
     64:     WA_TransparentForMouseEvents = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 63 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Vertical" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-12 |
| Tags | convention |

**üíª Codice attuale:**
```python
     61:     PointingHandCursor = 0
     62:     Horizontal = 1
 >>> 63:     Vertical = 2
     64:     WA_TransparentForMouseEvents = 0
     65:     WA_ShowWithoutActivating = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 64 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WA_TransparentForMouseEvents" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-32 |
| Tags | convention |

**üíª Codice attuale:**
```python
     62:     Horizontal = 1
     63:     Vertical = 2
 >>> 64:     WA_TransparentForMouseEvents = 0
     65:     WA_ShowWithoutActivating = 0
     66:     WA_TranslucentBackground = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 65 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WA_ShowWithoutActivating" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-28 |
| Tags | convention |

**üíª Codice attuale:**
```python
     63:     Vertical = 2
     64:     WA_TransparentForMouseEvents = 0
 >>> 65:     WA_ShowWithoutActivating = 0
     66:     WA_TranslucentBackground = 0
     67:     WA_DeleteOnClose = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 66 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WA_TranslucentBackground" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-28 |
| Tags | convention |

**üíª Codice attuale:**
```python
     64:     WA_TransparentForMouseEvents = 0
     65:     WA_ShowWithoutActivating = 0
 >>> 66:     WA_TranslucentBackground = 0
     67:     WA_DeleteOnClose = 0
     68:     AA_ShareOpenGLContexts = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 67 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WA_DeleteOnClose" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-20 |
| Tags | convention |

**üíª Codice attuale:**
```python
     65:     WA_ShowWithoutActivating = 0
     66:     WA_TranslucentBackground = 0
 >>> 67:     WA_DeleteOnClose = 0
     68:     AA_ShareOpenGLContexts = 0
     69:     DisplayRole = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 68 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AA_ShareOpenGLContexts" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-26 |
| Tags | convention |

**üíª Codice attuale:**
```python
     66:     WA_TranslucentBackground = 0
     67:     WA_DeleteOnClose = 0
 >>> 68:     AA_ShareOpenGLContexts = 0
     69:     DisplayRole = 0
     70:     EditRole = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 69 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "DisplayRole" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     67:     WA_DeleteOnClose = 0
     68:     AA_ShareOpenGLContexts = 0
 >>> 69:     DisplayRole = 0
     70:     EditRole = 1
     71:     UserRole = 256
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 70 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "EditRole" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-12 |
| Tags | convention |

**üíª Codice attuale:**
```python
     68:     AA_ShareOpenGLContexts = 0
     69:     DisplayRole = 0
 >>> 70:     EditRole = 1
     71:     UserRole = 256
     72:     WindowActive = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 71 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "UserRole" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-12 |
| Tags | convention |

**üíª Codice attuale:**
```python
     69:     DisplayRole = 0
     70:     EditRole = 1
 >>> 71:     UserRole = 256
     72:     WindowActive = 1
     73:     KeepAspectRatio = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 72 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WindowActive" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     70:     EditRole = 1
     71:     UserRole = 256
 >>> 72:     WindowActive = 1
     73:     KeepAspectRatio = 1
     74:     CustomContextMenu = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 73 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "KeepAspectRatio" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-19 |
| Tags | convention |

**üíª Codice attuale:**
```python
     71:     UserRole = 256
     72:     WindowActive = 1
 >>> 73:     KeepAspectRatio = 1
     74:     CustomContextMenu = 1
     75:     SmoothTransformation = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 74 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "CustomContextMenu" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-21 |
| Tags | convention |

**üíª Codice attuale:**
```python
     72:     WindowActive = 1
     73:     KeepAspectRatio = 1
 >>> 74:     CustomContextMenu = 1
     75:     SmoothTransformation = 1
     76:     TextSelectableByMouse = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 75 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "SmoothTransformation" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-24 |
| Tags | convention |

**üíª Codice attuale:**
```python
     73:     KeepAspectRatio = 1
     74:     CustomContextMenu = 1
 >>> 75:     SmoothTransformation = 1
     76:     TextSelectableByMouse = 1
     77:     NoPen = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 76 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "TextSelectableByMouse" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-25 |
| Tags | convention |

**üíª Codice attuale:**
```python
     74:     CustomContextMenu = 1
     75:     SmoothTransformation = 1
 >>> 76:     TextSelectableByMouse = 1
     77:     NoPen = 0
     78:     FramelessWindowHint = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 77 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "NoPen" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-9 |
| Tags | convention |

**üíª Codice attuale:**
```python
     75:     SmoothTransformation = 1
     76:     TextSelectableByMouse = 1
 >>> 77:     NoPen = 0
     78:     FramelessWindowHint = 0
     79:     Tool = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 78 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "FramelessWindowHint" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-23 |
| Tags | convention |

**üíª Codice attuale:**
```python
     76:     TextSelectableByMouse = 1
     77:     NoPen = 0
 >>> 78:     FramelessWindowHint = 0
     79:     Tool = 0
     80:     WindowStaysOnTopHint = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 79 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Tool" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-8 |
| Tags | convention |

**üíª Codice attuale:**
```python
     77:     NoPen = 0
     78:     FramelessWindowHint = 0
 >>> 79:     Tool = 0
     80:     WindowStaysOnTopHint = 0
     81:     Dialog = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 80 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WindowStaysOnTopHint" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-24 |
| Tags | convention |

**üíª Codice attuale:**
```python
     78:     FramelessWindowHint = 0
     79:     Tool = 0
 >>> 80:     WindowStaysOnTopHint = 0
     81:     Dialog = 0
     82:     SubWindow = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 81 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Dialog" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-10 |
| Tags | convention |

**üíª Codice attuale:**
```python
     79:     Tool = 0
     80:     WindowStaysOnTopHint = 0
 >>> 81:     Dialog = 0
     82:     SubWindow = 0
     83:     transparent = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 82 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "SubWindow" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-13 |
| Tags | convention |

**üíª Codice attuale:**
```python
     80:     WindowStaysOnTopHint = 0
     81:     Dialog = 0
 >>> 82:     SubWindow = 0
     83:     transparent = 0
     84:     white = 3
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 85 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WindowNoState" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-17 |
| Tags | convention |

**üíª Codice attuale:**
```python
     83:     transparent = 0
     84:     white = 3
 >>> 85:     WindowNoState = 0
     86:     WindowMinimized = 1
     87:     NoFrame = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 86 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WindowMinimized" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-19 |
| Tags | convention |

**üíª Codice attuale:**
```python
     84:     white = 3
     85:     WindowNoState = 0
 >>> 86:     WindowMinimized = 1
     87:     NoFrame = 0
     88:     RichText = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 87 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "NoFrame" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-11 |
| Tags | convention |

**üíª Codice attuale:**
```python
     85:     WindowNoState = 0
     86:     WindowMinimized = 1
 >>> 87:     NoFrame = 0
     88:     RichText = 1
     89: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 88 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "RichText" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-12 |
| Tags | convention |

**üíª Codice attuale:**
```python
     86:     WindowMinimized = 1
     87:     NoFrame = 0
 >>> 88:     RichText = 1
     89: 
     90:     class Orientation:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 91 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Horizontal" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-18 |
| Tags | convention |

**üíª Codice attuale:**
```python
     89: 
     90:     class Orientation:
 >>> 91:         Horizontal = 1
     92:         Vertical = 2
     93: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 92 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Vertical" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     90:     class Orientation:
     91:         Horizontal = 1
 >>> 92:         Vertical = 2
     93: 
     94:     class ContextMenuPolicy:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 95 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "CustomContextMenu" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-25 |
| Tags | convention |

**üíª Codice attuale:**
```python
     93: 
     94:     class ContextMenuPolicy:
 >>> 95:         CustomContextMenu = 1
     96: 
     97:     class TextInteractionFlag:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 98 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "TextBrowserInteraction" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-30 |
| Tags | convention |

**üíª Codice attuale:**
```python
     96: 
     97:     class TextInteractionFlag:
 >>> 98:         TextBrowserInteraction = 1
     99: 
     100:     class WindowState:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 101 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WindowNoState" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-21 |
| Tags | convention |

**üíª Codice attuale:**
```python
     99: 
     100:     class WindowState:
 >>> 101:         WindowNoState = 0
     102:         WindowMinimized = 1
     103: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 102 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WindowMinimized" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-23 |
| Tags | convention |

**üíª Codice attuale:**
```python
     100:     class WindowState:
     101:         WindowNoState = 0
 >>> 102:         WindowMinimized = 1
     103: 
     104:     class Shape:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 105 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "NoFrame" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     103: 
     104:     class Shape:
 >>> 105:         NoFrame = 0
     106:         HLine = 1
     107: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 106 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "HLine" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-13 |
| Tags | convention |

**üíª Codice attuale:**
```python
     104:     class Shape:
     105:         NoFrame = 0
 >>> 106:         HLine = 1
     107: 
     108:     class GlobalColor:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 113 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "DisplayRole" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-19 |
| Tags | convention |

**üíª Codice attuale:**
```python
     111: 
     112:     class ItemDataRole:
 >>> 113:         DisplayRole = 0
     114:         EditRole = 1
     115:         UserRole = 256
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 114 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "EditRole" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     112:     class ItemDataRole:
     113:         DisplayRole = 0
 >>> 114:         EditRole = 1
     115:         UserRole = 256
     116: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 115 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "UserRole" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     113:         DisplayRole = 0
     114:         EditRole = 1
 >>> 115:         UserRole = 256
     116: 
     117:     class ApplicationAttribute:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 118 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AA_ShareOpenGLContexts" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-30 |
| Tags | convention |

**üíª Codice attuale:**
```python
     116: 
     117:     class ApplicationAttribute:
 >>> 118:         AA_ShareOpenGLContexts = 0
     119: 
     120:     class AspectRatioMode:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 121 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "KeepAspectRatio" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-23 |
| Tags | convention |

**üíª Codice attuale:**
```python
     119: 
     120:     class AspectRatioMode:
 >>> 121:         KeepAspectRatio = 1
     122: 
     123:     class TransformationMode:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 124 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "SmoothTransformation" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-28 |
| Tags | convention |

**üíª Codice attuale:**
```python
     122: 
     123:     class TransformationMode:
 >>> 124:         SmoothTransformation = 1
     125: 
     126:     class CursorShape:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 127 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "PointingHandCursor" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-26 |
| Tags | convention |

**üíª Codice attuale:**
```python
     125: 
     126:     class CursorShape:
 >>> 127:         PointingHandCursor = 0
     128: 
     129:     class PenStyle:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 130 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "NoPen" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-13 |
| Tags | convention |

**üíª Codice attuale:**
```python
     128: 
     129:     class PenStyle:
 >>> 130:         NoPen = 0
     131: 
     132:     class WindowType:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 133 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "FramelessWindowHint" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-27 |
| Tags | convention |

**üíª Codice attuale:**
```python
     131: 
     132:     class WindowType:
 >>> 133:         FramelessWindowHint = 0
     134:         Tool = 0
     135:         WindowStaysOnTopHint = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 134 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Tool" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-12 |
| Tags | convention |

**üíª Codice attuale:**
```python
     132:     class WindowType:
     133:         FramelessWindowHint = 0
 >>> 134:         Tool = 0
     135:         WindowStaysOnTopHint = 0
     136:         Dialog = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 135 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WindowStaysOnTopHint" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-28 |
| Tags | convention |

**üíª Codice attuale:**
```python
     133:         FramelessWindowHint = 0
     134:         Tool = 0
 >>> 135:         WindowStaysOnTopHint = 0
     136:         Dialog = 0
     137:         SubWindow = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 136 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Dialog" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-14 |
| Tags | convention |

**üíª Codice attuale:**
```python
     134:         Tool = 0
     135:         WindowStaysOnTopHint = 0
 >>> 136:         Dialog = 0
     137:         SubWindow = 0
     138: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 137 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "SubWindow" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-17 |
| Tags | convention |

**üíª Codice attuale:**
```python
     135:         WindowStaysOnTopHint = 0
     136:         Dialog = 0
 >>> 137:         SubWindow = 0
     138: 
     139:     class WidgetAttribute:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 140 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WA_TranslucentBackground" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-32 |
| Tags | convention |

**üíª Codice attuale:**
```python
     138: 
     139:     class WidgetAttribute:
 >>> 140:         WA_TranslucentBackground = 0
     141:         WA_ShowWithoutActivating = 0
     142:         WA_DeleteOnClose = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 141 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WA_ShowWithoutActivating" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-32 |
| Tags | convention |

**üíª Codice attuale:**
```python
     139:     class WidgetAttribute:
     140:         WA_TranslucentBackground = 0
 >>> 141:         WA_ShowWithoutActivating = 0
     142:         WA_DeleteOnClose = 0
     143:         WA_TransparentForMouseEvents = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 142 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WA_DeleteOnClose" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-24 |
| Tags | convention |

**üíª Codice attuale:**
```python
     140:         WA_TranslucentBackground = 0
     141:         WA_ShowWithoutActivating = 0
 >>> 142:         WA_DeleteOnClose = 0
     143:         WA_TransparentForMouseEvents = 0
     144: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 143 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "WA_TransparentForMouseEvents" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-36 |
| Tags | convention |

**üíª Codice attuale:**
```python
     141:         WA_ShowWithoutActivating = 0
     142:         WA_DeleteOnClose = 0
 >>> 143:         WA_TransparentForMouseEvents = 0
     144: 
     145:     class BrushStyle:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 146 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "NoBrush" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     144: 
     145:     class BrushStyle:
 >>> 146:         NoBrush = 0
     147: 
     148:     class AlignmentFlag:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 149 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignCenter" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-19 |
| Tags | convention |

**üíª Codice attuale:**
```python
     147: 
     148:     class AlignmentFlag:
 >>> 149:         AlignCenter = 0
     150:         AlignLeft = 0
     151:         AlignRight = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 150 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignLeft" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-17 |
| Tags | convention |

**üíª Codice attuale:**
```python
     148:     class AlignmentFlag:
     149:         AlignCenter = 0
 >>> 150:         AlignLeft = 0
     151:         AlignRight = 0
     152:         AlignTop = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 151 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignRight" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-18 |
| Tags | convention |

**üíª Codice attuale:**
```python
     149:         AlignCenter = 0
     150:         AlignLeft = 0
 >>> 151:         AlignRight = 0
     152:         AlignTop = 0
     153:         AlignBottom = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 152 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignTop" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     150:         AlignLeft = 0
     151:         AlignRight = 0
 >>> 152:         AlignTop = 0
     153:         AlignBottom = 0
     154:         AlignVCenter = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 153 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignBottom" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-19 |
| Tags | convention |

**üíª Codice attuale:**
```python
     151:         AlignRight = 0
     152:         AlignTop = 0
 >>> 153:         AlignBottom = 0
     154:         AlignVCenter = 0
     155:         AlignHCenter = 0
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 154 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignVCenter" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-20 |
| Tags | convention |

**üíª Codice attuale:**
```python
     152:         AlignTop = 0
     153:         AlignBottom = 0
 >>> 154:         AlignVCenter = 0
     155:         AlignHCenter = 0
     156: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 155 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AlignHCenter" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-20 |
| Tags | convention |

**üíª Codice attuale:**
```python
     153:         AlignBottom = 0
     154:         AlignVCenter = 0
 >>> 155:         AlignHCenter = 0
     156: 
     157:     class TextFlag:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 158 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "TextWordWrap" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-20 |
| Tags | convention |

**üíª Codice attuale:**
```python
     156: 
     157:     class TextFlag:
 >>> 158:         TextWordWrap = 0
     159: 
     160:     class EditTrigger:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 161 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "NoEditTriggers" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-22 |
| Tags | convention |

**üíª Codice attuale:**
```python
     159: 
     160:     class EditTrigger:
 >>> 161:         NoEditTriggers = 0
     162:         DoubleClicked = 1
     163: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 162 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "DoubleClicked" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-21 |
| Tags | convention |

**üíª Codice attuale:**
```python
     160:     class EditTrigger:
     161:         NoEditTriggers = 0
 >>> 162:         DoubleClicked = 1
     163: 
     164:     class SelectionBehavior:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 165 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "SelectRows" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-18 |
| Tags | convention |

**üíª Codice attuale:**
```python
     163: 
     164:     class SelectionBehavior:
 >>> 165:         SelectRows = 1
     166:         SelectItems = 0
     167: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 166 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "SelectItems" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-19 |
| Tags | convention |

**üíª Codice attuale:**
```python
     164:     class SelectionBehavior:
     165:         SelectRows = 1
 >>> 166:         SelectItems = 0
     167: 
     168:     class SelectionMode:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 169 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "ExtendedSelection" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-25 |
| Tags | convention |

**üíª Codice attuale:**
```python
     167: 
     168:     class SelectionMode:
 >>> 169:         ExtendedSelection = 1
     170:         SingleSelection = 0
     171:     
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 170 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "SingleSelection" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-23 |
| Tags | convention |

**üíª Codice attuale:**
```python
     168:     class SelectionMode:
     169:         ExtendedSelection = 1
 >>> 170:         SingleSelection = 0
     171:     
     172:     class TextFormat:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 173 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "RichText" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     171:     
     172:     class TextFormat:
 >>> 173:         RichText = 1
     174: 
     175: class DummyQLayoutItem:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 192 üü° üü¢ MINOR

**üéØ Problema:** Rename method "isValid" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     190:         return self._column
     191: 
 >>> 192:     def isValid(self):
     193:         return True
     194: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 195 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "role".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 19-25 |
| Tags | unused |

**üíª Codice attuale:**
```python
     193:         return True
     194: 
 >>> 195:     def data(self, role=0):
     196:         return None
     197: 
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 203 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "parent".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 33-44 |
| Tags | unused |

**üíª Codice attuale:**
```python
     201:         self._data = []
     202: 
 >>> 203:     def index(self, row, column, parent=None):
     204:         return DummyQModelIndex(row, column)
     205: 
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 206 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     204:         return DummyQModelIndex(row, column)
     205: 
 >>> 206:     def beginResetModel(self): pass
     207:     def endResetModel(self): pass
     208:     def layoutChanged(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 207 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     205: 
     206:     def beginResetModel(self): pass
 >>> 207:     def endResetModel(self): pass
     208:     def layoutChanged(self):
     209:         return DummySignal()
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 210 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "parent".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-34 |
| Tags | unused |

**üíª Codice attuale:**
```python
     208:     def layoutChanged(self):
     209:         return DummySignal()
 >>> 210:     def rowCount(self, parent=None): return 0
     211:     def columnCount(self, parent=None): return 0
     212:     def data(self, index, role=0): return None
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 211 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "parent".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 26-37 |
| Tags | unused |

**üíª Codice attuale:**
```python
     209:         return DummySignal()
     210:     def rowCount(self, parent=None): return 0
 >>> 211:     def columnCount(self, parent=None): return 0
     212:     def data(self, index, role=0): return None
     213:     def flags(self, index): return 0
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 212 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "role".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 26-32 |
| Tags | unused |

**üíª Codice attuale:**
```python
     210:     def rowCount(self, parent=None): return 0
     211:     def columnCount(self, parent=None): return 0
 >>> 212:     def data(self, index, role=0): return None
     213:     def flags(self, index): return 0
     214:     def headerData(self, section, orientation, role=0): return None
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 212 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "index".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 19-24 |
| Tags | unused |

**üíª Codice attuale:**
```python
     210:     def rowCount(self, parent=None): return 0
     211:     def columnCount(self, parent=None): return 0
 >>> 212:     def data(self, index, role=0): return None
     213:     def flags(self, index): return 0
     214:     def headerData(self, section, orientation, role=0): return None
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 213 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "index".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 20-25 |
| Tags | unused |

**üíª Codice attuale:**
```python
     211:     def columnCount(self, parent=None): return 0
     212:     def data(self, index, role=0): return None
 >>> 213:     def flags(self, index): return 0
     214:     def headerData(self, section, orientation, role=0): return None
     215: 
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 214 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "orientation".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 34-45 |
| Tags | unused |

**üíª Codice attuale:**
```python
     212:     def data(self, index, role=0): return None
     213:     def flags(self, index): return 0
 >>> 214:     def headerData(self, section, orientation, role=0): return None
     215: 
     216: class DummyQPoint:
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 214 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "section".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 25-32 |
| Tags | unused |

**üíª Codice attuale:**
```python
     212:     def data(self, index, role=0): return None
     213:     def flags(self, index): return 0
 >>> 214:     def headerData(self, section, orientation, role=0): return None
     215: 
     216: class DummyQPoint:
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 214 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "role".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 47-53 |
| Tags | unused |

**üíª Codice attuale:**
```python
     212:     def data(self, index, role=0): return None
     213:     def flags(self, index): return 0
 >>> 214:     def headerData(self, section, orientation, role=0): return None
     215: 
     216: class DummyQPoint:
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 237 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     235:             if hasattr(y, 'width'):
     236:                 try: self._w = int(y.width())
 >>> 237:                 except: pass
     238:             if hasattr(y, 'height'):
     239:                 try: self._h = int(y.height())
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 240 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     238:             if hasattr(y, 'height'):
     239:                 try: self._h = int(y.height())
 >>> 240:                 except: pass
     241:         else:
     242:             self._x = int(x)
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 252 üü° üü¢ MINOR

**üéØ Problema:** Rename method "isValid" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     250:     def height(self): return int(self._h)
     251:     def contains(self, *args): return False
 >>> 252:     def isValid(self): return True
     253: 
     254:     def translated(self, x, y):
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 305 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     303:         self._text = text if isinstance(text, str) else ""
     304: 
 >>> 305:     def setLayout(self, layout):
     306:         pass
     307:     def layout(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 315 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     313:     def setVisible(self, visible):
     314:         self._visible = visible
 >>> 315:     def showEvent(self, event):
     316:         pass
     317:     def closeEvent(self, event):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 317 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     315:     def showEvent(self, event):
     316:         pass
 >>> 317:     def closeEvent(self, event):
     318:         pass
     319:     def close(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 324 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "block".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 27-32 |
| Tags | unused |

**üíª Codice attuale:**
```python
     322:     def isVisible(self):
     323:         return getattr(self, '_visible', True)
 >>> 324:     def blockSignals(self, block):
     325:         return False
     326:     def setUpdatesEnabled(self, enable):
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 326 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-25 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     324:     def blockSignals(self, block):
     325:         return False
 >>> 326:     def setUpdatesEnabled(self, enable):
     327:         pass
     328:     def setWindowTitle(self, title):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 328 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     326:     def setUpdatesEnabled(self, enable):
     327:         pass
 >>> 328:     def setWindowTitle(self, title):
     329:         pass
     330:     def setWindowFlags(self, flags):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 330 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     328:     def setWindowTitle(self, title):
     329:         pass
 >>> 330:     def setWindowFlags(self, flags):
     331:         pass
     332:     def windowFlags(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 334 üü° üî¥ BLOCKER

**üéØ Problema:** Rename method "windowState" to prevent any misunderstanding/clash with field "WindowState" defined on line 275

| Campo | Valore |
|-------|--------|
| Regola | `python:S1845` - Methods and field names should not differ only by capitalization |
| Categoria | MAINTAINABILITY |
| Severit√† | BLOCKER |
| Effort | 10min |
| Posizione | Colonne 8-19 |
| Tags | confusing, convention |

**üíª Codice attuale:**
```python
     332:     def windowFlags(self):
     333:         return 0
 >>> 334:     def windowState(self):
     335:         return DummyEnum.WindowNoState
     336:     def isWindow(self):
```

**‚ùì Perch√© √® un problema:**

Looking at the set of methods and fields in a `class` and finding two that differ only by capitalization is confusing to users of the
class.

This situation may simply indicate poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the case
where both a method and a field have the same name (with or without capitalization differences). However, renaming a public method could be disruptive
to callers. Therefore renaming the member is the recommended action.

##### Noncompliant code example

```
class SomeClass:
 lookUp = false
 def lookup(): # Non-compliant; method name differs from field name only by capitalization
 pass
```

##### Compliant solution

```
class SomeClass:
 lookUp = false
 def getLookUp():
 pass
```

**üìù Descrizione:**

This rule raises an issue when there is a method and a field in a class with names that differ only by capitalization.

### Why is this an issue?

Looking at the set of methods and fields in a `class` and finding two that differ only by capitalization is confusing to users of the
class.

This situation may simply indicate poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the case
where both a method and a field have the same name (with or without capitalization differences). However, renaming a public method could be disruptive
to callers. Therefore renaming the member is the recommended action.

#### Code examples

##### Noncompliant code example

```
class SomeClass:
 lookUp = false
 def lookup(): # Non-compliant; method name differs from field name only by capitalization
 pass
```

##### Compliant solution

```
class SomeClass:
 lookUp = false
 def getLookUp():
 pass
```

---

### Riga 338 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     336:     def isWindow(self):
     337:         return False
 >>> 338:     def showMaximized(self):
     339:         pass
     340:     def activateWindow(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 340 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     338:     def showMaximized(self):
     339:         pass
 >>> 340:     def activateWindow(self):
     341:         pass
     342:     def setAttribute(self, attr, on=True):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 342 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     340:     def activateWindow(self):
     341:         pass
 >>> 342:     def setAttribute(self, attr, on=True):
     343:         pass
     344:     def raise_(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 344 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     342:     def setAttribute(self, attr, on=True):
     343:         pass
 >>> 344:     def raise_(self):
     345:         pass
     346:     def resizeEvent(self, event):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 346 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     344:     def raise_(self):
     345:         pass
 >>> 346:     def resizeEvent(self, event):
     347:         pass
     348:     def resize(self, *args):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 348 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     346:     def resizeEvent(self, event):
     347:         pass
 >>> 348:     def resize(self, *args):
     349:         pass
     350:     def size(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 352 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     350:     def size(self):
     351:         return MagicMock()
 >>> 352:     def setGeometry(self, *args):
     353:         pass
     354:     def geometry(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 358 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-12 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     356:     def pos(self):
     357:         return DummyQPoint(0, 0)
 >>> 358:     def move(self, x, y):
     359:         pass
     360:     def setObjectName(self, name):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 360 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     358:     def move(self, x, y):
     359:         pass
 >>> 360:     def setObjectName(self, name):
     361:         pass
     362:     def setFixedWidth(self, width):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 362 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     360:     def setObjectName(self, name):
     361:         pass
 >>> 362:     def setFixedWidth(self, width):
     363:         pass
     364:     def width(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 366 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     364:     def width(self):
     365:         return 100
 >>> 366:     def setFixedHeight(self, height):
     367:         pass
     368:     def height(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 370 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     368:     def height(self):
     369:         return 100
 >>> 370:     def setFixedSize(self, w, h):
     371:         pass
     372:     def setMinimumWidth(self, width):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 372 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     370:     def setFixedSize(self, w, h):
     371:         pass
 >>> 372:     def setMinimumWidth(self, width):
     373:         pass
     374:     def setMinimumHeight(self, height):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 374 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-24 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     372:     def setMinimumWidth(self, width):
     373:         pass
 >>> 374:     def setMinimumHeight(self, height):
     375:         pass
     376:     def setMinimumDate(self, date):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 376 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     374:     def setMinimumHeight(self, height):
     375:         pass
 >>> 376:     def setMinimumDate(self, date):
     377:         pass
     378:     def setSpecialValueText(self, text):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 378 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-27 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     376:     def setMinimumDate(self, date):
     377:         pass
 >>> 378:     def setSpecialValueText(self, text):
     379:         pass
     380:     def setMaximumWidth(self, width):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 380 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     378:     def setSpecialValueText(self, text):
     379:         pass
 >>> 380:     def setMaximumWidth(self, width):
     381:         pass
     382:     def setContentsMargins(self, l, t, r, b):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 382 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-26 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     380:     def setMaximumWidth(self, width):
     381:         pass
 >>> 382:     def setContentsMargins(self, l, t, r, b):
     383:         pass
     384:     def setSpacing(self, spacing):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 384 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     382:     def setContentsMargins(self, l, t, r, b):
     383:         pass
 >>> 384:     def setSpacing(self, spacing):
     385:         pass
     386:     def setCursor(self, cursor):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 386 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     384:     def setSpacing(self, spacing):
     385:         pass
 >>> 386:     def setCursor(self, cursor):
     387:         pass
     388:     def setMouseTracking(self, enable):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 388 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-24 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     386:     def setCursor(self, cursor):
     387:         pass
 >>> 388:     def setMouseTracking(self, enable):
     389:         pass
     390:     def setTextInteractionFlags(self, flags):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 390 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-31 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     388:     def setMouseTracking(self, enable):
     389:         pass
 >>> 390:     def setTextInteractionFlags(self, flags):
     391:         pass
     392:     def setWordWrap(self, on):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 392 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     390:     def setTextInteractionFlags(self, flags):
     391:         pass
 >>> 392:     def setWordWrap(self, on):
     393:         pass
     394:     def setToolTip(self, text):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 394 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     392:     def setWordWrap(self, on):
     393:         pass
 >>> 394:     def setToolTip(self, text):
     395:         pass
     396:     def setProperty(self, name, value):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 396 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     394:     def setToolTip(self, text):
     395:         pass
 >>> 396:     def setProperty(self, name, value):
     397:         pass
     398:     def property(self, name):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 398 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "name".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-27 |
| Tags | unused |

**üíª Codice attuale:**
```python
     396:     def setProperty(self, name, value):
     397:         pass
 >>> 398:     def property(self, name):
     399:         return "mock_property"
     400:     def findChild(self, type, name=""):
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 400 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "type".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 24-28 |
| Tags | unused |

**üíª Codice attuale:**
```python
     398:     def property(self, name):
     399:         return "mock_property"
 >>> 400:     def findChild(self, type, name=""):
     401:         # Return a mock that can handle setText, etc.
     402:         m = MagicMock()
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 400 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "name".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 30-37 |
| Tags | unused |

**üíª Codice attuale:**
```python
     398:     def property(self, name):
     399:         return "mock_property"
 >>> 400:     def findChild(self, type, name=""):
     401:         # Return a mock that can handle setText, etc.
     402:         m = MagicMock()
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 412 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     410:     def addWidget(self, widget, *args, **kwargs):
     411:         self.widgets.append(widget)
 >>> 412:     def addLayout(self, layout, stretch=0):
     413:         pass
     414:     def addStretch(self, stretch=0):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 414 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     412:     def addLayout(self, layout, stretch=0):
     413:         pass
 >>> 414:     def addStretch(self, stretch=0):
     415:         pass
     416:     def itemAt(self, index):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 420 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     418:             return DummyQLayoutItem(self.widgets[index])
     419:         return None
 >>> 420:     def addSpacing(self, spacing):
     421:         pass
     422:     def setStretch(self, index, stretch):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 422 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     420:     def addSpacing(self, spacing):
     421:         pass
 >>> 422:     def setStretch(self, index, stretch):
     423:         pass
     424:     def setEchoMode(self, mode):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 424 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     422:     def setStretch(self, index, stretch):
     423:         pass
 >>> 424:     def setEchoMode(self, mode):
     425:         pass
     426:     def setPlaceholderText(self, text):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 426 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-26 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     424:     def setEchoMode(self, mode):
     425:         pass
 >>> 426:     def setPlaceholderText(self, text):
     427:         pass
     428:     def setText(self, text):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 440 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "userData".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 28-41 |
| Tags | unused |

**üíª Codice attuale:**
```python
     438:     def addItems(self, items):
     439:         self.widgets.extend(items)
 >>> 440:     def addItem(self, item, userData=None):
     441:         self.widgets.append(item)
     442:     def setFrameShape(self, shape):
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 440 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "userData" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 28-36 |
| Tags | convention |

**üíª Codice attuale:**
```python
     438:     def addItems(self, items):
     439:         self.widgets.extend(items)
 >>> 440:     def addItem(self, item, userData=None):
     441:         self.widgets.append(item)
     442:     def setFrameShape(self, shape):
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

### Riga 442 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     440:     def addItem(self, item, userData=None):
     441:         self.widgets.append(item)
 >>> 442:     def setFrameShape(self, shape):
     443:         pass
     444:     def setFrameShadow(self, shadow):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 444 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     442:     def setFrameShape(self, shape):
     443:         pass
 >>> 444:     def setFrameShadow(self, shadow):
     445:         pass
     446:     def setFieldGrowthPolicy(self, policy):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 446 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-28 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     444:     def setFrameShadow(self, shadow):
     445:         pass
 >>> 446:     def setFieldGrowthPolicy(self, policy):
     447:         pass
     448:     def addRow(self, label, field=None):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 448 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     446:     def setFieldGrowthPolicy(self, policy):
     447:         pass
 >>> 448:     def addRow(self, label, field=None):
     449:         pass
     450:     def setAlignment(self, alignment):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 450 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     448:     def addRow(self, label, field=None):
     449:         pass
 >>> 450:     def setAlignment(self, alignment):
     451:         pass
     452:     def setPixmap(self, pixmap):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 452 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     450:     def setAlignment(self, alignment):
     451:         pass
 >>> 452:     def setPixmap(self, pixmap):
     453:         pass
     454:     def setCheckable(self, checkable):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 454 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     452:     def setPixmap(self, pixmap):
     453:         pass
 >>> 454:     def setCheckable(self, checkable):
     455:         pass
     456:     def setIcon(self, icon):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 456 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     454:     def setCheckable(self, checkable):
     455:         pass
 >>> 456:     def setIcon(self, icon):
     457:         pass
     458:     def setIconSize(self, size):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 458 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     456:     def setIcon(self, icon):
     457:         pass
 >>> 458:     def setIconSize(self, size):
     459:         pass
     460:     def setStyleSheet(self, style):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 460 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     458:     def setIconSize(self, size):
     459:         pass
 >>> 460:     def setStyleSheet(self, style):
     461:         pass
     462:     def styleSheet(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 464 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-25 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     462:     def styleSheet(self):
     463:         return ""
 >>> 464:     def setGraphicsEffect(self, effect):
     465:         pass
     466:     def setChecked(self, checked):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 470 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-24 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     468:     def isChecked(self):
     469:         return getattr(self, '_checked', True)
 >>> 470:     def setCurrentWidget(self, widget):
     471:         pass
     472:     def currentWidget(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 492 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     490:         m.selectionChanged = DummySignal()
     491:         return m
 >>> 492:     def setCurrentIndex(self, index):
     493:         pass
     494:     def setAcceptDrops(self, accept):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 494 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     492:     def setCurrentIndex(self, index):
     493:         pass
 >>> 494:     def setAcceptDrops(self, accept):
     495:         pass
     496:     def verticalHeader(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 504 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-28 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     502:         m.setSectionResizeMode = MagicMock()
     503:         return m
 >>> 504:     def setSelectionBehavior(self, behavior):
     505:         pass
     506:     def setSelectionMode(self, mode):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 506 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-24 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     504:     def setSelectionBehavior(self, behavior):
     505:         pass
 >>> 506:     def setSelectionMode(self, mode):
     507:         pass
     508:     def setEditTriggers(self, triggers):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 508 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     506:     def setSelectionMode(self, mode):
     507:         pass
 >>> 508:     def setEditTriggers(self, triggers):
     509:         pass
     510:     def setAlternatingRowColors(self, enable):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 510 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-31 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     508:     def setEditTriggers(self, triggers):
     509:         pass
 >>> 510:     def setAlternatingRowColors(self, enable):
     511:         pass
     512:     def setModel(self, model):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 516 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     514:     def model(self):
     515:         return getattr(self, '_model', None)
 >>> 516:     def setColumnHidden(self, col, hidden):
     517:         pass
     518:     def selectRow(self, row):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 518 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     516:     def setColumnHidden(self, col, hidden):
     517:         pass
 >>> 518:     def selectRow(self, row):
     519:         pass
     520:     def setShowGrid(self, show):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 520 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     518:     def selectRow(self, row):
     519:         pass
 >>> 520:     def setShowGrid(self, show):
     521:         pass
     522:     def setEditable(self, editable):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 522 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     520:     def setShowGrid(self, show):
     521:         pass
 >>> 522:     def setEditable(self, editable):
     523:         pass
     524:     def setView(self, view):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 524 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     522:     def setEditable(self, editable):
     523:         pass
 >>> 524:     def setView(self, view):
     525:         pass
     526:     def setSizeAdjustPolicy(self, policy):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 526 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-27 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     524:     def setView(self, view):
     525:         pass
 >>> 526:     def setSizeAdjustPolicy(self, policy):
     527:         pass
     528:     def setDisplayFormat(self, format):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 528 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-24 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     526:     def setSizeAdjustPolicy(self, policy):
     527:         pass
 >>> 528:     def setDisplayFormat(self, format):
     529:         pass
     530:     def setCalendarPopup(self, enable):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 530 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-24 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     528:     def setDisplayFormat(self, format):
     529:         pass
 >>> 530:     def setCalendarPopup(self, enable):
     531:         pass
     532:     def setDate(self, date):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 532 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     530:     def setCalendarPopup(self, enable):
     531:         pass
 >>> 532:     def setDate(self, date):
     533:         pass
     534:     def date(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 536 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "which".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-26 |
| Tags | unused |

**üíª Codice attuale:**
```python
     534:     def date(self):
     535:         return DummyQDate()
 >>> 536:     def button(self, which):
     537:         return DummyQWidget()
     538:     def adjustSize(self):
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 538 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     536:     def button(self, which):
     537:         return DummyQWidget()
 >>> 538:     def adjustSize(self):
     539:         pass
     540:     def update(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 540 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     538:     def adjustSize(self):
     539:         pass
 >>> 540:     def update(self):
     541:         pass
     542:     def repaint(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 542 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     540:     def update(self):
     541:         pass
 >>> 542:     def repaint(self):
     543:         pass
     544:     def setCurrentText(self, text):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 544 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     542:     def repaint(self):
     543:         pass
 >>> 544:     def setCurrentText(self, text):
     545:         pass
     546:     def accept(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 546 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     544:     def setCurrentText(self, text):
     545:         pass
 >>> 546:     def accept(self):
     547:         pass
     548:     def reject(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 548 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     546:     def accept(self):
     547:         pass
 >>> 548:     def reject(self):
     549:         pass
     550:     def setReadOnly(self, ro):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 550 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     548:     def reject(self):
     549:         pass
 >>> 550:     def setReadOnly(self, ro):
     551:         pass
     552:     def viewport(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 557 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "pos".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 22-25 |
| Tags | unused |

**üíª Codice attuale:**
```python
     555:         m.width.return_value = 800
     556:         return m
 >>> 557:     def indexAt(self, pos):
     558:         m = MagicMock()
     559:         m.isValid.return_value = False
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 561 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-28 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     559:         m.isValid.return_value = False
     560:         return m
 >>> 561:     def setContextMenuPolicy(self, policy):
     562:         pass
     563:     def setScene(self, scene):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 563 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     561:     def setContextMenuPolicy(self, policy):
     562:         pass
 >>> 563:     def setScene(self, scene):
     564:         pass
     565:     def setRange(self, min, max):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 565 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     563:     def setScene(self, scene):
     564:         pass
 >>> 565:     def setRange(self, min, max):
     566:         pass
     567:     def setTextVisible(self, v):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 567 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     565:     def setRange(self, min, max):
     566:         pass
 >>> 567:     def setTextVisible(self, v):
     568:         pass
     569:     def setValue(self, v):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 575 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     573:     def maximum(self):
     574:         return 100
 >>> 575:     def setMaximum(self, m):
     576:         pass
     577:     def rect(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 584 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     582:             return self.widgets.index(widget)
     583:         return -1
 >>> 584:     def insertWidget(self, i, w):
     585:         pass
     586:     def takeAt(self, i):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 586 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "i".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-22 |
| Tags | unused |

**üíª Codice attuale:**
```python
     584:     def insertWidget(self, i, w):
     585:         pass
 >>> 586:     def takeAt(self, i):
     587:         return DummyQLayoutItem(MagicMock())
     588:     def setSizes(self, sizes):
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 588 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     586:     def takeAt(self, i):
     587:         return DummyQLayoutItem(MagicMock())
 >>> 588:     def setSizes(self, sizes):
     589:         pass
     590:     def setHeaderLabels(self, labels):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 590 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     588:     def setSizes(self, sizes):
     589:         pass
 >>> 590:     def setHeaderLabels(self, labels):
     591:         pass
     592:     def setFont(self, font):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 592 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     590:     def setHeaderLabels(self, labels):
     591:         pass
 >>> 592:     def setFont(self, font):
     593:         pass
     594:     def clear(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 598 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     596:         if getattr(self, '_model', None):
     597:             self._model._data = []
 >>> 598:     def setStartValue(self, v):
     599:         pass
     600:     def setEndValue(self, v):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 600 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     598:     def setStartValue(self, v):
     599:         pass
 >>> 600:     def setEndValue(self, v):
     601:         pass
     602:     def setDuration(self, d):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 602 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     600:     def setEndValue(self, v):
     601:         pass
 >>> 602:     def setDuration(self, d):
     603:         pass
     604:     def setEasingCurve(self, c):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 604 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     602:     def setDuration(self, d):
     603:         pass
 >>> 604:     def setEasingCurve(self, c):
     605:         pass
     606:     def start(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 606 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-13 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     604:     def setEasingCurve(self, c):
     605:         pass
 >>> 606:     def start(self):
     607:         pass
     608:     def stop(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 608 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-12 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     606:     def start(self):
     607:         pass
 >>> 608:     def stop(self):
     609:         pass
     610:     def valueChanged(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 616 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     614:     def clicked(self):
     615:         return self._clicked
 >>> 616:     def setSceneRect(self, *args):
     617:         pass
     618:     def mapToGlobal(self, pos):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 620 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-12 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     618:     def mapToGlobal(self, pos):
     619:         return pos
 >>> 620:     def exec(self, *args):
     621:         pass
     622:     def installEventFilter(self, filterObj):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 622 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "filterObj" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 33-42 |
| Tags | convention |

**üíª Codice attuale:**
```python
     620:     def exec(self, *args):
     621:         pass
 >>> 622:     def installEventFilter(self, filterObj):
     623:         pass
     624:     def setTextFormat(self, fmt):
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

### Riga 622 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-26 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     620:     def exec(self, *args):
     621:         pass
 >>> 622:     def installEventFilter(self, filterObj):
     623:         pass
     624:     def setTextFormat(self, fmt):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 624 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     622:     def installEventFilter(self, filterObj):
     623:         pass
 >>> 624:     def setTextFormat(self, fmt):
     625:         pass
     626:     def setOpenExternalLinks(self, open):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 626 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-28 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     624:     def setTextFormat(self, fmt):
     625:         pass
 >>> 626:     def setOpenExternalLinks(self, open):
     627:         pass
     628:     def setItemDelegateForColumn(self, col, delegate):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 628 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-32 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     626:     def setOpenExternalLinks(self, open):
     627:         pass
 >>> 628:     def setItemDelegateForColumn(self, col, delegate):
     629:         pass
     630: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 699 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-24 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     697: 
     698: class DummyQMainWindow(DummyQWidget):
 >>> 699:     def setCentralWidget(self, widget):
     700:         pass
     701: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 703 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-12 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     701: 
     702: class DummyQDialog(DummyQWidget):
 >>> 703:     def exec(self):
     704:         pass
     705: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 718 üü° üü¢ MINOR

**üéØ Problema:** Rename method "currentDate" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | convention |

**üíª Codice attuale:**
```python
     716: 
     717:     @staticmethod
 >>> 718:     def currentDate():
     719:         return DummyQDate(datetime.date.today())
     720: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 722 üü° üü¢ MINOR

**üéØ Problema:** Rename method "fromString" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | convention |

**üíª Codice attuale:**
```python
     720: 
     721:     @staticmethod
 >>> 722:     def fromString(s, f):
     723:         # Basic parsing for "dd/MM/yyyy" which is used in the view
     724:         try:
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 728 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     726:                 d = datetime.datetime.strptime(s, "%d/%m/%Y").date()
     727:                 return DummyQDate(d)
 >>> 728:         except:
     729:             pass
     730:         return DummyQDate()
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 732 üü° üü¢ MINOR

**üéØ Problema:** Rename method "addDays" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     730:         return DummyQDate()
     731: 
 >>> 732:     def addDays(self, days):
     733:         return DummyQDate(self._date + datetime.timedelta(days=days))
     734: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 735 üü° üü¢ MINOR

**üéØ Problema:** Rename method "addMonths" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | convention |

**üíª Codice attuale:**
```python
     733:         return DummyQDate(self._date + datetime.timedelta(days=days))
     734: 
 >>> 735:     def addMonths(self, months):
     736:         return DummyQDate(self._date + relativedelta(months=months))
     737: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 738 üü° üü¢ MINOR

**üéØ Problema:** Rename method "setDate" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     736:         return DummyQDate(self._date + relativedelta(months=months))
     737: 
 >>> 738:     def setDate(self, y, m, d):
     739:         self._date = datetime.date(y, m, d)
     740: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 745 üü° üü¢ MINOR

**üéØ Problema:** Rename method "daysTo" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | convention |

**üíª Codice attuale:**
```python
     743:     def day(self): return self._date.day
     744: 
 >>> 745:     def daysTo(self, other):
     746:         if isinstance(other, DummyQDate):
     747:             return (other._date - self._date).days
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 750 üü° üü¢ MINOR

**üéØ Problema:** Rename method "toString" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     748:         return 0
     749: 
 >>> 750:     def toString(self, format_str):
     751:         # Simple mapping for common Qt format strings to strftime
     752:         fmt = format_str.replace("dd", "%d").replace("MM", "%m").replace("yyyy", "%Y")
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 756 üü° üü¢ MINOR

**üéØ Problema:** Rename method "toPyDate" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     754:         return self._date.strftime(fmt)
     755: 
 >>> 756:     def toPyDate(self):
     757:         return self._date
     758: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 759 üü° üü¢ MINOR

**üéØ Problema:** Rename method "isValid" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     757:         return self._date
     758: 
 >>> 759:     def isValid(self):
     760:         return True
     761: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 788 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Language" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-12 |
| Tags | convention |

**üíª Codice attuale:**
```python
     786: 
     787: class DummyQLocale:
 >>> 788:     Language = MagicMock()
     789:     Country = MagicMock()
     790:     def __init__(self, *args):
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 789 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Country" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 4-11 |
| Tags | convention |

**üíª Codice attuale:**
```python
     787: class DummyQLocale:
     788:     Language = MagicMock()
 >>> 789:     Country = MagicMock()
     790:     def __init__(self, *args):
     791:         pass
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 790 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     788:     Language = MagicMock()
     789:     Country = MagicMock()
 >>> 790:     def __init__(self, *args):
     791:         pass
     792:     def toString(self, date, fmt):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 792 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "date".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-27 |
| Tags | unused |

**üíª Codice attuale:**
```python
     790:     def __init__(self, *args):
     791:         pass
 >>> 792:     def toString(self, date, fmt):
     793:         return "Jan 2025"
     794: 
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 792 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "fmt".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 29-32 |
| Tags | unused |

**üíª Codice attuale:**
```python
     790:     def __init__(self, *args):
     791:         pass
 >>> 792:     def toString(self, date, fmt):
     793:         return "Jan 2025"
     794: 
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 792 üü° üü¢ MINOR

**üéØ Problema:** Rename method "toString" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | convention |

**üíª Codice attuale:**
```python
     790:     def __init__(self, *args):
     791:         pass
 >>> 792:     def toString(self, date, fmt):
     793:         return "Jan 2025"
     794: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 803 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "col".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 19-22 |
| Tags | unused |

**üíª Codice attuale:**
```python
     801:         pass
     802: 
 >>> 803:     def data(self, col, role):
     804:         return None
     805: 
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 803 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "role".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 24-28 |
| Tags | unused |

**üíª Codice attuale:**
```python
     801:         pass
     802: 
 >>> 803:     def data(self, col, role):
     804:         return None
     805: 
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 809 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     807:     def __init__(self, *args, **kwargs):
     808:         super().__init__()
 >>> 809:     def setFont(self, font): pass
     810:     def setPos(self, x, y): pass
     811:     def setDefaultTextColor(self, color): pass
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 810 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     808:         super().__init__()
     809:     def setFont(self, font): pass
 >>> 810:     def setPos(self, x, y): pass
     811:     def setDefaultTextColor(self, color): pass
     812:     def boundingRect(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 811 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-27 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     809:     def setFont(self, font): pass
     810:     def setPos(self, x, y): pass
 >>> 811:     def setDefaultTextColor(self, color): pass
     812:     def boundingRect(self):
     813:         m = MagicMock()
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 822 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     820:         self._z = 0
     821: 
 >>> 822:     def setBrush(self, brush): pass
     823:     def setPen(self, pen): pass
     824:     def setZValue(self, z): self._z = z
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 823 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     821: 
     822:     def setBrush(self, brush): pass
 >>> 823:     def setPen(self, pen): pass
     824:     def setZValue(self, z): self._z = z
     825:     def zValue(self): return self._z
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 826 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     824:     def setZValue(self, z): self._z = z
     825:     def zValue(self): return self._z
 >>> 826:     def setRect(self, x, y, w, h): pass
     827:     def rect(self):
     828:         m = MagicMock()
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 832 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     830:         m.width.return_value = 100
     831:         return m
 >>> 832:     def setData(self, key, value): pass
     833:     def setToolTip(self, text): pass
     834: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 833 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-18 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     831:         return m
     832:     def setData(self, key, value): pass
 >>> 833:     def setToolTip(self, text): pass
     834: 
     835: class DummyQGraphicsLineItem(DummyQObject):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 838 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     836:     def __init__(self, *args, **kwargs):
     837:         super().__init__()
 >>> 838:     def setPen(self, pen): pass
     839:     def setLine(self, x1, y1, x2, y2): pass
     840:     def line(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 839 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     837:         super().__init__()
     838:     def setPen(self, pen): pass
 >>> 839:     def setLine(self, x1, y1, x2, y2): pass
     840:     def line(self):
     841:         m = MagicMock()
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 851 üü° üî¥ CRITICAL

**üéØ Problema:** Add missing parameters userData.

| Campo | Valore |
|-------|--------|
| Regola | `python:S2638` - Method overrides should not change contracts |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 15min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     849:         self._items = []
     850: 
 >>> 851:     def addItem(self, item):
     852:         self._items.append(item)
     853: 
```

**‚ùì Perch√© √® un problema:**

Because a subclass instance may be used as an instance of the superclass, overriding methods should uphold the aspects of the superclass contract
that relate to the [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle). Specifically, an
overriding method should be callable with the same parameters as the overriden one.

The following modifications are OK:

 - Adding an optional parameter, i.e. with a default value, as long as they don‚Äôt change the order of positional parameters. 

 - Renaming a positional-only parameter. 

 - Reordering keyword-only parameters. 

 - Adding a default value to an existing parameter. 

 - Changing the default value of an existing parameter. 

 - Extend the ways a parameter can be provided, i.e. change a keyword-only or positional-only parameter to a keyword-or-positional parameter. This
 is only true if the order of positional parameters doesn‚Äôt change. New positional parameters should be placed at the end. 

 - Addi...

**üìù Descrizione:**

This rule raises an issue when an overriding method changes a contract defined in a superclass.

### Why is this an issue?

Because a subclass instance may be used as an instance of the superclass, overriding methods should uphold the aspects of the superclass contract
that relate to the [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle). Specifically, an
overriding method should be callable with the same parameters as the overriden one.

The following modifications are OK:

 - Adding an optional parameter, i.e. with a default value, as long as they don‚Äôt change the order of positional parameters. 

 - Renaming a positional-only parameter. 

 - Reordering keyword-only parameters. 

 - Adding a default value to an existing parameter. 

 - Changing the default value of an existing parameter. 

 - Extend the ways a parameter can be provided, i.e. change a keyword-only or positional-only parameter to a keyword-or-positional parameter. This
 is only...

**üìö Risorse:**

#### Documentation

 - SOLID - [Wikipedia - Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle) 

 - Python Enhancement Proposal (PEP) 3102 - [Keyword-Only Arguments](https://www.python.org/dev/peps/pep-3102/) 

 - Python Enhancement Proposal (PEP) 570 - [Python Positional-Only Parameters](https://www.python.org/dev/peps/pep-0570/)

---

### Riga 860 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     858:         self._items = []
     859: 
 >>> 860:     def setSceneRect(self, x, y, w, h):
     861:         pass
     862: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 865 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "AllNonFixedFieldsGrow" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-29 |
| Tags | convention |

**üíª Codice attuale:**
```python
     863: class DummyQFormLayout(DummyQWidget):
     864:     class FieldGrowthPolicy:
 >>> 865:         AllNonFixedFieldsGrow = 1
     866: 
     867: class DummyQTableView(DummyQWidget):
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 869 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "SelectRows" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-18 |
| Tags | convention |

**üíª Codice attuale:**
```python
     867: class DummyQTableView(DummyQWidget):
     868:     class SelectionBehavior:
 >>> 869:         SelectRows = 1
     870:     class SelectionMode:
     871:         ExtendedSelection = 1
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 871 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "ExtendedSelection" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-25 |
| Tags | convention |

**üíª Codice attuale:**
```python
     869:         SelectRows = 1
     870:     class SelectionMode:
 >>> 871:         ExtendedSelection = 1
     872: 
     873:     def __init__(self, *args, **kwargs):
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 885 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "ResizeToContents" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-24 |
| Tags | convention |

**üíª Codice attuale:**
```python
     883: class DummyQHeaderView(DummyQWidget):
     884:     class ResizeMode:
 >>> 885:         ResizeToContents = 0
     886:         Stretch = 1
     887: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 886 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Stretch" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-15 |
| Tags | convention |

**üíª Codice attuale:**
```python
     884:     class ResizeMode:
     885:         ResizeToContents = 0
 >>> 886:         Stretch = 1
     887: 
     888: class DummyQWebEngineView(DummyQWidget):
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 895 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "baseUrl".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 28-40 |
| Tags | unused |

**üíª Codice attuale:**
```python
     893:     def setUrl(self, url):
     894:         self.url = url
 >>> 895:     def setHtml(self, html, baseUrl=None):
     896:         self.html = html
     897:     def page(self):
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 895 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "baseUrl" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 28-35 |
| Tags | convention |

**üíª Codice attuale:**
```python
     893:     def setUrl(self, url):
     894:         self.url = url
 >>> 895:     def setHtml(self, html, baseUrl=None):
     896:         self.html = html
     897:     def page(self):
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

### Riga 900 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     898:         page = MagicMock()
     899:         return page
 >>> 900:     def setPage(self, page):
     901:         pass
     902: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 904 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "lineNumber" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 55-65 |
| Tags | convention |

**üíª Codice attuale:**
```python
     902: 
     903: class DummyQWebEnginePage(DummyQWidget):
 >>> 904:     def javaScriptConsoleMessage(self, level, message, lineNumber, sourceID):
     905:         pass
     906: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

### Riga 904 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "sourceID" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 67-75 |
| Tags | convention |

**üíª Codice attuale:**
```python
     902: 
     903: class DummyQWebEnginePage(DummyQWidget):
 >>> 904:     def javaScriptConsoleMessage(self, level, message, lineNumber, sourceID):
     905:         pass
     906: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

### Riga 904 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-32 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     902: 
     903: class DummyQWebEnginePage(DummyQWidget):
 >>> 904:     def javaScriptConsoleMessage(self, level, message, lineNumber, sourceID):
     905:         pass
     906: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 976 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-25 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     974:             return self._finished
     975:         
 >>> 976:         def setStartValue(self, v): pass
     977:         def setEndValue(self, v): pass
     978:         def setDuration(self, d): pass
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 977 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     975:         
     976:         def setStartValue(self, v): pass
 >>> 977:         def setEndValue(self, v): pass
     978:         def setDuration(self, d): pass
     979:         def setEasingCurve(self, c): pass
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 978 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-23 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     976:         def setStartValue(self, v): pass
     977:         def setEndValue(self, v): pass
 >>> 978:         def setDuration(self, d): pass
     979:         def setEasingCurve(self, c): pass
     980:         def state(self): return 0 # Stopped
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 979 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-26 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     977:         def setEndValue(self, v): pass
     978:         def setDuration(self, d): pass
 >>> 979:         def setEasingCurve(self, c): pass
     980:         def state(self): return 0 # Stopped
     981: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 986 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     984:             self._finished.emit()
     985:         
 >>> 986:         def stop(self): pass
     987: 
     988:     mock_core.QPropertyAnimation = DummyQPropertyAnimation
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 992 üü° üü° MAJOR

**üéØ Problema:** Rename function "dummy_pyqtSlot" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1542` - Function names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 10min |
| Posizione | Colonne 8-22 |
| Tags | convention, pep |

**üíª Codice attuale:**
```python
     990:     mock_core.pyqtSignal = DummyPyQtSignal
     991: 
 >>> 992:     def dummy_pyqtSlot(*args, **kwargs):
     993:         def decorator(func):
     994:             return func
```

**‚ùì Perch√© √® un problema:**

Shared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.

According to PEP8, function names should be lowercase, with words separated by underscores as necessary to improve readability. This convention is
known as "snake_case." For example: `calculate_area`, `print_hello`, `process_data`

To fix this, respect the naming convention for the function. The default naming convention is snake case, as recommended by PEP8. Other naming
conventions can be defined through the `format` rule parameter.

##### Noncompliant code example

With the default provided regular expression: `^[a-z_][a-z0-9_]*$`

```
def MyFunction(a,b):
 ...
```

##### Compliant solution

```
def my_function(a,b):
 ...
```

**üìù Descrizione:**

This rule raises an issue when a function name doesn‚Äôt respect the naming convention.

### Why is this an issue?

Shared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.

According to PEP8, function names should be lowercase, with words separated by underscores as necessary to improve readability. This convention is
known as "snake_case." For example: `calculate_area`, `print_hello`, `process_data`

To fix this, respect the naming convention for the function. The default naming convention is snake case, as recommended by PEP8. Other naming
conventions can be defined through the `format` rule parameter.

#### Code examples

##### Noncompliant code example

With the default provided regular expression: `^[a-z_][a-z0-9_]*$`

```
def MyFunction(a,b):
 ...
```

##### Compliant solution

```
def my_function(a,b):
 ...
```

### Resources

#### Documentation

 - PEP8 - [Function and Variable Names](https://...

**üìö Risorse:**

#### Documentation

 - PEP8 - [Function and Variable Names](https://peps.python.org/pep-0008/#function-and-variable-names)

---

### Riga 1017 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     1015:             self._started.emit()
     1016: 
 >>> 1017:         def quit(self): pass
     1018:         def wait(self): pass
     1019:         def isRunning(self): return False
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 1018 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     1016: 
     1017:         def quit(self): pass
 >>> 1018:         def wait(self): pass
     1019:         def isRunning(self): return False
     1020:         def run(self): pass
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 1020 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-15 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     1018:         def wait(self): pass
     1019:         def isRunning(self): return False
 >>> 1020:         def run(self): pass
     1021: 
     1022:         @staticmethod
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

## üìÑ `app/core/config.py`
**18 issue(s)** | Effort: 1h 41min

### Riga 38 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 25 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 15min |
| Posizione | Colonne 4-27 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     36:     return base_dir
     37: 
 >>> 38: def migrate_legacy_settings(target_path: Path):
     39:     """
     40:     Checks for settings.json in legacy temporary locations and moves it to the target path.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 46 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "settings.json" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 35-50 |
| Tags | design |

**üíª Codice attuale:**
```python
     44:     if not target_path.exists():
     45:         temp_dir = Path(tempfile.gettempdir())
 >>> 46:         legacy_path_1 = temp_dir / "settings.json"
     47:         legacy_path_2 = temp_dir / "Intelleo" / "settings.json"
     48: 
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 196 üü° üü¢ MINOR

**üéØ Problema:** Rename method "LICENSE_GITHUB_TOKEN" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-28 |
| Tags | convention |

**üíª Codice attuale:**
```python
     194:     # Convenience properties to access mutable settings directly
     195:     @property
 >>> 196:     def LICENSE_GITHUB_TOKEN(self):
     197:         return reveal_string(self._OBFUSCATED_GITHUB_TOKEN)
     198: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 200 üü° üü¢ MINOR

**üéØ Problema:** Rename method "FIRST_RUN_ADMIN_PASSWORD" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-32 |
| Tags | convention |

**üíª Codice attuale:**
```python
     198: 
     199:     @property
 >>> 200:     def FIRST_RUN_ADMIN_PASSWORD(self):
     201:         return self.mutable.get("FIRST_RUN_ADMIN_PASSWORD")
     202: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 204 üü° üü¢ MINOR

**üéØ Problema:** Rename method "GEMINI_API_KEY_ANALYSIS" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-31 |
| Tags | convention |

**üíª Codice attuale:**
```python
     202: 
     203:     @property
 >>> 204:     def GEMINI_API_KEY_ANALYSIS(self):
     205:         obfuscated_key = self.mutable.get("GEMINI_API_KEY_ANALYSIS")
     206:         return reveal_string(obfuscated_key)
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 209 üü° üü¢ MINOR

**üéØ Problema:** Rename method "GEMINI_API_KEY_CHAT" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-27 |
| Tags | convention |

**üíª Codice attuale:**
```python
     207:     
     208:     @property
 >>> 209:     def GEMINI_API_KEY_CHAT(self):
     210:         obfuscated_key = self.mutable.get("GEMINI_API_KEY_CHAT")
     211:         return reveal_string(obfuscated_key)
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 214 üü° üü¢ MINOR

**üéØ Problema:** Rename method "VOICE_ASSISTANT_ENABLED" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-31 |
| Tags | convention |

**üíª Codice attuale:**
```python
     212: 
     213:     @property
 >>> 214:     def VOICE_ASSISTANT_ENABLED(self):
     215:         return self.mutable.get("VOICE_ASSISTANT_ENABLED", True)
     216: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 218 üü° üü¢ MINOR

**üéØ Problema:** Rename method "SMTP_HOST" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | convention |

**üíª Codice attuale:**
```python
     216: 
     217:     @property
 >>> 218:     def SMTP_HOST(self):
     219:         return self.mutable.get("SMTP_HOST")
     220: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 222 üü° üü¢ MINOR

**üéØ Problema:** Rename method "SMTP_PORT" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | convention |

**üíª Codice attuale:**
```python
     220: 
     221:     @property
 >>> 222:     def SMTP_PORT(self):
     223:         return self.mutable.get("SMTP_PORT")
     224: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 226 üü° üü¢ MINOR

**üéØ Problema:** Rename method "SMTP_USER" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | convention |

**üíª Codice attuale:**
```python
     224: 
     225:     @property
 >>> 226:     def SMTP_USER(self):
     227:         return self.mutable.get("SMTP_USER")
     228: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 230 üü° üü¢ MINOR

**üéØ Problema:** Rename method "SMTP_PASSWORD" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | convention |

**üíª Codice attuale:**
```python
     228: 
     229:     @property
 >>> 230:     def SMTP_PASSWORD(self):
     231:         return self.mutable.get("SMTP_PASSWORD")
     232: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 234 üü° üü¢ MINOR

**üéØ Problema:** Rename method "EMAIL_RECIPIENTS_TO" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-27 |
| Tags | convention |

**üíª Codice attuale:**
```python
     232: 
     233:     @property
 >>> 234:     def EMAIL_RECIPIENTS_TO(self):
     235:         return self.mutable.get("EMAIL_RECIPIENTS_TO")
     236: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 238 üü° üü¢ MINOR

**üéØ Problema:** Rename method "EMAIL_RECIPIENTS_CC" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-27 |
| Tags | convention |

**üíª Codice attuale:**
```python
     236: 
     237:     @property
 >>> 238:     def EMAIL_RECIPIENTS_CC(self):
     239:         return self.mutable.get("EMAIL_RECIPIENTS_CC")
     240: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 242 üü° üü¢ MINOR

**üéØ Problema:** Rename method "ALERT_THRESHOLD_DAYS" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-28 |
| Tags | convention |

**üíª Codice attuale:**
```python
     240: 
     241:     @property
 >>> 242:     def ALERT_THRESHOLD_DAYS(self):
     243:         return self.mutable.get("ALERT_THRESHOLD_DAYS")
     244: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 246 üü° üü¢ MINOR

**üéØ Problema:** Rename method "ALERT_THRESHOLD_DAYS_VISITE" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-35 |
| Tags | convention |

**üíª Codice attuale:**
```python
     244: 
     245:     @property
 >>> 246:     def ALERT_THRESHOLD_DAYS_VISITE(self):
     247:         return self.mutable.get("ALERT_THRESHOLD_DAYS_VISITE")
     248: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 250 üü° üü¢ MINOR

**üéØ Problema:** Rename method "DATABASE_PATH" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | convention |

**üíª Codice attuale:**
```python
     248: 
     249:     @property
 >>> 250:     def DATABASE_PATH(self):
     251:         return self.mutable.get("DATABASE_PATH")
     252: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 254 üü° üü¢ MINOR

**üéØ Problema:** Rename method "MAX_UPLOAD_SIZE" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | convention |

**üíª Codice attuale:**
```python
     252: 
     253:     @property
 >>> 254:     def MAX_UPLOAD_SIZE(self):
     255:         return self.mutable.get("MAX_UPLOAD_SIZE", 20 * 1024 * 1024)
     256: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

### Riga 258 üü° üü¢ MINOR

**üéØ Problema:** Rename method "MAX_CSV_SIZE" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S100` - Method names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-20 |
| Tags | convention |

**üíª Codice attuale:**
```python
     256: 
     257:     @property
 >>> 258:     def MAX_CSV_SIZE(self):
     259:         return self.mutable.get("MAX_CSV_SIZE", 5 * 1024 * 1024)
     260: 
```

**‚ùì Perch√© √® un problema:**

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

**üìù Descrizione:**

### Why is this an issue?

Shared naming conventions allow teams to collaborate efficiently.

This rule raises an issue when a method name does not match a provided regular expression.

For example, with the default provided regular expression `^[a-z_][a-z0-9_]*$`, the method:

```
class MyClass:
 def MyMethod(a,b): # Noncompliant
 ...
```

should be renamed to

```
class MyClass:
 def my_method(a,b):
 ...
```

---

## üìÑ `launcher.py`
**15 issue(s)** | Effort: 3h 11min

### Riga 133 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "analytics_enabled".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-25 |
| Tags | unused |

**üíª Codice attuale:**
```python
     131: 
     132:         # Check explicit disable flag (GDPR)
 >>> 133:         analytics_enabled = True
     134: 
     135:         # Configure PostHog Module-Global
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 177 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     175:                 posthog.capture('app_closed', distinct_id=get_machine_id())
     176:                 posthog.flush() # Ensure sent
 >>> 177:             except: pass
     178: 
     179:         atexit.register(track_exit)
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 212 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "database_documenti.db" 4 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 8min |
| Posizione | Colonne 36-59 |
| Tags | design |

**üíª Codice attuale:**
```python
     210:         sys.path.insert(0, lic_dir)
     211: 
 >>> 212:     db_path = os.path.join(EXE_DIR, "database_documenti.db")
     213:     if os.name == 'nt': db_path = db_path.replace('\\', '\\\\')
     214:     os.environ["DATABASE_URL"] = f"sqlite:///{db_path}"
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 230 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     228:                 if s.connect_ex(('127.0.0.1', port)) != 0:
     229:                     return port
 >>> 230:         except:
     231:             continue
     232:     return None
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 249 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 4-10 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     247:         s.close()
     248:         return result
 >>> 249:     except: return False
     250: 
     251: # --- PHASE 0: LICENSE GATEKEEPER ---
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 258 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "pyarmor.rkey" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 49-63 |
| Tags | design |

**üíª Codice attuale:**
```python
     256:     # 1. Check User Data Directory (Preferred)
     257:     user_lic_dir = get_license_dir()
 >>> 258:     if os.path.exists(os.path.join(user_lic_dir, "pyarmor.rkey")) and \
     259:        os.path.exists(os.path.join(user_lic_dir, "config.dat")):
     260:         sys.path.insert(0, user_lic_dir)
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 259 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "config.dat" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 49-61 |
| Tags | design |

**üíª Codice attuale:**
```python
     257:     user_lic_dir = get_license_dir()
     258:     if os.path.exists(os.path.join(user_lic_dir, "pyarmor.rkey")) and \
 >>> 259:        os.path.exists(os.path.join(user_lic_dir, "config.dat")):
     260:         sys.path.insert(0, user_lic_dir)
     261:         return True
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 377 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 51 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 41min |
| Posizione | Colonne 4-31 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     375: 
     376: 
 >>> 377: def post_launch_integrity_check(controller):
     378:     """
     379:     Step 3 (Delayed): Integrity Check and Recovery Dialog.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 434 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "exit_btn".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | unused |

**üíª Codice attuale:**
```python
     432:         browse_btn = msg.addButton("Sfoglia / Ripristina...", QMessageBox.ButtonRole.ActionRole)
     433:         create_btn = msg.addButton("Crea Nuovo Database", QMessageBox.ButtonRole.ActionRole)
 >>> 434:         exit_btn = msg.addButton("Esci", QMessageBox.ButtonRole.RejectRole)
     435: 
     436:         msg.setWindowFlags(msg.windowFlags() | Qt.WindowType.WindowStaysOnTopHint)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 509 üü° üü° MAJOR

**üéØ Problema:** Replace this generic exception class with a more specific one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S112` - "Exception" and "BaseException" should not be raised |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 20min |
| Posizione | Colonne 40-86 |
| Tags | cwe, error-handling |

**üíª Codice attuale:**
```python
     507: 
     508:                 is_intact, int_msg = verify_critical_components()
 >>> 509:                 if not is_intact: raise Exception(f"Integrit√† compromessa: {int_msg}")
     510:             except ImportError: pass
     511: 
```

**‚ùì Perch√© √® un problema:**

Raising instances of [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception) and [`BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException) will have a negative impact on any code trying
to catch these exceptions.

From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.

Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.

For instance, if an exception such as `SystemExit` is caught and not re-raised, it will preve...

**‚úÖ Come risolvere:**

To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:

 - Raise a specific [Built-in exception](https://docs.python.org/3/library/exceptions.html) when one matches. For example
 `TypeError` should be raised when the type of a parameter is not the one expected. 

 - Create a custom exception class deriving from `Exception` or one of its subclasses. 

##### Noncompliant code example

```
def check_value(value):
 if value &lt; 0:
 raise BaseException("Value cannot be negative") # Noncompliant: this will be difficult for consumers to handle
```

##### Compliant solution

```
def check_value(value):
 if value &lt; 0:
 raise ValueError("Value cannot be negative") # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html#BaseException) 

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes)

---

### Riga 517 üü° üü° MAJOR

**üéØ Problema:** Replace this generic exception class with a more specific one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S112` - "Exception" and "BaseException" should not be raised |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 20min |
| Posizione | Colonne 39-61 |
| Tags | cwe, error-handling |

**üíª Codice attuale:**
```python
     515:                 from desktop_app.services.time_service import check_system_clock
     516:                 clock_ok, clock_error = check_system_clock()
 >>> 517:                 if not clock_ok: raise Exception(clock_error)
     518:             except ImportError: pass
     519: 
```

**‚ùì Perch√© √® un problema:**

Raising instances of [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception) and [`BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException) will have a negative impact on any code trying
to catch these exceptions.

From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.

Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.

For instance, if an exception such as `SystemExit` is caught and not re-raised, it will preve...

**‚úÖ Come risolvere:**

To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:

 - Raise a specific [Built-in exception](https://docs.python.org/3/library/exceptions.html) when one matches. For example
 `TypeError` should be raised when the type of a parameter is not the one expected. 

 - Create a custom exception class deriving from `Exception` or one of its subclasses. 

##### Noncompliant code example

```
def check_value(value):
 if value &lt; 0:
 raise BaseException("Value cannot be negative") # Noncompliant: this will be difficult for consumers to handle
```

##### Compliant solution

```
def check_value(value):
 if value &lt; 0:
 raise ValueError("Value cannot be negative") # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html#BaseException) 

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes)

---

### Riga 538 üü° üü° MAJOR

**üéØ Problema:** Replace this generic exception class with a more specific one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S112` - "Exception" and "BaseException" should not be raised |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 20min |
| Posizione | Colonne 22-72 |
| Tags | cwe, error-handling |

**üíª Codice attuale:**
```python
     536: 
     537:             if not ready:
 >>> 538:                 raise Exception("Timeout connessione al server locale.")
     539: 
     540:             # 5. Health Check
```

**‚ùì Perch√© √® un problema:**

Raising instances of [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception) and [`BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException) will have a negative impact on any code trying
to catch these exceptions.

From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.

Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.

For instance, if an exception such as `SystemExit` is caught and not re-raised, it will preve...

**‚úÖ Come risolvere:**

To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:

 - Raise a specific [Built-in exception](https://docs.python.org/3/library/exceptions.html) when one matches. For example
 `TypeError` should be raised when the type of a parameter is not the one expected. 

 - Create a custom exception class deriving from `Exception` or one of its subclasses. 

##### Noncompliant code example

```
def check_value(value):
 if value &lt; 0:
 raise BaseException("Value cannot be negative") # Noncompliant: this will be difficult for consumers to handle
```

##### Compliant solution

```
def check_value(value):
 if value &lt; 0:
 raise ValueError("Value cannot be negative") # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html#BaseException) 

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes)

---

### Riga 546 üü° üü° MAJOR

**üéØ Problema:** Replace this generic exception class with a more specific one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S112` - "Exception" and "BaseException" should not be raised |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 20min |
| Posizione | Colonne 26-85 |
| Tags | cwe, error-handling |

**üíª Codice attuale:**
```python
     544:                 response = requests.get(health_url, timeout=5)
     545:                 if response.status_code != 200:
 >>> 546:                     raise Exception(f"Server Error: {response.json().get('detail')}")
     547:             except Exception as e:
     548:                 raise Exception(f"Health Check Failed: {e}")
```

**‚ùì Perch√© √® un problema:**

Raising instances of [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception) and [`BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException) will have a negative impact on any code trying
to catch these exceptions.

From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.

Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.

For instance, if an exception such as `SystemExit` is caught and not re-raised, it will preve...

**‚úÖ Come risolvere:**

To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:

 - Raise a specific [Built-in exception](https://docs.python.org/3/library/exceptions.html) when one matches. For example
 `TypeError` should be raised when the type of a parameter is not the one expected. 

 - Create a custom exception class deriving from `Exception` or one of its subclasses. 

##### Noncompliant code example

```
def check_value(value):
 if value &lt; 0:
 raise BaseException("Value cannot be negative") # Noncompliant: this will be difficult for consumers to handle
```

##### Compliant solution

```
def check_value(value):
 if value &lt; 0:
 raise ValueError("Value cannot be negative") # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html#BaseException) 

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes)

---

### Riga 548 üü° üü° MAJOR

**üéØ Problema:** Replace this generic exception class with a more specific one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S112` - "Exception" and "BaseException" should not be raised |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 20min |
| Posizione | Colonne 22-60 |
| Tags | cwe, error-handling |

**üíª Codice attuale:**
```python
     546:                     raise Exception(f"Server Error: {response.json().get('detail')}")
     547:             except Exception as e:
 >>> 548:                 raise Exception(f"Health Check Failed: {e}")
     549: 
     550:             # 6. Ready
```

**‚ùì Perch√© √® un problema:**

Raising instances of [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception) and [`BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException) will have a negative impact on any code trying
to catch these exceptions.

From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.

Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.

For instance, if an exception such as `SystemExit` is caught and not re-raised, it will preve...

**‚úÖ Come risolvere:**

To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:

 - Raise a specific [Built-in exception](https://docs.python.org/3/library/exceptions.html) when one matches. For example
 `TypeError` should be raised when the type of a parameter is not the one expected. 

 - Create a custom exception class deriving from `Exception` or one of its subclasses. 

##### Noncompliant code example

```
def check_value(value):
 if value &lt; 0:
 raise BaseException("Value cannot be negative") # Noncompliant: this will be difficult for consumers to handle
```

##### Compliant solution

```
def check_value(value):
 if value &lt; 0:
 raise ValueError("Value cannot be negative") # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html#BaseException) 

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes)

---

### Riga 563 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "unknown" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 10-17 |
| Tags | unused |

**üíª Codice attuale:**
```python
     561:     parser.add_argument("--import-csv", help="Path")
     562:     parser.add_argument("--view", help="View")
 >>> 563:     args, unknown = parser.parse_known_args()
     564: 
     565:     server_port = find_free_port()
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/app/core/test_db_security_integration.py`
**14 issue(s)** | Effort: 1h 10min

### Riga 39 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     37:             if manager.lock_manager:
     38:                 manager.release_lock()
 >>> 39:         except:
     40:             pass
     41: 
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 50 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "tmp_path" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-12 |
| Tags | unused |

**üíª Codice attuale:**
```python
     48: 
     49: def test_full_encryption_cycle(secure_db_env):
 >>> 50:     tmp_path, manager, db_name = secure_db_env
     51: 
     52:     # 1. Initialize DB (In Memory)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 50 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "db_name" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 23-30 |
| Tags | unused |

**üíª Codice attuale:**
```python
     48: 
     49: def test_full_encryption_cycle(secure_db_env):
 >>> 50:     tmp_path, manager, db_name = secure_db_env
     51: 
     52:     # 1. Initialize DB (In Memory)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 92 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "tmp_path" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-12 |
| Tags | unused |

**üíª Codice attuale:**
```python
     90: 
     91: def test_verify_integrity(secure_db_env):
 >>> 92:     tmp_path, manager, db_name = secure_db_env
     93:     
     94:     # Create valid encrypted DB
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 92 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "db_name" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 23-30 |
| Tags | unused |

**üíª Codice attuale:**
```python
     90: 
     91: def test_verify_integrity(secure_db_env):
 >>> 92:     tmp_path, manager, db_name = secure_db_env
     93:     
     94:     # Create valid encrypted DB
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 112 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "tmp_path" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-12 |
| Tags | unused |

**üíª Codice attuale:**
```python
     110: 
     111: def test_lock_acquisition_and_release(secure_db_env):
 >>> 112:     tmp_path, manager, db_name = secure_db_env
     113:     
     114:     # Acquire
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 112 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "db_name" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 23-30 |
| Tags | unused |

**üíª Codice attuale:**
```python
     110: 
     111: def test_lock_acquisition_and_release(secure_db_env):
 >>> 112:     tmp_path, manager, db_name = secure_db_env
     113:     
     114:     # Acquire
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 115 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "info" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 13-17 |
| Tags | unused |

**üíª Codice attuale:**
```python
     113:     
     114:     # Acquire
 >>> 115:     success, info = manager.acquire_session_lock({"user": "admin", "pid": 1234})
     116:     assert success is True
     117:     assert manager.lock_path.exists()
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 143 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "tmp_path" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-12 |
| Tags | unused |

**üíª Codice attuale:**
```python
     141: 
     142: def test_save_fails_if_read_only(secure_db_env):
 >>> 143:     tmp_path, manager, db_name = secure_db_env
     144:     
     145:     # Initialize connection so save_to_disk has something to save
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 143 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "db_name" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 23-30 |
| Tags | unused |

**üíª Codice attuale:**
```python
     141: 
     142: def test_save_fails_if_read_only(secure_db_env):
 >>> 143:     tmp_path, manager, db_name = secure_db_env
     144:     
     145:     # Initialize connection so save_to_disk has something to save
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 156 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "db_name" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 23-30 |
| Tags | unused |

**üíª Codice attuale:**
```python
     154: 
     155: def test_stale_lock_recovery(secure_db_env):
 >>> 156:     tmp_path, manager, db_name = secure_db_env
     157:     
     158:     # 1. Create a fake lock file from a "dead" process
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 156 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "tmp_path" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-12 |
| Tags | unused |

**üíª Codice attuale:**
```python
     154: 
     155: def test_stale_lock_recovery(secure_db_env):
 >>> 156:     tmp_path, manager, db_name = secure_db_env
     157:     
     158:     # 1. Create a fake lock file from a "dead" process
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 174 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "db_name" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 23-30 |
| Tags | unused |

**üíª Codice attuale:**
```python
     172: 
     173: def test_stale_lock_respects_living_process(secure_db_env):
 >>> 174:     tmp_path, manager, db_name = secure_db_env
     175:     
     176:     # 1. Create lock for CURRENT process (alive)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 174 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "tmp_path" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-12 |
| Tags | unused |

**üíª Codice attuale:**
```python
     172: 
     173: def test_stale_lock_respects_living_process(secure_db_env):
 >>> 174:     tmp_path, manager, db_name = secure_db_env
     175:     
     176:     # 1. Create lock for CURRENT process (alive)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `desktop_app/main_window_ui.py`
**14 issue(s)** | Effort: 1h 28min

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 13-19 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 18-24 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 156 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 23 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 13min |
| Posizione | Colonne 8-16 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     154:     logout_requested = pyqtSignal()
     155: 
 >>> 156:     def __init__(self, parent=None):
     157:         super().__init__(parent)
     158:         self.setFixedWidth(260)
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 261 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Scadenza Licenza" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 43-61 |
| Tags | design |

**üíª Codice attuale:**
```python
     259:                   self.license_layout.addWidget(l1)
     260: 
 >>> 261:              expiry_str = license_data.get("Scadenza Licenza", "")
     262:              if expiry_str:
     263:                   l2 = QLabel(f"Scadenza Licenza:\n{expiry_str}")
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 619 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 24 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 14min |
| Posizione | Colonne 8-35 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     617:         self._connect_cross_view_signals()
     618: 
 >>> 619:     def _connect_cross_view_signals(self):
     620:         # Refresh logic across views
     621:         imp = self.views.get("import")
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `desktop_app/components/neural_3d.py`
**12 issue(s)** | Effort: 1h 2min

### Riga 15 üü° üü° MAJOR

**üéØ Problema:** Use a "numpy.random.Generator" here instead of this legacy function.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6711` - numpy.random.Generator should be preferred to numpy.random.RandomState |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-37 |
| Tags | data-science, numpy |

**üíª Codice attuale:**
```python
     13:         # Position X, Y, Z centered at 0,0,0
     14:         # Range approx -800 to 800
 >>> 15:         self.points = (np.random.rand(num_nodes, 3) - 0.5) * 1600
     16: 
     17:         # Velocity vector (slow drift)
```

**‚ùì Perch√© √® un problema:**

Using a predictable seed is a common best practice when using NumPy to create reproducible results. To that end, using
`np.random.seed(number)` to set the seed of the global `numpy.random.RandomState` has been the privileged solution for a long
time.

`numpy.random.RandomState` and its associated methods rely on a global state, which may be problematic when threads or other forms of
concurrency are involved. The global state may be altered and the global seed may be reset at various points in the program (for instance, through an
imported package or script), which would lead to irreproducible results.

Instead, the preferred best practice to generate reproducible pseudorandom numbers is to instantiate a `numpy.random.Generator` object
with a seed and reuse it in different parts of the code. This avoids the reliance on a global state. Whenever a new seed is needed, a new generator
may be created instead of mutating a global state.

Below is the list of legacy functions and their alterna...

**‚úÖ Come risolvere:**

To fix this issue, replace usages of `numpy.random.RandomState` to `numpy.random.Generator`.

##### Noncompliant code example

```
import numpy as np
np.random.seed(42)
x = np.random.randn() # Noncompliant: this relies on numpy.random.RandomState, which is deprecated
```

##### Compliant solution

```
import numpy as np
generator = np.random.default_rng(42)
x = generator.standard_normal()
```

**üìö Risorse:**

#### Documentation

 - NumPy Documentation - [Random Generator](https://numpy.org/doc/stable/reference/random/generator.html#random-generator) 

 - NumPy Documentation - [Legacy Random Generation](https://numpy.org/doc/stable/reference/random/legacy.html#legacy-random-generation)
 

 - NumPy Documentation - [NEP19 RNG Policy](https://numpy.org/neps/nep-0019-rng-policy.html)

---

### Riga 18 üü° üü° MAJOR

**üéØ Problema:** Use a "numpy.random.Generator" here instead of this legacy function.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6711` - numpy.random.Generator should be preferred to numpy.random.RandomState |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 27-41 |
| Tags | data-science, numpy |

**üíª Codice attuale:**
```python
     16: 
     17:         # Velocity vector (slow drift)
 >>> 18:         self.velocities = (np.random.rand(num_nodes, 3) - 0.5) * 1.5
     19: 
     20:         # Phase for "breathing" effect (0 to 2pi)
```

**‚ùì Perch√© √® un problema:**

Using a predictable seed is a common best practice when using NumPy to create reproducible results. To that end, using
`np.random.seed(number)` to set the seed of the global `numpy.random.RandomState` has been the privileged solution for a long
time.

`numpy.random.RandomState` and its associated methods rely on a global state, which may be problematic when threads or other forms of
concurrency are involved. The global state may be altered and the global seed may be reset at various points in the program (for instance, through an
imported package or script), which would lead to irreproducible results.

Instead, the preferred best practice to generate reproducible pseudorandom numbers is to instantiate a `numpy.random.Generator` object
with a seed and reuse it in different parts of the code. This avoids the reliance on a global state. Whenever a new seed is needed, a new generator
may be created instead of mutating a global state.

Below is the list of legacy functions and their alterna...

**‚úÖ Come risolvere:**

To fix this issue, replace usages of `numpy.random.RandomState` to `numpy.random.Generator`.

##### Noncompliant code example

```
import numpy as np
np.random.seed(42)
x = np.random.randn() # Noncompliant: this relies on numpy.random.RandomState, which is deprecated
```

##### Compliant solution

```
import numpy as np
generator = np.random.default_rng(42)
x = generator.standard_normal()
```

**üìö Risorse:**

#### Documentation

 - NumPy Documentation - [Random Generator](https://numpy.org/doc/stable/reference/random/generator.html#random-generator) 

 - NumPy Documentation - [Legacy Random Generation](https://numpy.org/doc/stable/reference/random/legacy.html#legacy-random-generation)
 

 - NumPy Documentation - [NEP19 RNG Policy](https://numpy.org/neps/nep-0019-rng-policy.html)

---

### Riga 21 üü° üü° MAJOR

**üéØ Problema:** Use a "numpy.random.Generator" here instead of this legacy function.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6711` - numpy.random.Generator should be preferred to numpy.random.RandomState |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 22-36 |
| Tags | data-science, numpy |

**üíª Codice attuale:**
```python
     19: 
     20:         # Phase for "breathing" effect (0 to 2pi)
 >>> 21:         self.phases = np.random.rand(num_nodes) * 2 * math.pi
     22:         self.phase_speeds = np.random.rand(num_nodes) * 0.05 + 0.02
     23: 
```

**‚ùì Perch√© √® un problema:**

Using a predictable seed is a common best practice when using NumPy to create reproducible results. To that end, using
`np.random.seed(number)` to set the seed of the global `numpy.random.RandomState` has been the privileged solution for a long
time.

`numpy.random.RandomState` and its associated methods rely on a global state, which may be problematic when threads or other forms of
concurrency are involved. The global state may be altered and the global seed may be reset at various points in the program (for instance, through an
imported package or script), which would lead to irreproducible results.

Instead, the preferred best practice to generate reproducible pseudorandom numbers is to instantiate a `numpy.random.Generator` object
with a seed and reuse it in different parts of the code. This avoids the reliance on a global state. Whenever a new seed is needed, a new generator
may be created instead of mutating a global state.

Below is the list of legacy functions and their alterna...

**‚úÖ Come risolvere:**

To fix this issue, replace usages of `numpy.random.RandomState` to `numpy.random.Generator`.

##### Noncompliant code example

```
import numpy as np
np.random.seed(42)
x = np.random.randn() # Noncompliant: this relies on numpy.random.RandomState, which is deprecated
```

##### Compliant solution

```
import numpy as np
generator = np.random.default_rng(42)
x = generator.standard_normal()
```

**üìö Risorse:**

#### Documentation

 - NumPy Documentation - [Random Generator](https://numpy.org/doc/stable/reference/random/generator.html#random-generator) 

 - NumPy Documentation - [Legacy Random Generation](https://numpy.org/doc/stable/reference/random/legacy.html#legacy-random-generation)
 

 - NumPy Documentation - [NEP19 RNG Policy](https://numpy.org/neps/nep-0019-rng-policy.html)

---

### Riga 22 üü° üü° MAJOR

**üéØ Problema:** Use a "numpy.random.Generator" here instead of this legacy function.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6711` - numpy.random.Generator should be preferred to numpy.random.RandomState |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 28-42 |
| Tags | data-science, numpy |

**üíª Codice attuale:**
```python
     20:         # Phase for "breathing" effect (0 to 2pi)
     21:         self.phases = np.random.rand(num_nodes) * 2 * math.pi
 >>> 22:         self.phase_speeds = np.random.rand(num_nodes) * 0.05 + 0.02
     23: 
     24:         # Current Rotation (Euler angles)
```

**‚ùì Perch√© √® un problema:**

Using a predictable seed is a common best practice when using NumPy to create reproducible results. To that end, using
`np.random.seed(number)` to set the seed of the global `numpy.random.RandomState` has been the privileged solution for a long
time.

`numpy.random.RandomState` and its associated methods rely on a global state, which may be problematic when threads or other forms of
concurrency are involved. The global state may be altered and the global seed may be reset at various points in the program (for instance, through an
imported package or script), which would lead to irreproducible results.

Instead, the preferred best practice to generate reproducible pseudorandom numbers is to instantiate a `numpy.random.Generator` object
with a seed and reuse it in different parts of the code. This avoids the reliance on a global state. Whenever a new seed is needed, a new generator
may be created instead of mutating a global state.

Below is the list of legacy functions and their alterna...

**‚úÖ Come risolvere:**

To fix this issue, replace usages of `numpy.random.RandomState` to `numpy.random.Generator`.

##### Noncompliant code example

```
import numpy as np
np.random.seed(42)
x = np.random.randn() # Noncompliant: this relies on numpy.random.RandomState, which is deprecated
```

##### Compliant solution

```
import numpy as np
generator = np.random.default_rng(42)
x = generator.standard_normal()
```

**üìö Risorse:**

#### Documentation

 - NumPy Documentation - [Random Generator](https://numpy.org/doc/stable/reference/random/generator.html#random-generator) 

 - NumPy Documentation - [Legacy Random Generation](https://numpy.org/doc/stable/reference/random/legacy.html#legacy-random-generation)
 

 - NumPy Documentation - [NEP19 RNG Policy](https://numpy.org/neps/nep-0019-rng-policy.html)

---

### Riga 80 üü° üü° MAJOR

**üéØ Problema:** Use a "numpy.random.Generator" here instead of this legacy function.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6711` - numpy.random.Generator should be preferred to numpy.random.RandomState |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 23-37 |
| Tags | data-science, numpy |

**üíª Codice attuale:**
```python
     78:         self.warp_speed = 0.0
     79:         # Reset positions to ensure we aren't stuck in a "tunnel"
 >>> 80:         self.points = (np.random.rand(self.num_nodes, 3) - 0.5) * 1600
     81:         self.velocities = (np.random.rand(self.num_nodes, 3) - 0.5) * 1.5
     82: 
```

**‚ùì Perch√© √® un problema:**

Using a predictable seed is a common best practice when using NumPy to create reproducible results. To that end, using
`np.random.seed(number)` to set the seed of the global `numpy.random.RandomState` has been the privileged solution for a long
time.

`numpy.random.RandomState` and its associated methods rely on a global state, which may be problematic when threads or other forms of
concurrency are involved. The global state may be altered and the global seed may be reset at various points in the program (for instance, through an
imported package or script), which would lead to irreproducible results.

Instead, the preferred best practice to generate reproducible pseudorandom numbers is to instantiate a `numpy.random.Generator` object
with a seed and reuse it in different parts of the code. This avoids the reliance on a global state. Whenever a new seed is needed, a new generator
may be created instead of mutating a global state.

Below is the list of legacy functions and their alterna...

**‚úÖ Come risolvere:**

To fix this issue, replace usages of `numpy.random.RandomState` to `numpy.random.Generator`.

##### Noncompliant code example

```
import numpy as np
np.random.seed(42)
x = np.random.randn() # Noncompliant: this relies on numpy.random.RandomState, which is deprecated
```

##### Compliant solution

```
import numpy as np
generator = np.random.default_rng(42)
x = generator.standard_normal()
```

**üìö Risorse:**

#### Documentation

 - NumPy Documentation - [Random Generator](https://numpy.org/doc/stable/reference/random/generator.html#random-generator) 

 - NumPy Documentation - [Legacy Random Generation](https://numpy.org/doc/stable/reference/random/legacy.html#legacy-random-generation)
 

 - NumPy Documentation - [NEP19 RNG Policy](https://numpy.org/neps/nep-0019-rng-policy.html)

---

### Riga 81 üü° üü° MAJOR

**üéØ Problema:** Use a "numpy.random.Generator" here instead of this legacy function.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6711` - numpy.random.Generator should be preferred to numpy.random.RandomState |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 27-41 |
| Tags | data-science, numpy |

**üíª Codice attuale:**
```python
     79:         # Reset positions to ensure we aren't stuck in a "tunnel"
     80:         self.points = (np.random.rand(self.num_nodes, 3) - 0.5) * 1600
 >>> 81:         self.velocities = (np.random.rand(self.num_nodes, 3) - 0.5) * 1.5
     82: 
     83:     def start_warp(self):
```

**‚ùì Perch√© √® un problema:**

Using a predictable seed is a common best practice when using NumPy to create reproducible results. To that end, using
`np.random.seed(number)` to set the seed of the global `numpy.random.RandomState` has been the privileged solution for a long
time.

`numpy.random.RandomState` and its associated methods rely on a global state, which may be problematic when threads or other forms of
concurrency are involved. The global state may be altered and the global seed may be reset at various points in the program (for instance, through an
imported package or script), which would lead to irreproducible results.

Instead, the preferred best practice to generate reproducible pseudorandom numbers is to instantiate a `numpy.random.Generator` object
with a seed and reuse it in different parts of the code. This avoids the reliance on a global state. Whenever a new seed is needed, a new generator
may be created instead of mutating a global state.

Below is the list of legacy functions and their alterna...

**‚úÖ Come risolvere:**

To fix this issue, replace usages of `numpy.random.RandomState` to `numpy.random.Generator`.

##### Noncompliant code example

```
import numpy as np
np.random.seed(42)
x = np.random.randn() # Noncompliant: this relies on numpy.random.RandomState, which is deprecated
```

##### Compliant solution

```
import numpy as np
generator = np.random.default_rng(42)
x = generator.standard_normal()
```

**üìö Risorse:**

#### Documentation

 - NumPy Documentation - [Random Generator](https://numpy.org/doc/stable/reference/random/generator.html#random-generator) 

 - NumPy Documentation - [Legacy Random Generation](https://numpy.org/doc/stable/reference/random/legacy.html#legacy-random-generation)
 

 - NumPy Documentation - [NEP19 RNG Policy](https://numpy.org/neps/nep-0019-rng-policy.html)

---

### Riga 112 üü° üü° MAJOR

**üéØ Problema:** Use a "numpy.random.Generator" here instead of this legacy function.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6711` - numpy.random.Generator should be preferred to numpy.random.RandomState |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 48-62 |
| Tags | data-science, numpy |

**üíª Codice attuale:**
```python
     110:                  self.points[mask_behind, 2] = 1600
     111:                  # Randomize X/Y for infinite tunnel effect
 >>> 112:                  self.points[mask_behind, 0] = (np.random.rand(respawn_count) - 0.5) * 2000
     113:                  self.points[mask_behind, 1] = (np.random.rand(respawn_count) - 0.5) * 2000
     114: 
```

**‚ùì Perch√© √® un problema:**

Using a predictable seed is a common best practice when using NumPy to create reproducible results. To that end, using
`np.random.seed(number)` to set the seed of the global `numpy.random.RandomState` has been the privileged solution for a long
time.

`numpy.random.RandomState` and its associated methods rely on a global state, which may be problematic when threads or other forms of
concurrency are involved. The global state may be altered and the global seed may be reset at various points in the program (for instance, through an
imported package or script), which would lead to irreproducible results.

Instead, the preferred best practice to generate reproducible pseudorandom numbers is to instantiate a `numpy.random.Generator` object
with a seed and reuse it in different parts of the code. This avoids the reliance on a global state. Whenever a new seed is needed, a new generator
may be created instead of mutating a global state.

Below is the list of legacy functions and their alterna...

**‚úÖ Come risolvere:**

To fix this issue, replace usages of `numpy.random.RandomState` to `numpy.random.Generator`.

##### Noncompliant code example

```
import numpy as np
np.random.seed(42)
x = np.random.randn() # Noncompliant: this relies on numpy.random.RandomState, which is deprecated
```

##### Compliant solution

```
import numpy as np
generator = np.random.default_rng(42)
x = generator.standard_normal()
```

**üìö Risorse:**

#### Documentation

 - NumPy Documentation - [Random Generator](https://numpy.org/doc/stable/reference/random/generator.html#random-generator) 

 - NumPy Documentation - [Legacy Random Generation](https://numpy.org/doc/stable/reference/random/legacy.html#legacy-random-generation)
 

 - NumPy Documentation - [NEP19 RNG Policy](https://numpy.org/neps/nep-0019-rng-policy.html)

---

### Riga 113 üü° üü° MAJOR

**üéØ Problema:** Use a "numpy.random.Generator" here instead of this legacy function.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6711` - numpy.random.Generator should be preferred to numpy.random.RandomState |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 48-62 |
| Tags | data-science, numpy |

**üíª Codice attuale:**
```python
     111:                  # Randomize X/Y for infinite tunnel effect
     112:                  self.points[mask_behind, 0] = (np.random.rand(respawn_count) - 0.5) * 2000
 >>> 113:                  self.points[mask_behind, 1] = (np.random.rand(respawn_count) - 0.5) * 2000
     114: 
     115:              # Also slightly drift rotation to center
```

**‚ùì Perch√© √® un problema:**

Using a predictable seed is a common best practice when using NumPy to create reproducible results. To that end, using
`np.random.seed(number)` to set the seed of the global `numpy.random.RandomState` has been the privileged solution for a long
time.

`numpy.random.RandomState` and its associated methods rely on a global state, which may be problematic when threads or other forms of
concurrency are involved. The global state may be altered and the global seed may be reset at various points in the program (for instance, through an
imported package or script), which would lead to irreproducible results.

Instead, the preferred best practice to generate reproducible pseudorandom numbers is to instantiate a `numpy.random.Generator` object
with a seed and reuse it in different parts of the code. This avoids the reliance on a global state. Whenever a new seed is needed, a new generator
may be created instead of mutating a global state.

Below is the list of legacy functions and their alterna...

**‚úÖ Come risolvere:**

To fix this issue, replace usages of `numpy.random.RandomState` to `numpy.random.Generator`.

##### Noncompliant code example

```
import numpy as np
np.random.seed(42)
x = np.random.randn() # Noncompliant: this relies on numpy.random.RandomState, which is deprecated
```

##### Compliant solution

```
import numpy as np
generator = np.random.default_rng(42)
x = generator.standard_normal()
```

**üìö Risorse:**

#### Documentation

 - NumPy Documentation - [Random Generator](https://numpy.org/doc/stable/reference/random/generator.html#random-generator) 

 - NumPy Documentation - [Legacy Random Generation](https://numpy.org/doc/stable/reference/random/legacy.html#legacy-random-generation)
 

 - NumPy Documentation - [NEP19 RNG Policy](https://numpy.org/neps/nep-0019-rng-policy.html)

---

### Riga 151 üü° üü° MAJOR

**üéØ Problema:** Remove this commented out code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S125` - Sections of code should not be commented out |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 25-44 |
| Tags | unused |

**üíª Codice attuale:**
```python
     149:         active_pulses = []
     150:         for p in self.pulses:
 >>> 151:             p[2] += p[3] # Progress += Speed
     152:             if p[2] &lt; 1.0:
     153:                 active_pulses.append(p)
```

**‚ùì Perch√© √® un problema:**

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

**üìù Descrizione:**

### Why is this an issue?

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

---

### Riga 166 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 17 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 7min |
| Posizione | Colonne 8-26 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     164: 
     165: 
 >>> 166:     def project_and_render(self, painter, width, height):
     167:         """
     168:         Projects 3D points to 2D and renders everything.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 207 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "coords_2d".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-17 |
| Tags | unused |

**üíª Codice attuale:**
```python
     205:         # Store 2D coords for connection drawing
     206:         # Shape (N, 2)
 >>> 207:         coords_2d = np.column_stack((x_2d, y_2d))
     208: 
     209:         # --- 3. Draw Connections &amp; Pulses ---
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 244 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "pulse_color".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-19 |
| Tags | unused |

**üíª Codice attuale:**
```python
     242:         # Draw Pulses
     243:         painter.setPen(Qt.PenStyle.NoPen) # No outline
 >>> 244:         pulse_color = QColor(255, 255, 255) # White core
     245: 
     246:         for p in self.pulses:
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `desktop_app/views/scadenzario_view.py`
**10 issue(s)** | Effort: 1h 2min

### Riga 199 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "dd/MM/yyyy" 6 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 12min |
| Posizione | Colonne 55-67 |
| Tags | design |

**üíª Codice attuale:**
```python
     197:                 date_str = item.get('data_scadenza')
     198:                 if date_str:
 >>> 199:                     qdate = QDate.fromString(date_str, "dd/MM/yyyy")
     200:                     # Rilassiamo il controllo per permettere ai dati di test di passare se necessario,
     201:                     # ma manteniamo la logica principale. Se qdate non √® valido, non entra.
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 216 üü° üü¢ MINOR

**üéØ Problema:** Remove this redundant call.

| Campo | Valore |
|-------|--------|
| Regola | `python:S7508` - Redundant collection functions should be avoided |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 35-39 |

**üíª Codice attuale:**
```python
     214:     def _assign_category_colors(self):
     215:         self.category_colors = {}
 >>> 216:         unique_categories = sorted(list(set(cert['categoria'] for cert in self.certificates)))
     217:         for i, category in enumerate(unique_categories):
     218:             self.category_colors[category] = self.color_palette[i % len(self.color_palette)]
```

**‚ùì Perch√© √® un problema:**

Python‚Äôs built-in functions for processing iterables such as `list()`, `tuple()`, `set()`, `sorted()`,
and `reversed()` are designed to accept any iterable as input. When these functions are unnecessarily nested within each other, it creates
redundant operations that add unnecessary computational overhead by creating intermediate data structures, decrease code readability and make the
intention less clear, and waste memory by duplicating data structures temporarily.

**‚úÖ Come risolvere:**

When the outer function is given a collection but could have been given an iterable, the unnecessary conversion should be removed. For example, in
`sorted(list(iterable))`, the outer `sorted()` function can accept an iterable directly, so the inner `list()` call
is redundant and should be removed.

When the function `sorted()` is wrapped with `list()`, remove this conversion operation, since `sorted()` already
returns a list.

##### Noncompliant code example

```
iterable = (3, 1, 4, 1)

sorted_of_list = list(sorted(iterable)) # Noncompliant
```

##### Compliant solution

```
iterable = (3, 1, 4, 1)

sorted_of_list = sorted(iterable)
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [list](https://docs.python.org/3/library/stdtypes.html#list) 

 - Python Documentation - [tuple](https://docs.python.org/3/library/stdtypes.html#tuple) 

 - Python Documentation - [set](https://docs.python.org/3/library/stdtypes.html#set) 

 - Python Documentation - [sorted](https://docs.python.org/3/library/functions.html#sorted) 

 - Python Documentation - [reversed](https://docs.python.org/3/library/functions.html#reversed)

---

### Riga 216 üü° üü¢ MINOR

**üéØ Problema:** Replace set constructor call with a set comprehension.

| Campo | Valore |
|-------|--------|
| Regola | `python:S7494` - Comprehensions should be used instead of constructors around generator expressions |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 40-43 |

**üíª Codice attuale:**
```python
     214:     def _assign_category_colors(self):
     215:         self.category_colors = {}
 >>> 216:         unique_categories = sorted(list(set(cert['categoria'] for cert in self.certificates)))
     217:         for i, category in enumerate(unique_categories):
     218:             self.category_colors[category] = self.color_palette[i % len(self.color_palette)]
```

**‚ùì Perch√© √® un problema:**

Using `list()`, `set()`, or `dict()` around a generator expression is redundant when a corresponding comprehension
can directly express the same operation. Comprehensions are clearer, more concise, and often more readable than the equivalent constructor/generator
expression combination.

This principle applies to all three built-in collection types: `list`, `set`, and `dict`:

 - Use `[f(x) for x in foo]` instead of `list(f(x) for x in foo)` 

 - Use `{f(x) for x in foo}` instead of `set(f(x) for x in foo)` 

 - Use `{k: v for k, v in items}` instead of `dict((k, v) for k, v in items)` 

#### Exceptions

If the generator expression doesn‚Äôt filter or modify the collection, the rule does not raise. For example, `list(x for x in foo)` is
simply copying the iterable `foo` into a list, which is equivalent to `list(foo)` and covered by a different rule.

**‚úÖ Come risolvere:**

Replace the collection constructor with the appropriate comprehension syntax.

##### Noncompliant code example

```
def f(x):
 return x * 2

list(f(x) for x in range(5)) # Noncompliant
```

##### Compliant solution

```
def f(x):
 return x * 2

[f(x) for x in range(5)] # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [List Comprehensions](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) 

 - Python Documentation - [Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) 

 - Python Documentation - [Sets](https://docs.python.org/3/tutorial/datastructures.html#sets)

---

### Riga 232 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "IN SCADENZA" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 73-86 |
| Tags | design |

**üíª Codice attuale:**
```python
     230:                 parsed_date = QDate.fromString(item.get('data_scadenza', ''), "dd/MM/yyyy")
     231:             
 >>> 232:             status = "SCADUTI" if QDate.currentDate() &gt; parsed_date else "IN SCADENZA"
     233:             data_by_category[item['categoria']][status].append(item)
     234: 
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 248 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 23 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 13min |
| Posizione | Colonne 8-26 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     246:         self.employee_tree.setUpdatesEnabled(True)
     247: 
 >>> 248:     def redraw_gantt_scene(self):
     249:         # Bug 5 Fix: Disable updates for smooth rendering
     250:         self.gantt_view.setUpdatesEnabled(False)
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 381 üü° üü¢ MINOR

**üéØ Problema:** Remove this redundant call.

| Campo | Valore |
|-------|--------|
| Regola | `python:S7508` - Redundant collection functions should be avoided |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 36-40 |

**üíª Codice attuale:**
```python
     379:             if item.widget(): item.widget().deleteLater()
     380: 
 >>> 381:         visible_categories = sorted(list(set(cert['categoria'] for cert in visible_certs)))
     382:         for category in visible_categories:
     383:             color = self.category_colors.get(category)
```

**‚ùì Perch√© √® un problema:**

Python‚Äôs built-in functions for processing iterables such as `list()`, `tuple()`, `set()`, `sorted()`,
and `reversed()` are designed to accept any iterable as input. When these functions are unnecessarily nested within each other, it creates
redundant operations that add unnecessary computational overhead by creating intermediate data structures, decrease code readability and make the
intention less clear, and waste memory by duplicating data structures temporarily.

**‚úÖ Come risolvere:**

When the outer function is given a collection but could have been given an iterable, the unnecessary conversion should be removed. For example, in
`sorted(list(iterable))`, the outer `sorted()` function can accept an iterable directly, so the inner `list()` call
is redundant and should be removed.

When the function `sorted()` is wrapped with `list()`, remove this conversion operation, since `sorted()` already
returns a list.

##### Noncompliant code example

```
iterable = (3, 1, 4, 1)

sorted_of_list = list(sorted(iterable)) # Noncompliant
```

##### Compliant solution

```
iterable = (3, 1, 4, 1)

sorted_of_list = sorted(iterable)
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [list](https://docs.python.org/3/library/stdtypes.html#list) 

 - Python Documentation - [tuple](https://docs.python.org/3/library/stdtypes.html#tuple) 

 - Python Documentation - [set](https://docs.python.org/3/library/stdtypes.html#set) 

 - Python Documentation - [sorted](https://docs.python.org/3/library/functions.html#sorted) 

 - Python Documentation - [reversed](https://docs.python.org/3/library/functions.html#reversed)

---

### Riga 381 üü° üü¢ MINOR

**üéØ Problema:** Replace set constructor call with a set comprehension.

| Campo | Valore |
|-------|--------|
| Regola | `python:S7494` - Comprehensions should be used instead of constructors around generator expressions |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 41-44 |

**üíª Codice attuale:**
```python
     379:             if item.widget(): item.widget().deleteLater()
     380: 
 >>> 381:         visible_categories = sorted(list(set(cert['categoria'] for cert in visible_certs)))
     382:         for category in visible_categories:
     383:             color = self.category_colors.get(category)
```

**‚ùì Perch√© √® un problema:**

Using `list()`, `set()`, or `dict()` around a generator expression is redundant when a corresponding comprehension
can directly express the same operation. Comprehensions are clearer, more concise, and often more readable than the equivalent constructor/generator
expression combination.

This principle applies to all three built-in collection types: `list`, `set`, and `dict`:

 - Use `[f(x) for x in foo]` instead of `list(f(x) for x in foo)` 

 - Use `{f(x) for x in foo}` instead of `set(f(x) for x in foo)` 

 - Use `{k: v for k, v in items}` instead of `dict((k, v) for k, v in items)` 

#### Exceptions

If the generator expression doesn‚Äôt filter or modify the collection, the rule does not raise. For example, `list(x for x in foo)` is
simply copying the iterable `foo` into a list, which is equivalent to `list(foo)` and covered by a different rule.

**‚úÖ Come risolvere:**

Replace the collection constructor with the appropriate comprehension syntax.

##### Noncompliant code example

```
def f(x):
 return x * 2

list(f(x) for x in range(5)) # Noncompliant
```

##### Compliant solution

```
def f(x):
 return x * 2

[f(x) for x in range(5)] # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [List Comprehensions](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) 

 - Python Documentation - [Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) 

 - Python Documentation - [Sets](https://docs.python.org/3/tutorial/datastructures.html#sets)

---

### Riga 465 üü° üü° MAJOR

**üéØ Problema:** Add replacement fields or use a normal string instead of an f-string.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3457` - String formatting should be used correctly |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 62-95 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     463:                 with open(path, 'wb') as f:
     464:                     f.write(response.content)
 >>> 465:                 ToastManager.success("Esportazione Riuscita", f"Report esportato con successo.", self.window())
     466:             except Exception as e:
     467:                 CustomMessageDialog.show_error(self, "Errore", f"Impossibile salvare il file: {e}")
```

**‚ùì Perch√© √® un problema:**

A format string is a string that contains placeholders, usually represented by special characters such as "%s" or "{}", depending on the technology
in use. These placeholders are replaced by values when the string is printed or logged. Thus, it is required that a string is valid and arguments
match replacement fields in this string.

This applies to [the % operator](https://docs.python.org/3/tutorial/inputoutput.html#old-string-formatting), the [str.format](https://docs.python.org/3/tutorial/inputoutput.html#the-string-format-method) method, and loggers from the [logging](https://docs.python.org/3/library/logging.html) module. Internally, the latter use the `%-formatting`. The only
difference is that they will log an error instead of raising an exception when the provided arguments are invalid.

Formatted string literals (also called "f-strings"; available since Python 3.6) are generally simpler to use, and any syntax mistake will cause a
failure at compile time. However, it is easy to...

**‚úÖ Come risolvere:**

A `printf-`-style format string is a string that contains placeholders, which are replaced by values when the string is printed or
logged. Mismatch in the format specifiers and the arguments provided can lead to incorrect strings being created.

To avoid issues, a developer should ensure that the provided arguments match format specifiers.

##### Noncompliant code example

```
"Error %(message)s" % {"message": "something failed", "extra": "some dead code"} # Noncompliant. Remove the unused argument "extra" or add a replacement field.

"Error: User {} has not been able to access []".format("Alice", "MyFile") # Noncompliant. Remove 1 unexpected argument or add a replacement field.

user = "Alice"
resource = "MyFile"
message = f"Error: User [user] has not been able to access [resource]" # Noncompliant. Add replacement fields or use a normal string instead of an f-string.

import logging
logging.error("Error: User %s has not been able to access %s", "Alice") # Noncompliant. Add 1 missing argument.
```

##### Compliant solution

```
"Error %(message)s" % {"message": "something failed"}

"Error: User {} has not been able to access {}".format("Alice", "MyFile")

user = "Alice"
resource = "MyFile"
message = f"Error: User {user} has not been able to access {resource}"

import logging
logging.error("Error: User %s has not been able to access %s", "Alice", "MyFile")
```

**üìö Risorse:**

- [Python documentation - Format String Syntax](https://docs.python.org/3/library/string.html#format-string-syntax) 

 - Python documentation - printf-style String
 Formatting 

 - [Python documentation - Loggers](https://docs.python.org/3/howto/logging.html#loggers) 

 - Python
 documentation - Using particular formatting styles throughout your application 

 - Python documentation - Formatted string
 literals

---

### Riga 472 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "tb" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 24-26 |
| Tags | unused |

**üíª Codice attuale:**
```python
     470: 
     471:     def _on_generic_error(self, error_tuple, title):
 >>> 472:         exctype, value, tb = error_tuple
     473:         CustomMessageDialog.show_error(self, title, f"{value}")
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 472 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "exctype" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-15 |
| Tags | unused |

**üíª Codice attuale:**
```python
     470: 
     471:     def _on_generic_error(self, error_tuple, title):
 >>> 472:         exctype, value, tb = error_tuple
     473:         CustomMessageDialog.show_error(self, title, f"{value}")
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `app/api/main.py`
**9 issue(s)** | Effort: 4h 31min

### Riga 47 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 26 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 16min |
| Posizione | Colonne 10-20 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     45: 
     46: @router.post("/upload-pdf/", dependencies=[Depends(deps.check_write_permission), Depends(deps.verify_license)])
 >>> 47: async def upload_pdf(
     48:     file: UploadFile = File(...),
     49:     db: Session = Depends(get_db),
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 81 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal '%d/%m/%Y' 30 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 1h |
| Posizione | Colonne 66-76 |
| Tags | design |

**üíª Codice attuale:**
```python
     79:             parsed_date = parse_date_flexible(extracted_data[date_field])
     80:             if parsed_date:
 >>> 81:                 extracted_data[date_field] = parsed_date.strftime('%d/%m/%Y')
     82:             # If parsing fails, we leave it as is (or could set to None/warn)
     83: 
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 100 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 4-19 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     98: 
     99: @router.get("/certificati/", response_model=List[CertificatoSchema], dependencies=[Depends(deps.verify_license)])
 >>> 100: def get_certificati(validated: Optional[bool] = Query(None), db: Session = Depends(get_db)):
     101:     query = db.query(Certificato).options(selectinload(Certificato.dipendente), selectinload(Certificato.corso))
     102:     if validated is not None:
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 121 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "DA ASSEGNARE" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 56-70 |
| Tags | design |

**üíª Codice attuale:**
```python
     119:             matricola = cert.dipendente.matricola
     120:         else:
 >>> 121:             nome_completo = cert.nome_dipendente_raw or "DA ASSEGNARE"
     122:             data_nascita = cert.data_nascita_raw
     123:             matricola = None
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 145 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Certificato non trovato" 4 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 8min |
| Posizione | Colonne 52-77 |
| Tags | design |

**üíª Codice attuale:**
```python
     143:     db_cert = db.get(Certificato, certificato_id)
     144:     if not db_cert:
 >>> 145:         raise HTTPException(status_code=404, detail="Certificato non trovato")
     146: 
     147:     status = certificate_logic.get_certificate_status(db, db_cert)
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 171 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 28 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 18min |
| Posizione | Colonne 4-22 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     169: 
     170: @router.post("/certificati/", response_model=CertificatoSchema, dependencies=[Depends(deps.check_write_permission), Depends(deps.verify_license)])
 >>> 171: def create_certificato(
     172:     certificato: CertificatoCreazioneSchema,
     173:     db: Session = Depends(get_db),
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 333 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 77 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 1h7min |
| Posizione | Colonne 4-22 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     331: 
     332: @router.put("/certificati/{certificato_id}", response_model=CertificatoSchema, dependencies=[Depends(deps.check_write_permission), Depends(deps.verify_license)])
 >>> 333: def update_certificato(
     334:     certificato_id: int,
     335:     certificato: CertificatoAggiornamentoSchema,
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 553 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 94 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 1h24min |
| Posizione | Colonne 10-31 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     551: 
     552: @router.post("/dipendenti/import-csv", dependencies=[Depends(deps.check_write_permission), Depends(deps.verify_license)])
 >>> 553: async def import_dipendenti_csv(
     554:     file: UploadFile = File(...),
     555:     db: Session = Depends(get_db),
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 735 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Dipendente non trovato" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 52-76 |
| Tags | design |

**üíª Codice attuale:**
```python
     733: 
     734:     if not dipendente:
 >>> 735:         raise HTTPException(status_code=404, detail="Dipendente non trovato")
     736: 
     737:     # Calculate status for all certs
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

## üìÑ `desktop_app/main.py`
**7 issue(s)** | Effort: 36min

### Riga 482 üü° üü¢ MINOR

**üéØ Problema:** Remove this unneeded "pass".

| Campo | Valore |
|-------|--------|
| Regola | `python:S2772` - "pass" should not be used needlessly |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 8-12 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     480:         if os.name != 'nt':
     481:             return
 >>> 482:         pass
     483: 
     484:     def check_backend_health(self):
```

**‚ùì Perch√© √® un problema:**

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

**üìù Descrizione:**

This rule raises an issue when a `pass` statement is redundant.

### Why is this an issue?

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

#### Code examples

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

### Resources

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

**üìö Risorse:**

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

---

### Riga 494 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     492:                 try:
     493:                     detail = response.json().get("detail", "Errore sconosciuto")
 >>> 494:                 except:
     495:                     detail = response.text
     496: 
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 503 üü° üü¢ MINOR

**üéØ Problema:** Remove this unneeded "pass".

| Campo | Valore |
|-------|--------|
| Regola | `python:S2772` - "pass" should not be used needlessly |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 12-16 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     501:             print(f"[DEBUG] Health Check Warning: {e}")
     502:             # We proceed, as network errors might be temporary or handled by LoginView
 >>> 503:             pass
     504: 
     505:     def show_notification(self, title, message, icon_name="file-text.svg"):
```

**‚ùì Perch√© √® un problema:**

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

**üìù Descrizione:**

This rule raises an issue when a `pass` statement is redundant.

### Why is this an issue?

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

#### Code examples

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

### Resources

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

**üìö Risorse:**

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

---

### Riga 539 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Sola Lettura" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 65-79 |
| Tags | design |

**üíª Codice attuale:**
```python
     537:         """
     538:         if self.dashboard and getattr(self.dashboard, 'is_read_only', False):
 >>> 539:             CustomMessageDialog.show_warning(self.master_window, "Sola Lettura", "Impossibile avviare l'analisi in modalit√† Sola Lettura.")
     540:             return
     541: 
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 573 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 24 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 14min |
| Posizione | Colonne 8-24 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     571:             CustomMessageDialog.show_error(self.master_window, "Errore Importazione", f"Impossibile importare il file:\n{e}")
     572: 
 >>> 573:     def on_login_success(self, user_info):
     574:         # Create Dashboard if not exists
     575:         if not self.dashboard:
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 591 üü° üü¢ MINOR

**üéØ Problema:** Remove this unneeded "pass".

| Campo | Valore |
|-------|--------|
| Regola | `python:S2772` - "pass" should not be used needlessly |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 12-16 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     589:             
     590:             # We can expose a method on Dashboard to register for completion.
 >>> 591:             pass
     592: 
     593:         # Start Inactivity Timer (1 hour)
```

**‚ùì Perch√© √® un problema:**

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

**üìù Descrizione:**

This rule raises an issue when a `pass` statement is redundant.

### Why is this an issue?

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

#### Code examples

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

### Resources

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

**üìö Risorse:**

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

---

### Riga 641 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "pending_count".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | unused |

**üíª Codice attuale:**
```python
     639: 
     640:         # Check for pending documents notification
 >>> 641:         pending_count = user_info.get("pending_documents_count", 0)
     642:         
     643:         # Play Welcome Speech (Voice Service)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `admin/offusca/build_dist.py`
**7 issue(s)** | Effort: 1h 24min

### Riga 84 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 39 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 29min |
| Posizione | Colonne 4-16 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     82:     return libs
     83: 
 >>> 84: def scan_imports(source_dirs):
     85:     log_and_print("--- Scanning source code for imports ---")
     86:     detected_imports = set()
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 108 üü° üü° MAJOR

**üéØ Problema:** Merge this if statement with the enclosing one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1066` - Mergeable "if" statements should be combined |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 20-22 |
| Tags | clumsy |

**üíª Codice attuale:**
```python
     106:                         if root_pkg not in std_libs: detected_imports.add(root_pkg)
     107:                 elif isinstance(node, ast.ImportFrom):
 >>> 108:                     if node.module:
     109:                         root_pkg = node.module.split('.')[0]
     110:                         if root_pkg not in std_libs: detected_imports.add(root_pkg)
```

**‚ùì Perch√© √® un problema:**

Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.

Merging `if` statements when possible will decrease the nesting of the code and improve its readability.

Code like

```
if condition1:
 if condition2: # Noncompliant
 # ...
```

Will be more readable as

```
if condition1 and condition2: # Compliant
 # ...
```

**‚úÖ Come risolvere:**

If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.

##### Noncompliant code example

```
if file.isValid():
 if file.isfile() or file.isdir(): # Noncompliant
 # ...
```

##### Compliant solution

```
def isFileOrDirectory(File file):
 return file.isFile() or file.isDirectory()

if file.isValid() and isFileOrDirectory(file): # Compliant
 # ...
```

---

### Riga 111 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     109:                         root_pkg = node.module.split('.')[0]
     110:                         if root_pkg not in std_libs: detected_imports.add(root_pkg)
 >>> 111:         except: pass
     112: 
     113:     detected_imports.discard("app")
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 118 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 19 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 9min |
| Posizione | Colonne 4-22 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     116:     return list(detected_imports)
     117: 
 >>> 118: def verify_environment():
     119:     log_and_print("--- Step 1/7: Environment Diagnostics ---")
     120:     log_and_print(f"Running with Python: {sys.executable}")
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 134 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "requirements.txt" 4 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 8min |
| Posizione | Colonne 38-56 |
| Tags | design |

**üíª Codice attuale:**
```python
     132:         sys.exit(1)
     133: 
 >>> 134:     req_path = os.path.join(ROOT_DIR, "requirements.txt")
     135:     if os.path.exists(req_path):
     136:         log_and_print(f"Checking dependencies from {req_path}...")
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 180 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 37 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 27min |
| Posizione | Colonne 4-9 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     178:     return modules
     179: 
 >>> 180: def build():
     181:     try:
     182:         log_and_print("Starting Build Process...")
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 392 üü° üü° MAJOR

**üéØ Problema:** Add replacement fields or use a normal string instead of an f-string.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3457` - String formatting should be used correctly |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 17-40 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     390:                  iscc_exe,
     391:                  f"/dBuildDir={build_dir_abs}",
 >>> 392:                  f"/dMyAppVersion=1.0.0",
     393:                  "setup_script.iss"
     394:              ]
```

**‚ùì Perch√© √® un problema:**

A format string is a string that contains placeholders, usually represented by special characters such as "%s" or "{}", depending on the technology
in use. These placeholders are replaced by values when the string is printed or logged. Thus, it is required that a string is valid and arguments
match replacement fields in this string.

This applies to [the % operator](https://docs.python.org/3/tutorial/inputoutput.html#old-string-formatting), the [str.format](https://docs.python.org/3/tutorial/inputoutput.html#the-string-format-method) method, and loggers from the [logging](https://docs.python.org/3/library/logging.html) module. Internally, the latter use the `%-formatting`. The only
difference is that they will log an error instead of raising an exception when the provided arguments are invalid.

Formatted string literals (also called "f-strings"; available since Python 3.6) are generally simpler to use, and any syntax mistake will cause a
failure at compile time. However, it is easy to...

**‚úÖ Come risolvere:**

A `printf-`-style format string is a string that contains placeholders, which are replaced by values when the string is printed or
logged. Mismatch in the format specifiers and the arguments provided can lead to incorrect strings being created.

To avoid issues, a developer should ensure that the provided arguments match format specifiers.

##### Noncompliant code example

```
"Error %(message)s" % {"message": "something failed", "extra": "some dead code"} # Noncompliant. Remove the unused argument "extra" or add a replacement field.

"Error: User {} has not been able to access []".format("Alice", "MyFile") # Noncompliant. Remove 1 unexpected argument or add a replacement field.

user = "Alice"
resource = "MyFile"
message = f"Error: User [user] has not been able to access [resource]" # Noncompliant. Add replacement fields or use a normal string instead of an f-string.

import logging
logging.error("Error: User %s has not been able to access %s", "Alice") # Noncompliant. Add 1 missing argument.
```

##### Compliant solution

```
"Error %(message)s" % {"message": "something failed"}

"Error: User {} has not been able to access {}".format("Alice", "MyFile")

user = "Alice"
resource = "MyFile"
message = f"Error: User {user} has not been able to access {resource}"

import logging
logging.error("Error: User %s has not been able to access %s", "Alice", "MyFile")
```

**üìö Risorse:**

- [Python documentation - Format String Syntax](https://docs.python.org/3/library/string.html#format-string-syntax) 

 - Python documentation - printf-style String
 Formatting 

 - [Python documentation - Loggers](https://docs.python.org/3/howto/logging.html#loggers) 

 - Python
 documentation - Using particular formatting styles throughout your application 

 - Python documentation - Formatted string
 literals

---

## üìÑ `tests/app/core/test_db_security_failures.py`
**6 issue(s)** | Effort: 30min

### Riga 56 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "m_open".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 79-85 |
| Tags | unused |

**üíª Codice attuale:**
```python
     54:         
     55:         # Mock opening the lock file
 >>> 56:         with patch('builtins.open', mock_open(read_data=b'L{invalid_json')) as m_open:
     57:             with patch('app.core.db_security.os.remove') as m_remove:
     58:                 # Initialize manager (triggering the check)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 59 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "mgr".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 16-19 |
| Tags | unused |

**üíª Codice attuale:**
```python
     57:             with patch('app.core.db_security.os.remove') as m_remove:
     58:                 # Initialize manager (triggering the check)
 >>> 59:                 mgr = DBSecurityManager()
     60:                 
     61:                 # Verify removal was attempted
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 74 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "mgr".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 20-23 |
| Tags | unused |

**üíª Codice attuale:**
```python
     72:             with patch('app.core.db_security.psutil.pid_exists', return_value=False):
     73:                 with patch('app.core.db_security.os.remove') as m_remove:
 >>> 74:                     mgr = DBSecurityManager()
     75:                     m_remove.assert_called()
     76: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 88 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "mgr".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 24-27 |
| Tags | unused |

**üíª Codice attuale:**
```python
     86:                     m_proc.return_value.name.return_value = "chrome.exe"
     87:                     with patch('app.core.db_security.os.remove') as m_remove:
 >>> 88:                         mgr = DBSecurityManager()
     89:                         m_remove.assert_called()
     90: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 101 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "mgr".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 24-27 |
| Tags | unused |

**üíª Codice attuale:**
```python
     99:                     m_proc.return_value.name.return_value = "python.exe"
     100:                     with patch('app.core.db_security.os.remove') as m_remove:
 >>> 101:                         mgr = DBSecurityManager()
     102:                         m_remove.assert_not_called()
     103: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 177 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "m_open".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 52-58 |
| Tags | unused |

**üíª Codice attuale:**
```python
     175:         
     176:         # Let's mock the internal implementation of _safe_write
 >>> 177:         with patch('builtins.open', mock_open()) as m_open:
     178:             with patch('os.replace') as m_replace:
     179:                 # First 2 calls fail, 3rd succeeds
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `desktop_app/views/config_view.py`
**6 issue(s)** | Effort: 44min

### Riga 228 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 17 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 7min |
| Posizione | Colonne 8-17 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     226:         return int(self.table.item(rows[0].row(), 0).text())
     227: 
 >>> 228:     def edit_user(self):
     229:         user_id = self.get_selected_user_id()
     230:         if not user_id: return
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 252 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 8-27 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     250:                 CustomMessageDialog.show_error(self, "Errore", str(e))
     251: 
 >>> 252:     def change_own_password(self):
     253:         dialog = ChangePasswordDialog(self)
     254:         if dialog.exec():
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 275 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     273:                     else:
     274:                         CustomMessageDialog.show_error(self, "Errore", str(e))
 >>> 275:                 except:
     276:                     CustomMessageDialog.show_error(self, "Errore", str(e))
     277: 
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 344 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Ottimizza Database Ora" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 40-64 |
| Tags | design |

**üíª Codice attuale:**
```python
     342:         self.form_layout.addRow(maint_separator)
     343: 
 >>> 344:         self.optimize_btn = QPushButton("Ottimizza Database Ora")
     345:         self.optimize_btn.setToolTip("Esegue VACUUM e ANALYZE per recuperare spazio e migliorare le prestazioni.")
     346:         self.optimize_btn.clicked.connect(self.optimize_db)
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 635 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     633:                     dt = datetime.fromisoformat(ts_str)
     634:                     formatted_date = dt.strftime("%d/%m/%Y %H:%M:%S")
 >>> 635:                 except:
     636:                     formatted_date = ts_str
     637: 
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 958 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 25 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 15min |
| Posizione | Colonne 8-19 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     956:                 CustomMessageDialog.show_error(self, "Errore", f"Impossibile importare: {e}")
     957: 
 >>> 958:     def save_config(self):
     959:         if getattr(self, 'is_read_only', False):
     960:             return
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `desktop_app/views/login_view.py`
**6 issue(s)** | Effort: 1h 2min

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 17-23 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 36-42 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 216 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Hardware ID" 5 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 28-41 |
| Tags | design |

**üíª Codice attuale:**
```python
     214:             }
     215:         """)
 >>> 216:         if license_data and "Hardware ID" in license_data:
     217:             stored_hw_id = license_data["Hardware ID"]
     218:             if stored_hw_id == current_hw_id:
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 242 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "color: #93C5FD; font-size: 13px; font-weight: 500;" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 40-92 |
| Tags | design |

**üíª Codice attuale:**
```python
     240:             license_label.setStyleSheet("color: #FBBF24; font-size: 13px; font-weight: 600;")
     241:         else:
 >>> 242:             license_label.setStyleSheet("color: #93C5FD; font-size: 13px; font-weight: 500;")
     243:         license_label.setWordWrap(True)
     244:         license_info_layout.addWidget(license_label)
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 749 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 44 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 34min |
| Posizione | Colonne 8-24 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     747:         CustomMessageDialog.show_error(self, "Errore di Accesso", error_msg)
     748: 
 >>> 749:     def on_login_success(self, response):
     750:         try:
     751:             self.api_client.set_token(response)
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 765 üü° üü¢ MINOR

**üéØ Problema:** Remove this unneeded "pass".

| Campo | Valore |
|-------|--------|
| Regola | `python:S2772` - "pass" should not be used needlessly |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 21-25 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     763:                      # But we are trapped.
     764:                      # Let's show warning and then continue to Read-Only mode, skipping the loop.
 >>> 765:                      pass
     766:                 else:
     767:                     while True:
```

**‚ùì Perch√© √® un problema:**

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

**üìù Descrizione:**

This rule raises an issue when a `pass` statement is redundant.

### Why is this an issue?

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

#### Code examples

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

### Resources

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

**üìö Risorse:**

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

---

## üìÑ `desktop_app/utils.py`
**6 issue(s)** | Effort: 30min

### Riga 95 üü° üü° MAJOR

**üéØ Problema:** Replace this character class by the character itself.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6397` - Character classes in regular expressions should not contain only one character |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-22 |
| Tags | regex |

**üíª Codice attuale:**
```python
     93:     """
     94:     # 1. Always replace acute accents on a, i, u (Phonetic stress markers)
 >>> 95:     text = re.sub(r'[√°]', 'a', text)
     96:     text = re.sub(r'[√≠]', 'i', text)
     97:     text = re.sub(r'[√∫]', 'u', text)
```

**‚ùì Perch√© √® un problema:**

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

**üìù Descrizione:**

### Why is this an issue?

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

---

### Riga 96 üü° üü° MAJOR

**üéØ Problema:** Replace this character class by the character itself.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6397` - Character classes in regular expressions should not contain only one character |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-22 |
| Tags | regex |

**üíª Codice attuale:**
```python
     94:     # 1. Always replace acute accents on a, i, u (Phonetic stress markers)
     95:     text = re.sub(r'[√°]', 'a', text)
 >>> 96:     text = re.sub(r'[√≠]', 'i', text)
     97:     text = re.sub(r'[√∫]', 'u', text)
     98: 
```

**‚ùì Perch√© √® un problema:**

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

**üìù Descrizione:**

### Why is this an issue?

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

---

### Riga 97 üü° üü° MAJOR

**üéØ Problema:** Replace this character class by the character itself.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6397` - Character classes in regular expressions should not contain only one character |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-22 |
| Tags | regex |

**üíª Codice attuale:**
```python
     95:     text = re.sub(r'[√°]', 'a', text)
     96:     text = re.sub(r'[√≠]', 'i', text)
 >>> 97:     text = re.sub(r'[√∫]', 'u', text)
     98: 
     99:     # Regex lookahead (?=[^\W_]) ensures the character is followed by a word character
```

**‚ùì Perch√© √® un problema:**

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

**üìù Descrizione:**

### Why is this an issue?

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

---

### Riga 107 üü° üü° MAJOR

**üéØ Problema:** Replace this character class by the character itself.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6397` - Character classes in regular expressions should not contain only one character |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-22 |
| Tags | regex |

**üíª Codice attuale:**
```python
     105: 
     106:     # 3. Also clean other accents inside words if used for stress (e.g. c√†sa)
 >>> 107:     text = re.sub(r'[√†](?=[^\W_])', 'a', text)
     108:     text = re.sub(r'[√¨](?=[^\W_])', 'i', text)
     109:     text = re.sub(r'[√π](?=[^\W_])', 'u', text)
```

**‚ùì Perch√© √® un problema:**

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

**üìù Descrizione:**

### Why is this an issue?

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

---

### Riga 108 üü° üü° MAJOR

**üéØ Problema:** Replace this character class by the character itself.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6397` - Character classes in regular expressions should not contain only one character |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-22 |
| Tags | regex |

**üíª Codice attuale:**
```python
     106:     # 3. Also clean other accents inside words if used for stress (e.g. c√†sa)
     107:     text = re.sub(r'[√†](?=[^\W_])', 'a', text)
 >>> 108:     text = re.sub(r'[√¨](?=[^\W_])', 'i', text)
     109:     text = re.sub(r'[√π](?=[^\W_])', 'u', text)
     110: 
```

**‚ùì Perch√© √® un problema:**

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

**üìù Descrizione:**

### Why is this an issue?

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

---

### Riga 109 üü° üü° MAJOR

**üéØ Problema:** Replace this character class by the character itself.

| Campo | Valore |
|-------|--------|
| Regola | `python:S6397` - Character classes in regular expressions should not contain only one character |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 21-22 |
| Tags | regex |

**üíª Codice attuale:**
```python
     107:     text = re.sub(r'[√†](?=[^\W_])', 'a', text)
     108:     text = re.sub(r'[√¨](?=[^\W_])', 'i', text)
 >>> 109:     text = re.sub(r'[√π](?=[^\W_])', 'u', text)
     110: 
     111:     return text
```

**‚ùì Perch√© √® un problema:**

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

**üìù Descrizione:**

### Why is this an issue?

Character classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or
ranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character
class.

Thus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.

#### Noncompliant code example

```
r"a[b]c"
```

#### Compliant solution

```
r"abc"
```

#### Exceptions

This rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,
`[.]{3}` to match three dots).

---

## üìÑ `tests/desktop_app/test_main_window.py`
**6 issue(s)** | Effort: 30min

### Riga 11 üü° üü¢ MINOR

**üéØ Problema:** Remove this unnecessary `list()` call on an already iterable object.

| Campo | Valore |
|-------|--------|
| Regola | `python:S7504` - When iterating over an iterable object, using "list()" should be avoided |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 17-21 |

**üíª Codice attuale:**
```python
     9:     with patch.dict(sys.modules, modules):
     10:         # Unload desktop_app modules to force re-import with mocks
 >>> 11:         for k in list(sys.modules.keys()):
     12:             if k.startswith('desktop_app'):
     13:                 del sys.modules[k]
```

**‚ùì Perch√© √® un problema:**

When iterating over an already iterable object with a for loop or a comprehension, wrapping it with `list()` adds meaningless clutter
that doesn‚Äôt provide any functional value. Additionally, it creates unnecessary overhead by generating an intermediate list in memory, which
inefficiently consumes memory and can degrade performance, especially with large data structures. Iterating directly over the original object is
cleaner and more efficient.

**‚úÖ Come risolvere:**

Remove the redundant `list()` call and iterate directly over the original iterable.

##### Noncompliant code example

```
some_iterable = range(10)
for i in list(some_iterable): # Noncompliant: unnecessary list() call
 print(i)
```

##### Compliant solution

```
some_iterable = range(10)
for i in some_iterable: # Compliant
 print(i)
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Iterable Glossary Entry](https://docs.python.org/3/glossary.html#term-iterable) 

 - Python Documentation - [list()](https://docs.python.domainunion.de/3/library/stdtypes.html#list)

---

### Riga 26 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "MockImport".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 62-72 |
| Tags | unused |

**üíª Codice attuale:**
```python
     24:     
     25:     with patch("desktop_app.views.database_view.DatabaseView") as MockDash, \
 >>> 26:          patch("desktop_app.views.import_view.ImportView") as MockImport, \
     27:          patch("desktop_app.views.validation_view.ValidationView") as MockValid, \
     28:          patch("desktop_app.views.scadenzario_view.ScadenzarioView") as MockScad, \
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 27 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "MockValid".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 70-79 |
| Tags | unused |

**üíª Codice attuale:**
```python
     25:     with patch("desktop_app.views.database_view.DatabaseView") as MockDash, \
     26:          patch("desktop_app.views.import_view.ImportView") as MockImport, \
 >>> 27:          patch("desktop_app.views.validation_view.ValidationView") as MockValid, \
     28:          patch("desktop_app.views.scadenzario_view.ScadenzarioView") as MockScad, \
     29:          patch("desktop_app.views.config_view.ConfigView") as MockConfig, \
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 28 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "MockScad".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 72-80 |
| Tags | unused |

**üíª Codice attuale:**
```python
     26:          patch("desktop_app.views.import_view.ImportView") as MockImport, \
     27:          patch("desktop_app.views.validation_view.ValidationView") as MockValid, \
 >>> 28:          patch("desktop_app.views.scadenzario_view.ScadenzarioView") as MockScad, \
     29:          patch("desktop_app.views.config_view.ConfigView") as MockConfig, \
     30:          patch("desktop_app.views.modern_guide_view.ModernGuideView") as MockGuide, \
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 29 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "MockConfig".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 62-72 |
| Tags | unused |

**üíª Codice attuale:**
```python
     27:          patch("desktop_app.views.validation_view.ValidationView") as MockValid, \
     28:          patch("desktop_app.views.scadenzario_view.ScadenzarioView") as MockScad, \
 >>> 29:          patch("desktop_app.views.config_view.ConfigView") as MockConfig, \
     30:          patch("desktop_app.views.modern_guide_view.ModernGuideView") as MockGuide, \
     31:          patch("desktop_app.main_window_ui.QIcon") as MockIcon, \
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 30 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "MockGuide".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 73-82 |
| Tags | unused |

**üíª Codice attuale:**
```python
     28:          patch("desktop_app.views.scadenzario_view.ScadenzarioView") as MockScad, \
     29:          patch("desktop_app.views.config_view.ConfigView") as MockConfig, \
 >>> 30:          patch("desktop_app.views.modern_guide_view.ModernGuideView") as MockGuide, \
     31:          patch("desktop_app.main_window_ui.QIcon") as MockIcon, \
     32:          patch("os.path.exists", return_value=True):
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/desktop_app/views/test_main_views.py`
**6 issue(s)** | Effort: 1h

### Riga 14 üü° üî¥ CRITICAL

**üéØ Problema:** Remove this identity check; it will always be True.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5727` - Comparison to None should not be constant |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 15-31 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     12:         view = DatabaseView()
     13:         # Verify it's our DummyQWidget
 >>> 14:         assert view is not None
     15:         MockVM.assert_called()
     16: 
```

**‚ùì Perch√© √® un problema:**

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

**üìù Descrizione:**

This rule raises an issue when a comparison to `None` is invariant.

### Why is this an issue?

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

#### Code examples

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

### Resources

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

**üìö Risorse:**

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

---

### Riga 30 üü° üî¥ CRITICAL

**üéØ Problema:** Remove this identity check; it will always be True.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5727` - Comparison to None should not be constant |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 15-31 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     28: 
     29:         view = ValidationView()
 >>> 30:         assert view is not None
     31: 
     32:         # Manually trigger refresh
```

**‚ùì Perch√© √® un problema:**

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

**üìù Descrizione:**

This rule raises an issue when a comparison to `None` is invariant.

### Why is this an issue?

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

#### Code examples

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

### Resources

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

**üìö Risorse:**

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

---

### Riga 52 üü° üî¥ CRITICAL

**üéØ Problema:** Remove this identity check; it will always be True.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5727` - Comparison to None should not be constant |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 15-31 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     50: 
     51:         view = ScadenzarioView()
 >>> 52:         assert view is not None
     53:         # ScadenzarioView calls load_data in init -&gt; starts worker
     54:         assert MockThreadPool.return_value.start.called
```

**‚ùì Perch√© √® un problema:**

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

**üìù Descrizione:**

This rule raises an issue when a comparison to `None` is invariant.

### Why is this an issue?

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

#### Code examples

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

### Resources

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

**üìö Risorse:**

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

---

### Riga 59 üü° üî¥ CRITICAL

**üéØ Problema:** Remove this identity check; it will always be True.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5727` - Comparison to None should not be constant |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 11-27 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     57:     from desktop_app.views.import_view import ImportView
     58:     view = ImportView()
 >>> 59:     assert view is not None
     60: 
     61: def test_config_view_init():
```

**‚ùì Perch√© √® un problema:**

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

**üìù Descrizione:**

This rule raises an issue when a comparison to `None` is invariant.

### Why is this an issue?

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

#### Code examples

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

### Resources

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

**üìö Risorse:**

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

---

### Riga 74 üü° üî¥ CRITICAL

**üéØ Problema:** Remove this identity check; it will always be True.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5727` - Comparison to None should not be constant |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 15-31 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     72:         # Pass the mocked client to the constructor
     73:         view = ConfigView(api_client=mock_api_client)
 >>> 74:         assert view is not None
     75:         # Basic assertion to ensure the view initialized
     76:         assert view.api_client == mock_api_client
```

**‚ùì Perch√© √® un problema:**

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

**üìù Descrizione:**

This rule raises an issue when a comparison to `None` is invariant.

### Why is this an issue?

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

#### Code examples

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

### Resources

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

**üìö Risorse:**

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

---

### Riga 86 üü° üî¥ CRITICAL

**üéØ Problema:** Remove this identity check; it will always be True.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5727` - Comparison to None should not be constant |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 11-29 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     84:     categories = ["CAT1", "CAT2"]
     85:     dialog = EditCertificatoDialog(data, categories)
 >>> 86:     assert dialog is not None
     87:     # Test get_data
     88:     res = dialog.get_data()
```

**‚ùì Perch√© √® un problema:**

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

**üìù Descrizione:**

This rule raises an issue when a comparison to `None` is invariant.

### Why is this an issue?

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

#### Code examples

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

### Resources

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

**üìö Risorse:**

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

---

## üìÑ `tests/desktop_app/views/test_config_view_interactions.py`
**5 issue(s)** | Effort: 19min

### Riga 15 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     13:     def __init__(self, parent=None):
     14:         super().__init__(parent)
 >>> 15:     def setFrameShape(self, shape): pass
     16:     def setFrameShadow(self, shadow): pass
     17:     class Shape: HLine=1
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 16 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     14:         super().__init__(parent)
     15:     def setFrameShape(self, shape): pass
 >>> 16:     def setFrameShadow(self, shadow): pass
     17:     class Shape: HLine=1
     18:     class Shadow: Sunken=1
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 17 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "HLine" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 17-22 |
| Tags | convention |

**üíª Codice attuale:**
```python
     15:     def setFrameShape(self, shape): pass
     16:     def setFrameShadow(self, shadow): pass
 >>> 17:     class Shape: HLine=1
     18:     class Shadow: Sunken=1
     19: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 18 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Sunken" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 18-24 |
| Tags | convention |

**üíª Codice attuale:**
```python
     16:     def setFrameShadow(self, shadow): pass
     17:     class Shape: HLine=1
 >>> 18:     class Shadow: Sunken=1
     19: 
     20: # Define a MockWidget that ignores constructor args to prevent MagicMock spec interpretation
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 116 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     114:         self.view = ConfigView(self.api_client)
     115: 
 >>> 116:     def tearDown(self):
     117:         pass
     118: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

## üìÑ `app/services/sync_service.py`
**5 issue(s)** | Effort: 1h 14min

### Riga 82 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 17 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 7min |
| Posizione | Colonne 4-28 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     80:     return new_filename
     81: 
 >>> 82: def archive_certificate_file(db: Session, cert: Certificato) -&gt; bool:
     83:     """
     84:     Moves a certificate's file to the STORICO folder.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 82 üü° üü° MAJOR

**üéØ Problema:** Remove the unused function parameter "db".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1172` - Unused function parameters should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 29-40 |
| Tags | unused |

**üíª Codice attuale:**
```python
     80:     return new_filename
     81: 
 >>> 82: def archive_certificate_file(db: Session, cert: Certificato) -&gt; bool:
     83:     """
     84:     Moves a certificate's file to the STORICO folder.
```

**‚ùì Perch√© √® un problema:**

A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function‚Äôs
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function‚Äôs behavior will be the same, but the programmer‚Äôs intention won‚Äôt be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.

#### Exceptions

This rule ignores overriding methods.

```
class C(B):
 def do_something(self, a, b): # no issue reported on b
 return self.compute(a)
```

This rule also ignores variables named with a single underscore `_`. Such naming is a common practice for indicating that the variable
is insignificant.

```
def do_something(a, _): # no issue reported on _
 return compute(a)
```

The rule also won‚Äôt raise an issue if the parameter is referenced in a docstring or a comment:
...

**‚úÖ Come risolvere:**

Having unused function parameters in your code can lead to confusion and misunderstanding of a developer‚Äôs intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.

##### Noncompliant code example

```
def do_something(a, b): # second parameter is unused
 return compute(a)
```

##### Compliant solution

```
def do_something(a):
 return compute(a)
```

---

### Riga 98 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal '%d/%m/%Y' 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 63-73 |
| Tags | design |

**üíª Codice attuale:**
```python
     96:         'matricola': cert.dipendente.matricola if cert.dipendente else None,
     97:         'categoria': cert.corso.categoria_corso,
 >>> 98:         'data_scadenza': cert.data_scadenza_calcolata.strftime('%d/%m/%Y') if cert.data_scadenza_calcolata else None
     99:     }
     100: 
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 128 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 46 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 36min |
| Posizione | Colonne 4-30 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     126:     return False
     127: 
 >>> 128: def link_orphaned_certificates(db: Session, dipendente: Dipendente) -&gt; int:
     129:     """
     130:     Scans for orphaned certificates that match the given employee and links them.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 195 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 30 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 20min |
| Posizione | Colonne 4-25 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     193:     return linked_count
     194: 
 >>> 195: def synchronize_all_files(db: Session):
     196:     """
     197:     Scans all certificates and ensures their PDF files are located in the correct
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `desktop_app/views/import_view.py`
**5 issue(s)** | Effort: 1h 50min

### Riga 43 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "processed_files".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-23 |
| Tags | unused |

**üíª Codice attuale:**
```python
     41:     def run(self):
     42:         total_files = len(self.file_paths)
 >>> 43:         processed_files = 0
     44:         for i, file_path in enumerate(self.file_paths):
     45:             if self._is_stopped:
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 75 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 93 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 1h23min |
| Posizione | Colonne 8-19 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     73:         self.finished.emit(self.archived_count, self.verify_count)
     74: 
 >>> 75:     def process_pdf(self, file_path):
     76:         original_filename = os.path.basename(file_path)
     77: 
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 108 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal '%d/%m/%Y' 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 81-91 |
| Tags | design |

**üíª Codice attuale:**
```python
     106:                     else:
     107:                         try:
 >>> 108:                             scadenza_date = datetime.strptime(data_scadenza_str, '%d/%m/%Y').date()
     109:                             file_scadenza = scadenza_date.strftime('%d_%m_%Y')
     110:                             # Bug 5 Fix: Use backend-aligned logic for status (considering threshold)
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 120 üü° üü° MAJOR

**üéØ Problema:** Either merge this branch with the identical one on line "117" or change one of the implementations.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1871` - Two branches in a conditional structure should not have exactly the same implementation |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 10min |
| Posizione | Colonne 32-48 |
| Tags | design, suspicious |

**üíª Codice attuale:**
```python
     118:                             # If expiring soon, it is technically "ATTIVO" folder (as per sync_service logic: attivo/in_scadenza -&gt; ATTIVO)
     119:                             elif scadenza_date &gt;= datetime.now().date():
 >>> 120:                                 stato = 'ATTIVO'
     121:                             # Else it is expired
     122:                         except ValueError:
```

**‚ùì Perch√© √® un problema:**

When the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can
potentially introduce bugs if one instance of the code is changed but others are not.

Having two branches in the same `if` structure with the same implementation is at best duplicate code, and at worst a coding error.

```
if 0 &lt;= a &lt; 10:
 do_first()
 do_second()
elif 10 &lt;= a &lt; 20:
 do_the_other_thing()
elif 20 &lt;= a &lt; 50:
 do_first() # Noncompliant; duplicates first condition
 do_second()
```

If the same logic is needed for both instances, then the conditions should be combined.

```
if (0 &lt;= a &lt; 10) or (20 &lt;= a &lt; 50):
 do_first()
 do_second()
elif 10 &lt;= a &lt; 20:
 do_the_other_thing()
```

#### Exceptions

Blocks in an `if` chain that contain a single line of code are ignored.

```
if 0 &lt;= a &lt; 10:
 do_first()
elif 10 &lt;= a &lt; 20:
 do_the_other_thing()
elif 20 &lt;= a &lt; 50:
 do_first() # no issu...

**üìù Descrizione:**

### Why is this an issue?

When the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can
potentially introduce bugs if one instance of the code is changed but others are not.

Having two branches in the same `if` structure with the same implementation is at best duplicate code, and at worst a coding error.

```
if 0 &lt;= a &lt; 10:
 do_first()
 do_second()
elif 10 &lt;= a &lt; 20:
 do_the_other_thing()
elif 20 &lt;= a &lt; 50:
 do_first() # Noncompliant; duplicates first condition
 do_second()
```

If the same logic is needed for both instances, then the conditions should be combined.

```
if (0 &lt;= a &lt; 10) or (20 &lt;= a &lt; 50):
 do_first()
 do_second()
elif 10 &lt;= a &lt; 20:
 do_the_other_thing()
```

#### Exceptions

Blocks in an `if` chain that contain a single line of code are ignored.

```
if 0 &lt;= a &lt; 10:
 do_first()
elif 10 &lt;= a &lt; 20:
 do_the_other_thing()
elif 20 &lt;= a &lt...

**üìö Risorse:**

#### Related rules

 - S3923 - All branches in a conditional structure should not have exactly the same implementation

---

### Riga 133 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "ERRORI ANALISI" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 66-82 |
| Tags | design |

**üíª Codice attuale:**
```python
     131:                     new_filename = f"{nome_fs} ({matricola_fs}) - {categoria_fs} - {file_scadenza}.pdf"
     132: 
 >>> 133:                     target_dir = os.path.join(self.output_folder, "ERRORI ANALISI", error_category, employee_folder_name, categoria_fs, stato)
     134:                     os.makedirs(target_dir, exist_ok=True)
     135:                     shutil.move(source_path, os.path.join(target_dir, new_filename))
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

## üìÑ `tests/app/test_main_full.py`
**5 issue(s)** | Effort: 25min

### Riga 35 üü° üü° MAJOR

**üéØ Problema:** Either remove or fill this block of code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S108` - Nested blocks of code should not be left empty |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     33:         # Run lifespan
     34:         async with lifespan(app):
 >>> 35:             pass
     36: 
     37:         mock_sec.load_memory_db.assert_called_once()
```

**‚ùì Perch√© √® un problema:**

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

**üìù Descrizione:**

### Why is this an issue?

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

---

### Riga 49 üü° üü° MAJOR

**üéØ Problema:** Either remove or fill this block of code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S108` - Nested blocks of code should not be left empty |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     47: 
     48:         async with lifespan(app):
 >>> 49:             pass
     50: 
     51:         assert app.state.startup_error == "Fatal Lock"
```

**‚ùì Perch√© √® un problema:**

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

**üìù Descrizione:**

### Why is this an issue?

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

---

### Riga 60 üü° üü° MAJOR

**üéØ Problema:** Either remove or fill this block of code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S108` - Nested blocks of code should not be left empty |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     58: 
     59:         async with lifespan(app):
 >>> 60:             pass
     61: 
     62:         # Should not set startup_error (allows UI to load)
```

**‚ùì Perch√© √® un problema:**

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

**üìù Descrizione:**

### Why is this an issue?

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

---

### Riga 73 üü° üü° MAJOR

**üéØ Problema:** Either remove or fill this block of code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S108` - Nested blocks of code should not be left empty |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     71:         # Should catch and continue
     72:         async with lifespan(app):
 >>> 73:             pass
     74: 
     75: @pytest.mark.anyio
```

**‚ùì Perch√© √® un problema:**

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

**üìù Descrizione:**

### Why is this an issue?

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

---

### Riga 85 üü° üü° MAJOR

**üéØ Problema:** Either remove or fill this block of code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S108` - Nested blocks of code should not be left empty |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     83: 
     84:         async with lifespan(app):
 >>> 85:             pass
     86:         # Should not raise
     87: 
```

**‚ùì Perch√© √® un problema:**

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

**üìù Descrizione:**

### Why is this an issue?

An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.

```
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
 pass
```

Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.

#### Exceptions

The rule ignores code blocks that contain comments.

---

## üìÑ `guide_frontend/src/pages/Glossary.jsx`
**5 issue(s)** | Effort: 9min

### Riga 3 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Note'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 7-11 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
     2: import GuideCard from '../components/ui/GuideCard';
 >>> 3: import Note from '../components/ui/Note';
     4: import { Book, Tag, Hash, FileQuestion } from 'lucide-react';
     5: 
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Tag'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 15-18 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     2: import GuideCard from '../components/ui/GuideCard';
     3: import Note from '../components/ui/Note';
 >>> 4: import { Book, Tag, Hash, FileQuestion } from 'lucide-react';
     5: 
     6: const Glossary = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Hash'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 20-24 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     2: import GuideCard from '../components/ui/GuideCard';
     3: import Note from '../components/ui/Note';
 >>> 4: import { Book, Tag, Hash, FileQuestion } from 'lucide-react';
     5: 
     6: const Glossary = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'FileQuestion'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 26-38 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     2: import GuideCard from '../components/ui/GuideCard';
     3: import Note from '../components/ui/Note';
 >>> 4: import { Book, Tag, Hash, FileQuestion } from 'lucide-react';
     5: 
     6: const Glossary = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 53 üü° üü° MAJOR

**üéØ Problema:** Do not use Array index in keys

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6479` - JSX list components should not use array indexes as key |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 28-31 |
| Tags | jsx, performance, react |

**üíª Codice attuale:**
```jsx
     51:       &lt;div className="grid grid-cols-1 gap-6"&gt;
     52:         {terms.map((item, idx) =&gt; (
 >>> 53:             &lt;GuideCard key={idx} className="hover:border-blue-300 transition-colors group"&gt;
     54:                 &lt;h3 className="text-lg font-bold text-gray-900 mb-2 flex items-center gap-2 group-hover:text-blue-700"&gt;
     55:                     &lt;Book size={18} className="text-gray-400 group-hover:text-blue-500"/&gt;
```

**‚ùì Perch√© √® un problema:**

To optimize the rendering of React list components, a unique identifier (UID) is required for each list item. This UID lets React identify the item
throughout its lifetime. Avoid array indexes since the order of the items may change, which will cause keys to not match up between renders,
recreating the DOM. It can negatively impact performance and may cause issues with the component state.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((post, index) =&gt;
 &lt;li key={index}&gt; &lt;!-- Noncompliant: When 'posts' are reordered, React will need to recreate the list DOM --&gt;
 {post.title}
 &lt;/li&gt;
 )}
 &lt;/ul&gt;
 );
}
```

To fix it, use a string or a number that uniquely identifies the list item. The key must be unique among its siblings, not globally.

If the data comes from a database, database IDs are already unique and are the best option. Otherwise, use a counter or a UUID generator.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((p...

**üìù Descrizione:**

### Why is this an issue?

To optimize the rendering of React list components, a unique identifier (UID) is required for each list item. This UID lets React identify the item
throughout its lifetime. Avoid array indexes since the order of the items may change, which will cause keys to not match up between renders,
recreating the DOM. It can negatively impact performance and may cause issues with the component state.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((post, index) =&gt;
 &lt;li key={index}&gt; &lt;!-- Noncompliant: When 'posts' are reordered, React will need to recreate the list DOM --&gt;
 {post.title}
 &lt;/li&gt;
 )}
 &lt;/ul&gt;
 );
}
```

To fix it, use a string or a number that uniquely identifies the list item. The key must be unique among its siblings, not globally.

If the data comes from a database, database IDs are already unique and are the best option. Otherwise, use a counter or a UUID generator.

```
function Blog(props) {
 return (
 &lt;...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [no-array-index-key](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/no-array-index-key.md) 

 - React Documentation - [Rendering lists](https://react.dev/learn/rendering-lists#rules-of-keys) 

 - React Documentation - [Recursing On Children](https://reactjs.org/docs/reconciliation.html#recursing-on-children) 

 - MDN web docs - [Crypto: randomUUID() method](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID) 

 - Wikipedia - [UUID](https://en.wikipedia....

---

## üìÑ `desktop_app/services/license_updater_service.py`
**5 issue(s)** | Effort: 34min

### Riga 53 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 19 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 9min |
| Posizione | Colonne 8-22 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     51:         return sha256_hash.hexdigest()
     52: 
 >>> 53:     def update_license(self, hardware_id):
     54:         try:
     55:             config = self._load_config()
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 85 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "manifest.json" 4 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 8min |
| Posizione | Colonne 66-81 |
| Tags | design |

**üíª Codice attuale:**
```python
     83: 
     84:             # Confronta con il manifest locale, se esiste
 >>> 85:             local_manifest_path = os.path.join(get_license_dir(), "manifest.json")
     86:             if os.path.exists(local_manifest_path):
     87:                 with open(local_manifest_path, 'r') as f:
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 99 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "pyarmor.rkey" 4 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 8min |
| Posizione | Colonne 37-51 |
| Tags | design |

**üíª Codice attuale:**
```python
     97: 
     98:                 # Scarica gli altri file
 >>> 99:                 files_to_download = ["pyarmor.rkey", "config.dat"]
     100:                 for filename in files_to_download:
     101:                     file_api_url = f"{api_url}/{filename}"
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 99 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "config.dat" 4 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 8min |
| Posizione | Colonne 53-65 |
| Tags | design |

**üíª Codice attuale:**
```python
     97: 
     98:                 # Scarica gli altri file
 >>> 99:                 files_to_download = ["pyarmor.rkey", "config.dat"]
     100:                 for filename in files_to_download:
     101:                     file_api_url = f"{api_url}/{filename}"
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 144 üü° üü° MAJOR

**üéØ Problema:** Add replacement fields or use a normal string instead of an f-string.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3457` - String formatting should be used correctly |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 26-105 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     142:             elif e.response.status_code == 401 or e.response.status_code == 403:
     143:                 return False, "Errore di autenticazione: Accesso non autorizzato. Contattare il supporto."
 >>> 144:             return False, f"Errore di rete durante il download della licenza. Verificare la connessione."
     145:         except (ValueError, KeyError) as e:
     146:             return False, f"Errore di validazione: {e}"
```

**‚ùì Perch√© √® un problema:**

A format string is a string that contains placeholders, usually represented by special characters such as "%s" or "{}", depending on the technology
in use. These placeholders are replaced by values when the string is printed or logged. Thus, it is required that a string is valid and arguments
match replacement fields in this string.

This applies to [the % operator](https://docs.python.org/3/tutorial/inputoutput.html#old-string-formatting), the [str.format](https://docs.python.org/3/tutorial/inputoutput.html#the-string-format-method) method, and loggers from the [logging](https://docs.python.org/3/library/logging.html) module. Internally, the latter use the `%-formatting`. The only
difference is that they will log an error instead of raising an exception when the provided arguments are invalid.

Formatted string literals (also called "f-strings"; available since Python 3.6) are generally simpler to use, and any syntax mistake will cause a
failure at compile time. However, it is easy to...

**‚úÖ Come risolvere:**

A `printf-`-style format string is a string that contains placeholders, which are replaced by values when the string is printed or
logged. Mismatch in the format specifiers and the arguments provided can lead to incorrect strings being created.

To avoid issues, a developer should ensure that the provided arguments match format specifiers.

##### Noncompliant code example

```
"Error %(message)s" % {"message": "something failed", "extra": "some dead code"} # Noncompliant. Remove the unused argument "extra" or add a replacement field.

"Error: User {} has not been able to access []".format("Alice", "MyFile") # Noncompliant. Remove 1 unexpected argument or add a replacement field.

user = "Alice"
resource = "MyFile"
message = f"Error: User [user] has not been able to access [resource]" # Noncompliant. Add replacement fields or use a normal string instead of an f-string.

import logging
logging.error("Error: User %s has not been able to access %s", "Alice") # Noncompliant. Add 1 missing argument.
```

##### Compliant solution

```
"Error %(message)s" % {"message": "something failed"}

"Error: User {} has not been able to access {}".format("Alice", "MyFile")

user = "Alice"
resource = "MyFile"
message = f"Error: User {user} has not been able to access {resource}"

import logging
logging.error("Error: User %s has not been able to access %s", "Alice", "MyFile")
```

**üìö Risorse:**

- [Python documentation - Format String Syntax](https://docs.python.org/3/library/string.html#format-string-syntax) 

 - Python documentation - printf-style String
 Formatting 

 - [Python documentation - Loggers](https://docs.python.org/3/howto/logging.html#loggers) 

 - Python
 documentation - Using particular formatting styles throughout your application 

 - Python documentation - Formatted string
 literals

---

## üìÑ `tests/desktop_app/views/test_import_view_advanced.py`
**4 issue(s)** | Effort: 14min

### Riga 21 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-21 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     19:     def __init__(self, parent=None):
     20:         super().__init__(parent)
 >>> 21:     def setFrameShape(self, shape): pass
     22:     def setFrameShadow(self, shadow): pass
     23:     class Shape: StyledPanel=1
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 22 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-22 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     20:         super().__init__(parent)
     21:     def setFrameShape(self, shape): pass
 >>> 22:     def setFrameShadow(self, shadow): pass
     23:     class Shape: StyledPanel=1
     24:     class Shadow: Sunken=1
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 23 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "StyledPanel" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 17-28 |
| Tags | convention |

**üíª Codice attuale:**
```python
     21:     def setFrameShape(self, shape): pass
     22:     def setFrameShadow(self, shadow): pass
 >>> 23:     class Shape: StyledPanel=1
     24:     class Shadow: Sunken=1
     25: 
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

### Riga 24 üü° üü¢ MINOR

**üéØ Problema:** Rename this field "Sunken" to match the regular expression ^[_a-z][_a-z0-9]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S116` - Field names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 18-24 |
| Tags | convention |

**üíª Codice attuale:**
```python
     22:     def setFrameShadow(self, shadow): pass
     23:     class Shape: StyledPanel=1
 >>> 24:     class Shadow: Sunken=1
     25: 
     26: mock_qt.QFrame = DummyFrame
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

**üìù Descrizione:**

### Why is this an issue?

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.

The goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures
consistency in the code, especially when multiple developers are working on the same project.

This rule checks that field names match a provided regular expression.

Using the regular expression `^[_a-z][_a-z0-9]*$`, the noncompliant code below:

```
class MyClass:
 myField = 1
```

Should be replaced with:

```
class MyClass:
 my_field = 1
```

### Resources

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming))

---

## üìÑ `app/services/ai_extraction.py`
**4 issue(s)** | Effort: 31min

### Riga 163 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 26 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 16min |
| Posizione | Colonne 4-23 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     161:         return model.generate_content([pdf_file_part, prompt])
     162: 
 >>> 163: def _extract_json_block(text: str) -&gt; str:
     164:     """
     165:     Robustly extracts the first valid JSON block from text, handling nested structures.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 185 üü° üü° MAJOR

**üéØ Problema:** Merge this if statement with the enclosing one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1066` - Mergeable "if" statements should be combined |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 12-14 |
| Tags | clumsy |

**üíª Codice attuale:**
```python
     183:             stack.append(char)
     184:         elif char == '}' or char == ']':
 >>> 185:             if stack:
     186:                 last = stack[-1]
     187:                 if (last == '{' and char == '}') or (last == '[' and char == ']'):
```

**‚ùì Perch√© √® un problema:**

Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.

Merging `if` statements when possible will decrease the nesting of the code and improve its readability.

Code like

```
if condition1:
 if condition2: # Noncompliant
 # ...
```

Will be more readable as

```
if condition1 and condition2: # Compliant
 # ...
```

**‚úÖ Come risolvere:**

If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.

##### Noncompliant code example

```
if file.isValid():
 if file.isfile() or file.isdir(): # Noncompliant
 # ...
```

##### Compliant solution

```
def isFileOrDirectory(File file):
 return file.isFile() or file.isDirectory()

if file.isValid() and isFileOrDirectory(file): # Compliant
 # ...
```

---

### Riga 240 üü° üü° MAJOR

**üéØ Problema:** Remove this commented out code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S125` - Sections of code should not be commented out |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-53 |
| Tags | unused |

**üíª Codice attuale:**
```python
     238:         # Actually, if we allow dynamic, we don't need this block at all.
     239:         
 >>> 240:         # valid_categories = list(CATEGORIE_STATICHE)
     241:         # if "ATEX" not in valid_categories:
     242:         #     valid_categories.append("ATEX")
```

**‚ùì Perch√© √® un problema:**

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

**üìù Descrizione:**

### Why is this an issue?

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

---

### Riga 244 üü° üü° MAJOR

**üéØ Problema:** Remove this commented out code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S125` - Sections of code should not be commented out |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-55 |
| Tags | unused |

**üíª Codice attuale:**
```python
     242:         #     valid_categories.append("ATEX")
     243: 
 >>> 244:         # if data["categoria"] not in valid_categories:
     245:         #     logging.warning(f"Invalid category '{data['categoria']}'. Defaulting to 'ALTRO'.")
     246:         #     data["categoria"] = "ALTRO"
```

**‚ùì Perch√© √® un problema:**

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

**üìù Descrizione:**

### Why is this an issue?

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

---

## üìÑ `guide_frontend/src/pages/ImportGuide.jsx`
**4 issue(s)** | Effort: 4min

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Step'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 7-11 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     2: import GuideCard from '../components/ui/GuideCard';
     3: import Note from '../components/ui/Note';
 >>> 4: import Step from '../components/ui/Step';
     5: import ImportSimulator from '../components/ImportSimulator';
     6: import { UploadCloud, FolderOpen, AlertTriangle } from 'lucide-react';
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 6 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'AlertTriangle'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 34-47 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     4: import Step from '../components/ui/Step';
     5: import ImportSimulator from '../components/ImportSimulator';
 >>> 6: import { UploadCloud, FolderOpen, AlertTriangle } from 'lucide-react';
     7: 
     8: const ImportGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 6 üü° üü¢ MINOR

**üéØ Problema:** 'lucide-react' imported multiple times.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S3863` - Imports from the same module should be merged |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 55-69 |
| Tags | es2015 |

**üíª Codice attuale:**
```jsx
     4: import Step from '../components/ui/Step';
     5: import ImportSimulator from '../components/ImportSimulator';
 >>> 6: import { UploadCloud, FolderOpen, AlertTriangle } from 'lucide-react';
     7: 
     8: const ImportGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Having the same module imported multiple times can affect code readability and maintainability. It makes hard to identify which modules are being
used.

```
import { B1 } from 'b';
import { B2 } from 'b'; // Noncompliant: there is already an import from module 'b'.
```

Instead, one should consolidate the imports from the same module into a single statement. By consolidating all imports from the same module in a
single `import` statement, the code becomes more concise and easier to read, as there is only one import statement to keep track of.
Additionally, it can make it easier to identify which modules are used in the code.

```
import { B1, B2 } from 'b';
```

**üìù Descrizione:**

### Why is this an issue?

Having the same module imported multiple times can affect code readability and maintainability. It makes hard to identify which modules are being
used.

```
import { B1 } from 'b';
import { B2 } from 'b'; // Noncompliant: there is already an import from module 'b'.
```

Instead, one should consolidate the imports from the same module into a single statement. By consolidating all imports from the same module in a
single `import` statement, the code becomes more concise and easier to read, as there is only one import statement to keep track of.
Additionally, it can make it easier to identify which modules are used in the code.

```
import { B1, B2 } from 'b';
```

### Resources

#### Documentation

 - [eslint-plugin-import](https://github.com/import-js/eslint-plugin-import) - Rule [no-duplicates](https://github.com/import-js/eslint-plugin-import/blob/HEAD/docs/rules/no-duplicates.md) 

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/Ja...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-import](https://github.com/import-js/eslint-plugin-import) - Rule [no-duplicates](https://github.com/import-js/eslint-plugin-import/blob/HEAD/docs/rules/no-duplicates.md) 

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

 - MDN web docs - [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)

---

### Riga 89 üü° üü¢ MINOR

**üéØ Problema:** 'lucide-react' imported multiple times.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S3863` - Imports from the same module should be merged |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 25-39 |
| Tags | es2015 |

**üíª Codice attuale:**
```jsx
     87: };
     88: 
 >>> 89: import { FileText } from 'lucide-react'; // Fix missing import for icon used in GuideCard
     90: export default ImportGuide;
     91: 
```

**‚ùì Perch√© √® un problema:**

Having the same module imported multiple times can affect code readability and maintainability. It makes hard to identify which modules are being
used.

```
import { B1 } from 'b';
import { B2 } from 'b'; // Noncompliant: there is already an import from module 'b'.
```

Instead, one should consolidate the imports from the same module into a single statement. By consolidating all imports from the same module in a
single `import` statement, the code becomes more concise and easier to read, as there is only one import statement to keep track of.
Additionally, it can make it easier to identify which modules are used in the code.

```
import { B1, B2 } from 'b';
```

**üìù Descrizione:**

### Why is this an issue?

Having the same module imported multiple times can affect code readability and maintainability. It makes hard to identify which modules are being
used.

```
import { B1 } from 'b';
import { B2 } from 'b'; // Noncompliant: there is already an import from module 'b'.
```

Instead, one should consolidate the imports from the same module into a single statement. By consolidating all imports from the same module in a
single `import` statement, the code becomes more concise and easier to read, as there is only one import statement to keep track of.
Additionally, it can make it easier to identify which modules are used in the code.

```
import { B1, B2 } from 'b';
```

### Resources

#### Documentation

 - [eslint-plugin-import](https://github.com/import-js/eslint-plugin-import) - Rule [no-duplicates](https://github.com/import-js/eslint-plugin-import/blob/HEAD/docs/rules/no-duplicates.md) 

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/Ja...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-import](https://github.com/import-js/eslint-plugin-import) - Rule [no-duplicates](https://github.com/import-js/eslint-plugin-import/blob/HEAD/docs/rules/no-duplicates.md) 

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

 - MDN web docs - [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)

---

## üìÑ `guide_frontend/src/pages/SecurityGuide.jsx`
**4 issue(s)** | Effort: 4min

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** 'lucide-react' imported multiple times.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S3863` - Imports from the same module should be merged |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 65-79 |
| Tags | es2015 |

**üíª Codice attuale:**
```jsx
     2: import GuideCard from '../components/ui/GuideCard';
     3: import Note from '../components/ui/Note';
 >>> 4: import { Shield, Lock, Eye, Key, FileWarning, Fingerprint } from 'lucide-react';
     5: 
     6: const SecurityGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Having the same module imported multiple times can affect code readability and maintainability. It makes hard to identify which modules are being
used.

```
import { B1 } from 'b';
import { B2 } from 'b'; // Noncompliant: there is already an import from module 'b'.
```

Instead, one should consolidate the imports from the same module into a single statement. By consolidating all imports from the same module in a
single `import` statement, the code becomes more concise and easier to read, as there is only one import statement to keep track of.
Additionally, it can make it easier to identify which modules are used in the code.

```
import { B1, B2 } from 'b';
```

**üìù Descrizione:**

### Why is this an issue?

Having the same module imported multiple times can affect code readability and maintainability. It makes hard to identify which modules are being
used.

```
import { B1 } from 'b';
import { B2 } from 'b'; // Noncompliant: there is already an import from module 'b'.
```

Instead, one should consolidate the imports from the same module into a single statement. By consolidating all imports from the same module in a
single `import` statement, the code becomes more concise and easier to read, as there is only one import statement to keep track of.
Additionally, it can make it easier to identify which modules are used in the code.

```
import { B1, B2 } from 'b';
```

### Resources

#### Documentation

 - [eslint-plugin-import](https://github.com/import-js/eslint-plugin-import) - Rule [no-duplicates](https://github.com/import-js/eslint-plugin-import/blob/HEAD/docs/rules/no-duplicates.md) 

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/Ja...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-import](https://github.com/import-js/eslint-plugin-import) - Rule [no-duplicates](https://github.com/import-js/eslint-plugin-import/blob/HEAD/docs/rules/no-duplicates.md) 

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

 - MDN web docs - [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)

---

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Shield'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 9-15 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     2: import GuideCard from '../components/ui/GuideCard';
     3: import Note from '../components/ui/Note';
 >>> 4: import { Shield, Lock, Eye, Key, FileWarning, Fingerprint } from 'lucide-react';
     5: 
     6: const SecurityGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 4 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Fingerprint'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 46-57 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     2: import GuideCard from '../components/ui/GuideCard';
     3: import Note from '../components/ui/Note';
 >>> 4: import { Shield, Lock, Eye, Key, FileWarning, Fingerprint } from 'lucide-react';
     5: 
     6: const SecurityGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 92 üü° üü¢ MINOR

**üéØ Problema:** 'lucide-react' imported multiple times.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S3863` - Imports from the same module should be merged |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 20-34 |
| Tags | es2015 |

**üíª Codice attuale:**
```jsx
     90: };
     91: 
 >>> 92: import { Zap } from 'lucide-react'; // Fix missing import
     93: export default SecurityGuide;
     94: 
```

**‚ùì Perch√© √® un problema:**

Having the same module imported multiple times can affect code readability and maintainability. It makes hard to identify which modules are being
used.

```
import { B1 } from 'b';
import { B2 } from 'b'; // Noncompliant: there is already an import from module 'b'.
```

Instead, one should consolidate the imports from the same module into a single statement. By consolidating all imports from the same module in a
single `import` statement, the code becomes more concise and easier to read, as there is only one import statement to keep track of.
Additionally, it can make it easier to identify which modules are used in the code.

```
import { B1, B2 } from 'b';
```

**üìù Descrizione:**

### Why is this an issue?

Having the same module imported multiple times can affect code readability and maintainability. It makes hard to identify which modules are being
used.

```
import { B1 } from 'b';
import { B2 } from 'b'; // Noncompliant: there is already an import from module 'b'.
```

Instead, one should consolidate the imports from the same module into a single statement. By consolidating all imports from the same module in a
single `import` statement, the code becomes more concise and easier to read, as there is only one import statement to keep track of.
Additionally, it can make it easier to identify which modules are used in the code.

```
import { B1, B2 } from 'b';
```

### Resources

#### Documentation

 - [eslint-plugin-import](https://github.com/import-js/eslint-plugin-import) - Rule [no-duplicates](https://github.com/import-js/eslint-plugin-import/blob/HEAD/docs/rules/no-duplicates.md) 

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/Ja...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-import](https://github.com/import-js/eslint-plugin-import) - Rule [no-duplicates](https://github.com/import-js/eslint-plugin-import/blob/HEAD/docs/rules/no-duplicates.md) 

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

 - MDN web docs - [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)

---

## üìÑ `admin/crea_licenze/admin_license_gui.py`
**4 issue(s)** | Effort: 31min

### Riga 32 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Segoe UI" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 40-50 |
| Tags | design |

**üíª Codice attuale:**
```python
     30:         style = ttk.Style()
     31:         style.theme_use('clam')
 >>> 32:         style.configure("TLabel", font=("Segoe UI", 10))
     33:         style.configure("TButton", font=("Segoe UI", 10, "bold"))
     34: 
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 69 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     67:             self.ent_disk.delete(0, tk.END)
     68:             self.ent_disk.insert(0, self.root.clipboard_get().strip())
 >>> 69:         except: pass
     70: 
     71:     def generate(self):
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 71 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 24 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 14min |
| Posizione | Colonne 8-16 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     69:         except: pass
     70: 
 >>> 71:     def generate(self):
     72:         disk_serial = self.ent_disk.get().strip()
     73:         client_name = self.ent_name.get().strip()
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 102 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "pyarmor.rkey" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 51-65 |
| Tags | design |

**üíª Codice attuale:**
```python
     100:             if res.returncode == 0:
     101:                 # PyArmor di default mette l'output in "dist/pyarmor.rkey" relativo alla CWD
 >>> 102:                 src_default = os.path.join("dist", "pyarmor.rkey")
     103:                 
     104:                 if os.path.exists(src_default):
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

## üìÑ `tests/desktop_app/test_api_client.py`
**3 issue(s)** | Effort: 15min

### Riga 76 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "args" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-12 |
| Tags | unused |

**üíª Codice attuale:**
```python
     74:         assert data == {"data": "test"}
     75:         # Check header contains Auth
 >>> 76:         args, kwargs = mock_get.call_args
     77:         assert kwargs['headers']['Authorization'] == "Bearer fake_token"
     78: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 90 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "args" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-12 |
| Tags | unused |

**üíª Codice attuale:**
```python
     88:         
     89:         assert data == {"id": 1}
 >>> 90:         args, kwargs = mock_post.call_args
     91:         assert kwargs['json'] == {"nome": "test"}
     92: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 116 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "args" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 16-20 |
| Tags | unused |

**üíª Codice attuale:**
```python
     114:                 
     115:                 assert result["status"] == "ok"
 >>> 116:                 args, kwargs = mock_post.call_args
     117:                 assert 'files' in kwargs
     118: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `app/db/seeding.py`
**3 issue(s)** | Effort: 41min

### Riga 13 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 26 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 16min |
| Posizione | Colonne 4-18 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     11: from datetime import datetime
     12: 
 >>> 13: def migrate_schema(db: Session):
     14:     """
     15:     Checks for missing columns in existing tables (due to lack of migrations)
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 123 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 33 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 23min |
| Posizione | Colonne 4-27 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     121:         raise # Critical failure
     122: 
 >>> 123: def cleanup_deprecated_data(db: Session):
     124:     """
     125:     Removes data related to deprecated categories like 'MEDICO COMPETENTE'.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 246 üü° üü¢ MINOR

**üéØ Problema:** Use the opposite operator ("!=") instead.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1940` - Boolean checks should not be inverted |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 15-90 |
| Tags | pitfall |

**üíª Codice attuale:**
```python
     244:             # Bug 1 Fix: Ensure password matches settings
     245:             current_admin_password = settings.FIRST_RUN_ADMIN_PASSWORD
 >>> 246:             if not get_password_hash(current_admin_password) == admin_user.hashed_password: # Simple check wont work with salt
     247:                 # Verify properly
     248:                 from app.core.security import verify_password
```

**‚ùì Perch√© √® un problema:**

It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.

#### Noncompliant code example

```
if not a == 2: # Noncompliant
 b = not i &lt; 10 # Noncompliant
```

#### Compliant solution

```
if a != 2 :
 b = i &gt;= 10
```

**üìù Descrizione:**

### Why is this an issue?

It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.

#### Noncompliant code example

```
if not a == 2: # Noncompliant
 b = not i &lt; 10 # Noncompliant
```

#### Compliant solution

```
if a != 2 :
 b = i &gt;= 10
```

---

## üìÑ `app/services/chat_service.py`
**3 issue(s)** | Effort: 19min

### Riga 15 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     13: 
     14: class ChatService:
 >>> 15:     def __init__(self):
     16:         pass
     17: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 18 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 19 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 9min |
| Posizione | Colonne 8-23 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     16:         pass
     17: 
 >>> 18:     def get_rag_context(self, db: Session, user: User) -&gt; str:
     19:         """
     20:         Retrieves context from the database to ground the AI.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 99 üü° üü° MAJOR

**üéØ Problema:** Merge this if statement with the enclosing one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1066` - Mergeable "if" statements should be combined |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 13-15 |
| Tags | clumsy |

**üíª Codice attuale:**
```python
     97: 
     98:         if not api_key or "obf:" in api_key:
 >>> 99:              if not api_key:
     100:                  return "Errore: Chiave API Chat non configurata."
     101: 
```

**‚ùì Perch√© √® un problema:**

Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.

Merging `if` statements when possible will decrease the nesting of the code and improve its readability.

Code like

```
if condition1:
 if condition2: # Noncompliant
 # ...
```

Will be more readable as

```
if condition1 and condition2: # Compliant
 # ...
```

**‚úÖ Come risolvere:**

If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.

##### Noncompliant code example

```
if file.isValid():
 if file.isfile() or file.isdir(): # Noncompliant
 # ...
```

##### Compliant solution

```
def isFileOrDirectory(File file):
 return file.isFile() or file.isDirectory()

if file.isValid() and isFileOrDirectory(file): # Compliant
 # ...
```

---

## üìÑ `desktop_app/views/validation_view.py`
**3 issue(s)** | Effort: 21min

### Riga 139 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Database in sola lettura" 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 40-66 |
| Tags | design |

**üíª Codice attuale:**
```python
     137:             self.validate_button.setEnabled(False)
     138:             self.delete_button.setEnabled(False)
 >>> 139:             self.edit_button.setToolTip("Database in sola lettura")
     140:             self.validate_button.setToolTip("Database in sola lettura")
     141:             self.delete_button.setToolTip("Database in sola lettura")
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 172 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 13-19 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     170:                  if first_row &lt; len(self.df):
     171:                      return {'mode': 'reselect_by_id', 'id': self.df.iloc[first_row]['id'], 'fallback_row': first_row}
 >>> 172:              except:
     173:                  pass
     174: 
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 246 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 20 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 8-23 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     244:         self._on_data_loaded([])
     245: 
 >>> 246:     def _on_data_loaded(self, data):
     247:         if not data:
     248:             self.df = pd.DataFrame()
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `app/services/notification_service.py`
**3 issue(s)** | Effort: 35min

### Riga 37 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     35:         try:
     36:             self.image('desktop_app/assets/logo.png', 10, 8, 45)
 >>> 37:         except:
     38:             pass # Skip logo if missing to prevent crash
     39:         self.set_font('Arial', 'B', 15)
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 50 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 30 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 20min |
| Posizione | Colonne 4-33 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     48:         self.cell(0, 10, 'Pagina ' + str(self.page_no()) + '/{nb}', 0, 0, 'R')
     49: 
 >>> 50: def generate_pdf_report_in_memory(expiring_visite, expiring_corsi, overdue_certificates, visite_threshold, corsi_threshold):
     51:     """Generates a professional, multi-table PDF report with pagination logic."""
     52:     try:
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 262 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 20 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 4-19 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     260:         logging.error(f"Failed to send security alert: {e}")
     261: 
 >>> 262: def get_report_data(db: Session):
     263:     today = date.today()
     264:     expiring_visite = []
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `desktop_app/views/database_view.py`
**3 issue(s)** | Effort: 13min

### Riga 225 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 17 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 7min |
| Posizione | Colonne 8-26 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     223:         self._update_button_states()
     224: 
 >>> 225:     def _update_table_view(self):
     226:         df = self.view_model.filtered_data
     227: 
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 230 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     228:         if self.table_view.model() and self.table_view.selectionModel():
     229:             try: self.table_view.selectionModel().selectionChanged.disconnect(self._update_button_states)
 >>> 230:             except: pass
     231: 
     232:         if not df.empty:
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 412 üü° üü° MAJOR

**üéØ Problema:** Add replacement fields or use a normal string instead of an f-string.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3457` - String formatting should be used correctly |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 62-93 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     410:             try:
     411:                 self.model._data.to_csv(path, index=False)
 >>> 412:                 ToastManager.success("Esportazione Riuscita", f"Dati esportati con successo.", self.window())
     413:             except Exception as e:
     414:                 self._show_error_message(f"Impossibile salvare il file: {e}")
```

**‚ùì Perch√© √® un problema:**

A format string is a string that contains placeholders, usually represented by special characters such as "%s" or "{}", depending on the technology
in use. These placeholders are replaced by values when the string is printed or logged. Thus, it is required that a string is valid and arguments
match replacement fields in this string.

This applies to [the % operator](https://docs.python.org/3/tutorial/inputoutput.html#old-string-formatting), the [str.format](https://docs.python.org/3/tutorial/inputoutput.html#the-string-format-method) method, and loggers from the [logging](https://docs.python.org/3/library/logging.html) module. Internally, the latter use the `%-formatting`. The only
difference is that they will log an error instead of raising an exception when the provided arguments are invalid.

Formatted string literals (also called "f-strings"; available since Python 3.6) are generally simpler to use, and any syntax mistake will cause a
failure at compile time. However, it is easy to...

**‚úÖ Come risolvere:**

A `printf-`-style format string is a string that contains placeholders, which are replaced by values when the string is printed or
logged. Mismatch in the format specifiers and the arguments provided can lead to incorrect strings being created.

To avoid issues, a developer should ensure that the provided arguments match format specifiers.

##### Noncompliant code example

```
"Error %(message)s" % {"message": "something failed", "extra": "some dead code"} # Noncompliant. Remove the unused argument "extra" or add a replacement field.

"Error: User {} has not been able to access []".format("Alice", "MyFile") # Noncompliant. Remove 1 unexpected argument or add a replacement field.

user = "Alice"
resource = "MyFile"
message = f"Error: User [user] has not been able to access [resource]" # Noncompliant. Add replacement fields or use a normal string instead of an f-string.

import logging
logging.error("Error: User %s has not been able to access %s", "Alice") # Noncompliant. Add 1 missing argument.
```

##### Compliant solution

```
"Error %(message)s" % {"message": "something failed"}

"Error: User {} has not been able to access {}".format("Alice", "MyFile")

user = "Alice"
resource = "MyFile"
message = f"Error: User {user} has not been able to access {resource}"

import logging
logging.error("Error: User %s has not been able to access %s", "Alice", "MyFile")
```

**üìö Risorse:**

- [Python documentation - Format String Syntax](https://docs.python.org/3/library/string.html#format-string-syntax) 

 - Python documentation - printf-style String
 Formatting 

 - [Python documentation - Loggers](https://docs.python.org/3/howto/logging.html#loggers) 

 - Python
 documentation - Using particular formatting styles throughout your application 

 - Python documentation - Formatted string
 literals

---

## üìÑ `app/core/db_security.py`
**3 issue(s)** | Effort: 24min

### Riga 84 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 24 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 14min |
| Posizione | Colonne 8-37 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     82:         return base64.urlsafe_b64encode(digest)
     83: 
 >>> 84:     def _check_and_recover_stale_lock(self):
     85:         """
     86:         Detects if a lock file exists but belongs to a dead process.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 108 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     106:                 try:
     107:                     metadata = json.loads(data.decode('utf-8'))
 >>> 108:                 except:
     109:                     # Corrupt JSON -&gt; Force Clean
     110:                     should_remove = True
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 350 üü° üü¢ MINOR

**üéØ Problema:** Add logic to this except clause or eliminate it and rethrow the exception automatically.

| Campo | Valore |
|-------|--------|
| Regola | `python:S2737` - "except" clauses should do more than raise the same issue |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 16-21 |
| Tags | clumsy, error-handling, finding, unused |

**üíª Codice attuale:**
```python
     348:                 os.replace(swp_path, self.db_path)
     349:             except PermissionError:
 >>> 350:                 raise
     351:         else:
     352:             os.replace(swp_path, self.db_path)
```

**‚ùì Perch√© √® un problema:**

An `except` clause that only rethrows the caught exception has the same effect as omitting the `except` altogether and
letting it bubble up automatically.

```
a = {}
try:
 a[5]
except KeyError:
 raise # Noncompliant
```

Such clauses should either be removed or populated with the appropriate logic.

```
a = {}
try:
 a[5]
except KeyError as e:
 logging.exception('error while accessing the dict')
 raise e
```

**üìù Descrizione:**

### Why is this an issue?

An `except` clause that only rethrows the caught exception has the same effect as omitting the `except` altogether and
letting it bubble up automatically.

```
a = {}
try:
 a[5]
except KeyError:
 raise # Noncompliant
```

Such clauses should either be removed or populated with the appropriate logic.

```
a = {}
try:
 a[5]
except KeyError as e:
 logging.exception('error while accessing the dict')
 raise e
```

---

## üìÑ `desktop_app/views/anagrafica_view.py`
**3 issue(s)** | Effort: 14min

### Riga 15 üü° üü° MAJOR

**üéØ Problema:** Add replacement fields or use a normal string instead of an f-string.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3457` - String formatting should be used correctly |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 27-11 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     13:     def __init__(self, title, value, color="#3B82F6", parent=None):
     14:         super().__init__(parent)
 >>> 15:         self.setStyleSheet(f"""
 >>> 16:             QFrame {{
 >>> 17:                 background-color: #FFFFFF;
 >>> 18:                 border: 1px solid #E5E7EB;
 >>> 19:                 border-radius: 8px;
 >>> 20:             }}
 >>> 21:         """)
     22:         layout = QVBoxLayout(self)
     23:         layout.setContentsMargins(15, 15, 15, 15)
```

**‚ùì Perch√© √® un problema:**

A format string is a string that contains placeholders, usually represented by special characters such as "%s" or "{}", depending on the technology
in use. These placeholders are replaced by values when the string is printed or logged. Thus, it is required that a string is valid and arguments
match replacement fields in this string.

This applies to [the % operator](https://docs.python.org/3/tutorial/inputoutput.html#old-string-formatting), the [str.format](https://docs.python.org/3/tutorial/inputoutput.html#the-string-format-method) method, and loggers from the [logging](https://docs.python.org/3/library/logging.html) module. Internally, the latter use the `%-formatting`. The only
difference is that they will log an error instead of raising an exception when the provided arguments are invalid.

Formatted string literals (also called "f-strings"; available since Python 3.6) are generally simpler to use, and any syntax mistake will cause a
failure at compile time. However, it is easy to...

**‚úÖ Come risolvere:**

A `printf-`-style format string is a string that contains placeholders, which are replaced by values when the string is printed or
logged. Mismatch in the format specifiers and the arguments provided can lead to incorrect strings being created.

To avoid issues, a developer should ensure that the provided arguments match format specifiers.

##### Noncompliant code example

```
"Error %(message)s" % {"message": "something failed", "extra": "some dead code"} # Noncompliant. Remove the unused argument "extra" or add a replacement field.

"Error: User {} has not been able to access []".format("Alice", "MyFile") # Noncompliant. Remove 1 unexpected argument or add a replacement field.

user = "Alice"
resource = "MyFile"
message = f"Error: User [user] has not been able to access [resource]" # Noncompliant. Add replacement fields or use a normal string instead of an f-string.

import logging
logging.error("Error: User %s has not been able to access %s", "Alice") # Noncompliant. Add 1 missing argument.
```

##### Compliant solution

```
"Error %(message)s" % {"message": "something failed"}

"Error: User {} has not been able to access {}".format("Alice", "MyFile")

user = "Alice"
resource = "MyFile"
message = f"Error: User {user} has not been able to access {resource}"

import logging
logging.error("Error: User %s has not been able to access %s", "Alice", "MyFile")
```

**üìö Risorse:**

- [Python documentation - Format String Syntax](https://docs.python.org/3/library/string.html#format-string-syntax) 

 - Python documentation - printf-style String
 Formatting 

 - [Python documentation - Loggers](https://docs.python.org/3/howto/logging.html#loggers) 

 - Python
 documentation - Using particular formatting styles throughout your application 

 - Python documentation - Formatted string
 literals

---

### Riga 60 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal """
            QFrame {
                background-color: #FFFFFF;
                border-radius: 12px;
                border: 1px solid #E5E7EB;
            }
        """ 3 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 33-11 |
| Tags | design |

**üíª Codice attuale:**
```python
     58:         left_panel = QFrame()
     59:         left_panel.setFixedWidth(300)
 >>> 60:         left_panel.setStyleSheet("""
 >>> 61:             QFrame {
 >>> 62:                 background-color: #FFFFFF;
 >>> 63:                 border-radius: 12px;
 >>> 64:                 border: 1px solid #E5E7EB;
 >>> 65:             }
 >>> 66:         """)
     67:         left_layout = QVBoxLayout(left_panel)
     68:         left_layout.setContentsMargins(15, 15, 15, 15)
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 416 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 17 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 7min |
| Posizione | Colonne 8-23 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     414:             QMessageBox.critical(self, "Errore", f"Impossibile caricare dettagli: {e}")
     415: 
 >>> 416:     def populate_detail(self, data):
     417:         # Header
     418:         full_name = f"{data['cognome']} {data['nome']}"
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `guide_frontend/src/pages/ValidationGuide.jsx`
**3 issue(s)** | Effort: 3min

### Riga 2 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'GuideCard'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 7-16 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
 >>> 2: import GuideCard from '../components/ui/GuideCard';
     3: import Note from '../components/ui/Note';
     4: import Step from '../components/ui/Step';
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 6 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Database'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 9-17 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     4: import Step from '../components/ui/Step';
     5: import ValidationSimulator from '../components/ValidationSimulator';
 >>> 6: import { Database, CheckCircle, AlertOctagon } from 'lucide-react';
     7: 
     8: const ValidationGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 6 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'AlertOctagon'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 32-44 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     4: import Step from '../components/ui/Step';
     5: import ValidationSimulator from '../components/ValidationSimulator';
 >>> 6: import { Database, CheckCircle, AlertOctagon } from 'lucide-react';
     7: 
     8: const ValidationGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

## üìÑ `boot_loader.py`
**3 issue(s)** | Effort: 15min

### Riga 19 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     17:             # 0x10 = MB_ICONHAND (Error icon)
     18:             ctypes.windll.user32.MessageBoxW(0, message, title, 0x10)
 >>> 19:         except:
     20:             pass # Se fallisce anche questo, non possiamo farci nulla.
     21:     else:
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 48 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 4-10 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     46:         with open("CRASH_LOG.txt", "a", encoding="utf-8") as f:
     47:             f.write(log_content)
 >>> 48:     except: pass
     49: 
     50:     # 2. Scrivi sul Desktop dell'utente (per massima visibilit√†)
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

### Riga 57 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     55:                 with open(os.path.join(desktop, "INTELLEO_CRASH_LOG.txt"), "a", encoding="utf-8") as f:
     56:                     f.write(log_content)
 >>> 57:         except: pass
     58: 
     59: def main():
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

## üìÑ `tests/desktop_app/services/test_sound_manager.py`
**2 issue(s)** | Effort: 7min

### Riga 44 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "m_gen".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 85-90 |
| Tags | unused |

**üíª Codice attuale:**
```python
     42:     def test_generate_sounds_on_init(self):
     43:         """Test that sounds are generated (cached to dict) on init."""
 >>> 44:         with patch.object(SoundManager, '_generate_wav', return_value="mock_url") as m_gen:
     45:             mgr = SoundManager()
     46:             self.assertIn('hover', mgr.sounds)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 90 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "MockWorker" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 39-49 |
| Tags | convention |

**üíª Codice attuale:**
```python
     88: 
     89:     @patch('desktop_app.services.sound_manager.SpeechWorker')
 >>> 90:     def test_speak_starts_worker(self, MockWorker):
     91:         """Test that speak method starts the SpeechWorker."""
     92:         mgr = SoundManager()
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

## üìÑ `tests/desktop_app/test_launcher_robustness.py`
**2 issue(s)** | Effort: 10min

### Riga 34 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-13 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     32:     def __init__(self, parent=None):
     33:         super().__init__()
 >>> 34:     def start(self):
     35:         pass
     36:     def wait(self):
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

### Riga 75 üü° üü° MAJOR

**üéØ Problema:** Remove this commented out code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S125` - Sections of code should not be commented out |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 85-101 |
| Tags | unused |

**üíª Codice attuale:**
```python
     73:         """Test handling when all ports are busy."""
     74:         with patch('socket.socket') as m_socket:
 >>> 75:             m_socket.return_value.__enter__.return_value.connect_ex.return_value = 0 # Success = Busy
     76:             port = launcher.find_free_port(8000, 8002)
     77:             self.assertIsNone(port)
```

**‚ùì Perch√© √® un problema:**

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

**üìù Descrizione:**

### Why is this an issue?

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

---

## üìÑ `tests/desktop_app/views/test_login_view_logic.py`
**2 issue(s)** | Effort: 20min

### Riga 29 üü° üü° MAJOR

**üéØ Problema:** Rename function "side_effect_singleShot" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1542` - Function names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 10min |
| Posizione | Colonne 16-38 |
| Tags | convention, pep |

**üíª Codice attuale:**
```python
     27: 
     28:             # Configure QTimer.singleShot to execute the callback immediately
 >>> 29:             def side_effect_singleShot(ms, callback):
     30:                 callback()
     31:             MockTimer.singleShot.side_effect = side_effect_singleShot
```

**‚ùì Perch√© √® un problema:**

Shared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.

According to PEP8, function names should be lowercase, with words separated by underscores as necessary to improve readability. This convention is
known as "snake_case." For example: `calculate_area`, `print_hello`, `process_data`

To fix this, respect the naming convention for the function. The default naming convention is snake case, as recommended by PEP8. Other naming
conventions can be defined through the `format` rule parameter.

##### Noncompliant code example

With the default provided regular expression: `^[a-z_][a-z0-9_]*$`

```
def MyFunction(a,b):
 ...
```

##### Compliant solution

```
def my_function(a,b):
 ...
```

**üìù Descrizione:**

This rule raises an issue when a function name doesn‚Äôt respect the naming convention.

### Why is this an issue?

Shared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.

According to PEP8, function names should be lowercase, with words separated by underscores as necessary to improve readability. This convention is
known as "snake_case." For example: `calculate_area`, `print_hello`, `process_data`

To fix this, respect the naming convention for the function. The default naming convention is snake case, as recommended by PEP8. Other naming
conventions can be defined through the `format` rule parameter.

#### Code examples

##### Noncompliant code example

With the default provided regular expression: `^[a-z_][a-z0-9_]*$`

```
def MyFunction(a,b):
 ...
```

##### Compliant solution

```
def my_function(a,b):
 ...
```

### Resources

#### Documentation

 - PEP8 - [Function and Variable Names](https://...

**üìö Risorse:**

#### Documentation

 - PEP8 - [Function and Variable Names](https://peps.python.org/pep-0008/#function-and-variable-names)

---

### Riga 124 üü° üü° MAJOR

**üéØ Problema:** Rename function "side_effect_singleShot" to match the regular expression ^[a-z_][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1542` - Function names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 10min |
| Posizione | Colonne 16-38 |
| Tags | convention, pep |

**üíª Codice attuale:**
```python
     122: 
     123:             # Configure QTimer to run callback immediately
 >>> 124:             def side_effect_singleShot(ms, callback):
     125:                 callback()
     126:             MockTimer.singleShot.side_effect = side_effect_singleShot
```

**‚ùì Perch√© √® un problema:**

Shared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.

According to PEP8, function names should be lowercase, with words separated by underscores as necessary to improve readability. This convention is
known as "snake_case." For example: `calculate_area`, `print_hello`, `process_data`

To fix this, respect the naming convention for the function. The default naming convention is snake case, as recommended by PEP8. Other naming
conventions can be defined through the `format` rule parameter.

##### Noncompliant code example

With the default provided regular expression: `^[a-z_][a-z0-9_]*$`

```
def MyFunction(a,b):
 ...
```

##### Compliant solution

```
def my_function(a,b):
 ...
```

**üìù Descrizione:**

This rule raises an issue when a function name doesn‚Äôt respect the naming convention.

### Why is this an issue?

Shared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.

According to PEP8, function names should be lowercase, with words separated by underscores as necessary to improve readability. This convention is
known as "snake_case." For example: `calculate_area`, `print_hello`, `process_data`

To fix this, respect the naming convention for the function. The default naming convention is snake case, as recommended by PEP8. Other naming
conventions can be defined through the `format` rule parameter.

#### Code examples

##### Noncompliant code example

With the default provided regular expression: `^[a-z_][a-z0-9_]*$`

```
def MyFunction(a,b):
 ...
```

##### Compliant solution

```
def my_function(a,b):
 ...
```

### Resources

#### Documentation

 - PEP8 - [Function and Variable Names](https://...

**üìö Risorse:**

#### Documentation

 - PEP8 - [Function and Variable Names](https://peps.python.org/pep-0008/#function-and-variable-names)

---

## üìÑ `tests/app/core/test_db_security_advanced.py`
**2 issue(s)** | Effort: 10min

### Riga 33 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "owner" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 13-18 |
| Tags | unused |

**üíª Codice attuale:**
```python
     31:     db_manager.lock_manager.acquire.return_value = (True, None)
     32: 
 >>> 33:     success, owner = db_manager.acquire_session_lock({"username": "test"})
     34: 
     35:     assert success is True
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 72 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "mock_replace".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 32-44 |
| Tags | unused |

**üíª Codice attuale:**
```python
     70: 
     71:     with patch("builtins.open", return_value=mock_file), \
 >>> 72:          patch("os.replace") as mock_replace:
     73:              result = db_manager.save_to_disk()
     74: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `desktop_app/components/floating_chat_widget.py`
**2 issue(s)** | Effort: 24min

### Riga 130 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 33 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 23min |
| Posizione | Colonne 8-19 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     128:         self.expand_animation.setEasingCurve(QEasingCurve.Type.OutCubic)
     129: 
 >>> 130:     def eventFilter(self, source, event):
     131:         if source == self.fab:
     132:             if event.type() == QEvent.Type.MouseButtonPress:
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 173 üü° üü° MAJOR

**üéØ Problema:** Remove this assignment to local variable 'align_flag'; the value is never used.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1854` - Unused assignments should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 8-47 |
| Tags | cwe, unused |

**üíª Codice attuale:**
```python
     171: 
     172:         target_x = 0
 >>> 173:         align_flag = Qt.AlignmentFlag.AlignLeft
     174: 
     175:         # Snap Right
```

**‚ùì Perch√© √® un problema:**

Dead stores refer to assignments made to local variables that are subsequently never used or immediately overwritten. Such assignments are
unnecessary and don‚Äôt contribute to the functionality or clarity of the code. They may even negatively impact performance. Removing them enhances code
cleanliness and readability. Even if the unnecessary operations do not do any harm in terms of the program‚Äôs correctness, they are - at best - a waste
of computing resources.

#### Exceptions

This rule ignores initializations to `-1`, `0`, `1`, `None`, `True`, `False` and
`""`. No issue will be raised on unpacked variables.

**‚úÖ Come risolvere:**

Remove the unnecessary assignment, then test the code to make sure that the right-hand side of a given assignment had no side effects (e.g. a
method that writes certain data to a file and returns the number of written bytes).

##### Noncompliant code example

```
def func(a, b, compute):
 i = a + b # Noncompliant; calculation result not used before value is overwritten
 i = compute()
 return i
```

##### Compliant solution

```
def func(a, b, compute):
 i = a + b
 i += compute()
 return i
```

**üìö Risorse:**

#### Standards

 - CWE - [CWE-563 - Assignment to Variable without Use ('Unused Variable')](https://cwe.mitre.org/data/definitions/563) 

#### Related rules

 - S1763 - All code should be reachable 

 - S3516 - Functions returns should not be invariant 

 - S3626 - Jump statements should not be redundant

---

## üìÑ `tests/desktop_app/services/test_voice_service.py`
**2 issue(s)** | Effort: 7min

### Riga 23 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "MockCommunicate" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 31-46 |
| Tags | convention |

**üíª Codice attuale:**
```python
     21: # Patch edge_tts globally as it is imported as a module
     22: @patch('edge_tts.Communicate')
 >>> 23: def test_tts_worker_generation(MockCommunicate):
     24:     # Setup AsyncMock for save
     25:     mock_comm_instance = MockCommunicate.return_value
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

### Riga 34 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "e".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 35-36 |
| Tags | unused |

**üíª Codice attuale:**
```python
     32:             try:
     33:                 worker.run()
 >>> 34:             except RuntimeError as e:
     35:                 # Loop running issue potential
     36:                 pass
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tools/prepare_installer_assets.py`
**2 issue(s)** | Effort: 11min

### Riga 71 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 4-18 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     69:         draw_neural_network(painter, width, height)
     70: 
 >>> 71: def draw_tech_grid(painter, width, height, is_dark):
     72:     """Draws a subtle hexagonal grid."""
     73:     size = 45
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 210 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "app".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-7 |
| Tags | unused |

**üíª Codice attuale:**
```python
     208: 
     209: def create_assets():
 >>> 210:     app = QApplication(sys.argv)
     211:     base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
     212:     assets_dir = os.path.join(base_dir, "desktop_app", "assets")
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/desktop_app/components/test_neural_3d.py`
**2 issue(s)** | Effort: 2min

### Riga 40 üü° üü¢ MINOR

**üéØ Problema:** Consider using "assertGreater" instead.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5906` - The most specific "unittest" assertion should be used |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 8-50 |
| Tags | tests, unittest |

**üíª Codice attuale:**
```python
     38: 
     39:         # Check assets generation
 >>> 40:         self.assertTrue(len(nn.star_textures) &gt; 0)
     41: 
     42:     def test_update_logic(self):
```

**‚ùì Perch√© √® un problema:**

The `unittest` module provides assertion methods specific to common types and operations. Both versions will test the same things, but
the dedicated one will provide a better error message, simplifying the debugging process.

This rule reports an issue when an assertion can be simplified by using a more specific function. The array below gives a list of assertions on
which an issue will be raised, and which function should be used instead:

 
 
 
 
 
 
 Original
 Dedicated
 
 
 
 
 `assertTrue(x == y)`

 `assertEqual(x, y)`

 
 
 `assertTrue(x != y)`

 `assertNotEqual(x, y)`

 
 
 `assertFalse(x == y)`

 `assertNotEqual(x, y)`

 
 
 `assertFalse(x != y)`

 `assertEqual(x, y)`

 
 
 `assertTrue(x < y)`

 `assertLess(x, y)`

 
 
 `assertTrue(x <= y)`

 `assertLessEqual(x, y)`

 
 
 `assertTrue(x > y)`

 `assertGreater(x, y)`

 
 
 `assertTrue(x >= y)`

 `assertGreaterEqual(x, y)`

 
 
 `assertTrue(x is y)`

 `assertIs(x, y)`

 
 
 `assertTrue(x is not y)`

 `assertIsNot(x, y)`

 
 
 `ass...

**üìù Descrizione:**

### Why is this an issue?

The `unittest` module provides assertion methods specific to common types and operations. Both versions will test the same things, but
the dedicated one will provide a better error message, simplifying the debugging process.

This rule reports an issue when an assertion can be simplified by using a more specific function. The array below gives a list of assertions on
which an issue will be raised, and which function should be used instead:

 
 
 
 
 
 
 Original
 Dedicated
 
 
 
 
 `assertTrue(x == y)`

 `assertEqual(x, y)`

 
 
 `assertTrue(x != y)`

 `assertNotEqual(x, y)`

 
 
 `assertFalse(x == y)`

 `assertNotEqual(x, y)`

 
 
 `assertFalse(x != y)`

 `assertEqual(x, y)`

 
 
 `assertTrue(x < y)`

 `assertLess(x, y)`

 
 
 `assertTrue(x <= y)`

 `assertLessEqual(x, y)`

 
 
 `assertTrue(x > y)`

 `assertGreater(x, y)`

 
 
 `assertTrue(x >= y)`

 `assertGreaterEqual(x, y)`

 
 
 `assertTrue(x is y)`

 `assertIs(x, y)`

 
 
 `assertTrue(x is not y)`

 `as...

**üìö Risorse:**

Python documentation - the `unittest`
module

---

### Riga 71 üü° üü¢ MINOR

**üéØ Problema:** Consider using "assertGreater" instead.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5906` - The most specific "unittest" assertion should be used |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 8-43 |
| Tags | tests, unittest |

**üíª Codice attuale:**
```python
     69:                 nn.update(0, 0)
     70: 
 >>> 71:         self.assertTrue(len(nn.pulses) &gt; 0)
     72:         self.assertEqual(nn.pulses[0][0], 0) # Start idx
     73:         self.assertEqual(nn.pulses[0][1], 1) # End idx
```

**‚ùì Perch√© √® un problema:**

The `unittest` module provides assertion methods specific to common types and operations. Both versions will test the same things, but
the dedicated one will provide a better error message, simplifying the debugging process.

This rule reports an issue when an assertion can be simplified by using a more specific function. The array below gives a list of assertions on
which an issue will be raised, and which function should be used instead:

 
 
 
 
 
 
 Original
 Dedicated
 
 
 
 
 `assertTrue(x == y)`

 `assertEqual(x, y)`

 
 
 `assertTrue(x != y)`

 `assertNotEqual(x, y)`

 
 
 `assertFalse(x == y)`

 `assertNotEqual(x, y)`

 
 
 `assertFalse(x != y)`

 `assertEqual(x, y)`

 
 
 `assertTrue(x < y)`

 `assertLess(x, y)`

 
 
 `assertTrue(x <= y)`

 `assertLessEqual(x, y)`

 
 
 `assertTrue(x > y)`

 `assertGreater(x, y)`

 
 
 `assertTrue(x >= y)`

 `assertGreaterEqual(x, y)`

 
 
 `assertTrue(x is y)`

 `assertIs(x, y)`

 
 
 `assertTrue(x is not y)`

 `assertIsNot(x, y)`

 
 
 `ass...

**üìù Descrizione:**

### Why is this an issue?

The `unittest` module provides assertion methods specific to common types and operations. Both versions will test the same things, but
the dedicated one will provide a better error message, simplifying the debugging process.

This rule reports an issue when an assertion can be simplified by using a more specific function. The array below gives a list of assertions on
which an issue will be raised, and which function should be used instead:

 
 
 
 
 
 
 Original
 Dedicated
 
 
 
 
 `assertTrue(x == y)`

 `assertEqual(x, y)`

 
 
 `assertTrue(x != y)`

 `assertNotEqual(x, y)`

 
 
 `assertFalse(x == y)`

 `assertNotEqual(x, y)`

 
 
 `assertFalse(x != y)`

 `assertEqual(x, y)`

 
 
 `assertTrue(x < y)`

 `assertLess(x, y)`

 
 
 `assertTrue(x <= y)`

 `assertLessEqual(x, y)`

 
 
 `assertTrue(x > y)`

 `assertGreater(x, y)`

 
 
 `assertTrue(x >= y)`

 `assertGreaterEqual(x, y)`

 
 
 `assertTrue(x is y)`

 `assertIs(x, y)`

 
 
 `assertTrue(x is not y)`

 `as...

**üìö Risorse:**

Python documentation - the `unittest`
module

---

## üìÑ `desktop_app/components/custom_dialog.py`
**2 issue(s)** | Effort: 10min

### Riga 50 üü° üü° MAJOR

**üéØ Problema:** Extract this nested conditional expression into an independent statement.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3358` - Conditional expressions should not be nested |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 50-88 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     48:         # Title
     49:         self.title_label = QLabel(title)
 >>> 50:         title_color = "#DC2626" if is_error else ("#D97706" if is_warning else "#1F2937")
     51:         self.title_label.setStyleSheet(f"color: {title_color}; font-size: 18px; font-weight: 700;")
     52:         self.title_label.setAlignment(Qt.AlignmentFlag.AlignLeft)
```

**‚ùì Perch√© √® un problema:**

Nested conditionals are hard to read and can make the order of operations complex to understand.

```
class Job:
 @property
 def readable_status(self):
 return "Running" if job.is_running else "Failed" if job.errors else "Succeeded" # Noncompliant
```

Instead, use another line to express the nested operation in a separate statement.

```
class Job:
 @property
 def readable_status(self):
 if job.is_running:
 return "Running"
 return "Failed" if job.errors else "Succeeded"
```

#### Exceptions

No issue is raised on conditional expressions in comprehensions.

```
job_statuses = ["Running" if job.is_running else "Failed" if job.errors else "Succeeded" for job in jobs] # Compliant by exception
```

**üìù Descrizione:**

### Why is this an issue?

Nested conditionals are hard to read and can make the order of operations complex to understand.

```
class Job:
 @property
 def readable_status(self):
 return "Running" if job.is_running else "Failed" if job.errors else "Succeeded" # Noncompliant
```

Instead, use another line to express the nested operation in a separate statement.

```
class Job:
 @property
 def readable_status(self):
 if job.is_running:
 return "Running"
 return "Failed" if job.errors else "Succeeded"
```

#### Exceptions

No issue is raised on conditional expressions in comprehensions.

```
job_statuses = ["Running" if job.is_running else "Failed" if job.errors else "Succeeded" for job in jobs] # Compliant by exception
```

---

### Riga 121 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "result".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | unused |

**üíª Codice attuale:**
```python
     119:         """
     120:         dialog = CustomMessageDialog(title, message, parent=parent, is_question=True)
 >>> 121:         result = dialog.exec()
     122:         return dialog.result_value
     123: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/app/services/test_certificate_logic.py`
**2 issue(s)** | Effort: 10min

### Riga 237 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "today_year".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-14 |
| Tags | unused |

**üíª Codice attuale:**
```python
     235:     # Per sicurezza, usiamo date relative a 'today' per il test robusto,
     236:     # ma per seguire lo scenario utente usiamo date fisse future per l'ultimo.
 >>> 237:     today_year = date.today().year
     238:     # Se siamo nel 2025 o dopo, questo funziona. Se siamo nel 2024, 2025 √® futuro.
     239:     # Forziamo date relative per garantire il test passi sempre.
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 366 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "threshold".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-13 |
| Tags | unused |

**üíª Codice attuale:**
```python
     364: 
     365:     # Threshold is 30 days for VISITA MEDICA
 >>> 366:     threshold = settings.ALERT_THRESHOLD_DAYS_VISITE
     367: 
     368:     # Expiring in 45 days (outside 30 but inside 60)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `desktop_app/views/modern_guide_view.py`
**2 issue(s)** | Effort: 4min

### Riga 21 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "lineNumber" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 55-65 |
| Tags | convention |

**üíª Codice attuale:**
```python
     19: 
     20: class CustomWebEnginePage(QWebEnginePage):
 >>> 21:     def javaScriptConsoleMessage(self, level, message, lineNumber, sourceID):
     22:         # Suppress specific router warnings that clutter the console
     23:         if "No routes matched location" in message:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

### Riga 21 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "sourceID" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 67-75 |
| Tags | convention |

**üíª Codice attuale:**
```python
     19: 
     20: class CustomWebEnginePage(QWebEnginePage):
 >>> 21:     def javaScriptConsoleMessage(self, level, message, lineNumber, sourceID):
     22:         # Suppress specific router warnings that clutter the console
     23:         if "No routes matched location" in message:
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

## üìÑ `guide_frontend/src/components/Layout.jsx`
**2 issue(s)** | Effort: 6min

### Riga 8 üü° üü¢ MINOR

**üéØ Problema:** Remove the declaration of the unused 'location' variable.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1481` - Unused local variables and functions should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-16 |
| Tags | unused |

**üíª Codice attuale:**
```jsx
     6: 
     7: const Layout = () =&gt; {
 >>> 8:   const location = useLocation();
     9: 
     10:   return (
```

**‚ùì Perch√© √® un problema:**

If a local variable or a local function is declared but not used, it is dead code and should be removed. Doing so will improve maintainability
because developers will not wonder what the variable or function is used for.

#### What is the potential impact?

##### Dead code

An unused variable or local function usually occurs because some logic is no longer required after a code change. In that case, such code becomes
unused and never executed.

Also, if you are writing code for the front-end, every unused variable or function remaining in your codebase is just extra bytes you have to send
over the wire to your users. Unused code bloats your codebase unnecessarily and impacts the performance of your application.

##### Wrong logic

It could happen that due to a bad copy-paste or autocompletion, the wrong variable is used, while the right one is only declared. In that case, the
unused variable should be used instead of deleted from the codebase.

##### Memory leaks

Finally, unused funct...

**‚úÖ Come risolvere:**

Usually, the fix for this issue is straightforward, you just need to remove the unused variable declaration, or its name from the declaration
statement if it is declared along with other variables.

##### Noncompliant code example

```
function numberOfMinutes(hours) {
 var seconds = 0; // seconds is never used
 return hours * 60;
}
```

##### Compliant solution

```
function numberOfMinutes(hours) {
 return hours * 60;
}
```

##### Noncompliant code example

When an array destructuring is used and some element of the array is never referenced, one might simply remove it from the destructuring.

```
const [_, params] = url.split(path);
```

##### Compliant solution

```
const [, params] = url.split(path);
```

**üìö Risorse:**

#### Documentation

 - MDN web docs - [Destructuring assignment / Ignoring some values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#ignoring_some_returned_values) 

#### Articles & blog posts

 - Phil Nash, Common TypeScript
 Issues N¬∫ 3: unused local variables and functions 

 - David Glasser, An interesting kind of JavaScript
 memory leak

---

### Riga 8 üü° üü° MAJOR

**üéØ Problema:** Remove this useless assignment to variable "location".

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1854` - Unused assignments should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 8-16 |
| Tags | cwe, unused |

**üíª Codice attuale:**
```jsx
     6: 
     7: const Layout = () =&gt; {
 >>> 8:   const location = useLocation();
     9: 
     10:   return (
```

**‚ùì Perch√© √® un problema:**

Dead stores refer to assignments made to local variables that are subsequently never used or immediately overwritten. Such assignments are
unnecessary and don‚Äôt contribute to the functionality or clarity of the code. They may even negatively impact performance. Removing them enhances code
cleanliness and readability. Even if the unnecessary operations do not do any harm in terms of the program‚Äôs correctness, they are - at best - a waste
of computing resources.

#### Exceptions

The rule ignores

 - Initializations to `-1`, `0`, `1`, `undefined`, `[]`, `{}`,
 `true`, `false` and `""`. 

 - Variables that start with an underscore (e.g. `_unused`) are ignored. 

 - Assignment of `null` is ignored because it is sometimes used to help garbage collection 

 - Increment and decrement expressions are ignored because they are often used idiomatically instead of `x+1` 

 - This rule also ignores variables declared with object destructuring using rest syntax (used to exclude some properties from ...

**‚úÖ Come risolvere:**

Remove the unnecessary assignment, then test the code to make sure that the right-hand side of a given assignment had no side effects (e.g. a
method that writes certain data to a file and returns the number of written bytes).

##### Noncompliant code example

```
function foo(y) {
 let x = 100; // Noncompliant: dead store
 x = 150; // Noncompliant: dead store
 x = 200;
 return x + y;
}
```

##### Compliant solution

```
function foo(y) {
 let x = 200; // Compliant: no unnecessary assignment
 return x + y;
}
```

**üìö Risorse:**

#### Standards

 - CWE - [CWE-563 - Assignment to Variable without Use ('Unused Variable')](https://cwe.mitre.org/data/definitions/563) 

#### Related rules

 - S1763 - All code should be reachable 

 - S2589 - Boolean expressions should not be gratuitous 

 - S3516 - Function returns should not be invariant 

 - S3626 - Jump statements should not be redundant

---

## üìÑ `guide_frontend/src/pages/EmployeesGuide.jsx`
**2 issue(s)** | Effort: 2min

### Riga 5 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Users'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 9-14 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     3: import Note from '../components/ui/Note';
     4: import Step from '../components/ui/Step';
 >>> 5: import { Users, FileSpreadsheet, UserPlus, Link } from 'lucide-react';
     6: 
     7: const EmployeesGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

### Riga 5 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'FileSpreadsheet'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 16-31 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     3: import Note from '../components/ui/Note';
     4: import Step from '../components/ui/Step';
 >>> 5: import { Users, FileSpreadsheet, UserPlus, Link } from 'lucide-react';
     6: 
     7: const EmployeesGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

## üìÑ `app/core/lock_manager.py`
**2 issue(s)** | Effort: 12min

### Riga 25 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 8-15 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     23:         self.current_metadata: Optional[Dict] = None
     24: 
 >>> 25:     def acquire(self, owner_metadata: Dict, retries: int = 3, delay: float = 0.5) -&gt; Tuple[bool, Optional[Dict]]:
     26:         """
     27:         Attempts to acquire an exclusive lock on the file with retry logic.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

### Riga 103 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 8-24 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     101:                 self._lock_handle = None
     102: 
 >>> 103:     def update_heartbeat(self) -&gt; bool:
     104:         """
     105:         Updates the timestamp in the lock file to prove we are still alive.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `tests/core/test_lock_manager.py`
**2 issue(s)** | Effort: 10min

### Riga 13 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "info" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 13-17 |
| Tags | unused |

**üíª Codice attuale:**
```python
     11: 
     12:     # 1. Acquire
 >>> 13:     success, info = lock_manager.acquire({"test": "data"})
     14:     assert success
     15:     # In mock env we didn't actually lock byte, but file is open
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 35 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "info" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 13-17 |
| Tags | unused |

**üíª Codice attuale:**
```python
     33: 
     34:     # 1. Acquire
 >>> 35:     success, info = lock_manager.acquire({"test": "data"})
     36:     assert success
     37: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `app/api/routers/auth.py`
**2 issue(s)** | Effort: 7min

### Riga 38 üü° üü¢ MINOR

**üéØ Problema:** Remove this unneeded "pass".

| Campo | Valore |
|-------|--------|
| Regola | `python:S2772` - "pass" should not be used needlessly |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 12-16 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     36:             # If it failed, it's likely already blacklisted or race condition.
     37:             # We treat it as success (idempotent).
 >>> 38:             pass
     39: 
     40:     # Force DB Sync and Cleanup on logout to ensure data persistence and lock release
```

**‚ùì Perch√© √® un problema:**

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

**üìù Descrizione:**

This rule raises an issue when a `pass` statement is redundant.

### Why is this an issue?

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

#### Code examples

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

### Resources

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

**üìö Risorse:**

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

---

### Riga 142 üü° üî¥ CRITICAL

**üéØ Problema:** Change this default value to "None" and initialize this parameter inside the function/method.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5717` - Function parameters' default values should not be modified or assigned |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 4-60 |
| Tags | bad-practice, pitfall |

**üíª Codice attuale:**
```python
     140:     password_data: UserPasswordUpdate,
     141:     request: Request,
 >>> 142:     current_user: deps.User = Depends(deps.get_current_user),
     143:     db: Session = Depends(get_db)
     144: ):
```

**‚ùì Perch√© √® un problema:**

In Python, function parameters can have default values.

These default values are expressions which are evalutated when the function is defined, i.e. only once. The same default value will be used every
time the function is called. Therefore, modifying it will have an effect on every subsequent call. This can lead to confusing bugs.

```
def myfunction(param=foo()): # foo is called only once, when the function is defined.
 ...
```

For the same reason, it is also a bad idea to store mutable default values in another object (ex: as an attribute). Multiple instances will then
share the same value and modifying one object will modify all of them.

This rule raises an issue when:

 - a default value is either modified in the function or assigned to anything other than a variable and it has one of the following types:
 
 [collections](https://docs.python.org/3/library/collections.html) module: deque, UserList, ChainMap, Counter, OrderedDict,
 defaultdict, UserDict. 

 
 - an attribute of a ...

**‚úÖ Come risolvere:**

When a parameter default value is meant to be a mutable object, it is best to keep the parameter optional and instantiate the mutable object in the
function‚Äôs body directly.

##### Noncompliant code example

In the following example, the parameter "param" has `list()` as a default value. This list is created only once and then reused in every
call. Thus when appending `'a'` to this list in the body of the function, the next call will have `['a']` as a default
value.

```
def myfunction(param=list()): # Noncompliant: param is a list that gets mutated
 param.append('a') # modification of the default value.
 return param

print(myfunction()) # returns ['a']
print(myfunction()) # returns ['a', 'a']
print(myfunction()) # returns ['a', 'a', 'a']
```

##### Compliant solution

```
def myfunction(param=None):
 if param is None:
 param = list()
 param.append('a')
 return param

print(myfunction()) # returns ['a']
print(myfunction()) # returns ['a']
print(myfunction()) # returns ['a']
```

**üìö Risorse:**

#### Documentation

 - Python documentation - [Function definitions](https://docs.python.org/3/reference/compound_stmts.html#function-definitions) 

#### External coding guidelines

 - The Hitchhiker‚Äôs Guide to Python - [Common Gotchas](https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments)

---

## üìÑ `tests/app/api/routers/test_app_config.py`
**2 issue(s)** | Effort: 10min

### Riga 37 üü° üü¢ MINOR

**üéØ Problema:** Replace this comprehension with passing the iterable to the collection constructor call

| Campo | Valore |
|-------|--------|
| Regola | `python:S7500` - Comprehensions only used to copy should be replaced with the respective constructor calls |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 16-31 |

**üíª Codice attuale:**
```python
     35:     """
     36:     app.dependency_overrides[deps.get_current_active_admin] = \
 >>> 37:         lambda: (_ for _ in ()).throw(HTTPException(status_code=403, detail="Forbidden"))
     38: 
     39:     response = test_client.get("/app_config/config", headers=user_token_headers)
```

**‚ùì Perch√© √® un problema:**

Python comprehensions are a concise way to create new collections while transforming or filtering elements. However, using a comprehension that
copies elements from one collection to another without any transformation is less readable than using the respective constructor directly.

Therefore, when a comprehension is only copying elements, use the appropriate constructor instead:

 - Replace `[x for x in iterable]` with `list(iterable)` 

 - Replace `{x for x in iterable}` with `set(iterable)` 

 - Replace `{k: v for k, v in iterable.items()}` with `dict(iterable)`

**‚úÖ Come risolvere:**

Replace comprehensions that copy elements from one collection to another with the respective constructor.

##### Noncompliant code example

```
some_list = [1, 2, 3, 2]
[x for x in some_list] # Noncompliant
```

##### Compliant solution

```
some_list = [1, 2, 3, 2]
list(some_list) # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [dict()](https://docs.python.org/3/library/stdtypes.html#dict) 

 - Python Documentation - [list()](https://docs.python.org/3/library/stdtypes.html#list) 

 - Python Documentation - [set()](https://docs.python.org/3/library/stdtypes.html#set)

---

### Riga 66 üü° üü¢ MINOR

**üéØ Problema:** Replace this comprehension with passing the iterable to the collection constructor call

| Campo | Valore |
|-------|--------|
| Regola | `python:S7500` - Comprehensions only used to copy should be replaced with the respective constructor calls |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 16-31 |

**üíª Codice attuale:**
```python
     64:     """
     65:     app.dependency_overrides[deps.get_current_active_admin] = \
 >>> 66:         lambda: (_ for _ in ()).throw(HTTPException(status_code=403, detail="Forbidden"))
     67: 
     68:     new_settings = {"SMTP_HOST": "hacker.com"}
```

**‚ùì Perch√© √® un problema:**

Python comprehensions are a concise way to create new collections while transforming or filtering elements. However, using a comprehension that
copies elements from one collection to another without any transformation is less readable than using the respective constructor directly.

Therefore, when a comprehension is only copying elements, use the appropriate constructor instead:

 - Replace `[x for x in iterable]` with `list(iterable)` 

 - Replace `{x for x in iterable}` with `set(iterable)` 

 - Replace `{k: v for k, v in iterable.items()}` with `dict(iterable)`

**‚úÖ Come risolvere:**

Replace comprehensions that copy elements from one collection to another with the respective constructor.

##### Noncompliant code example

```
some_list = [1, 2, 3, 2]
[x for x in some_list] # Noncompliant
```

##### Compliant solution

```
some_list = [1, 2, 3, 2]
list(some_list) # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [dict()](https://docs.python.org/3/library/stdtypes.html#dict) 

 - Python Documentation - [list()](https://docs.python.org/3/library/stdtypes.html#list) 

 - Python Documentation - [set()](https://docs.python.org/3/library/stdtypes.html#set)

---

## üìÑ `tests/desktop_app/views/test_config_view.py`
**2 issue(s)** | Effort: 4min

### Riga 34 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "MockAPIClient" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 45-58 |
| Tags | convention |

**üíª Codice attuale:**
```python
     32: 
     33: @patch('desktop_app.views.config_view.APIClient')
 >>> 34: def test_config_view_loads_settings_from_api(MockAPIClient, mock_api_client):
     35:     """
     36:     Test that the ConfigView calls the API to load settings and populates the UI fields.
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

### Riga 64 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "MockAPIClient" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 44-57 |
| Tags | convention |

**üíª Codice attuale:**
```python
     62: 
     63: @patch('desktop_app.views.config_view.APIClient')
 >>> 64: def test_config_view_saves_settings_via_api(MockAPIClient, mock_api_client):
     65:     """
     66:     Test that the ConfigView calls the API to save settings when the button is clicked.
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

## üìÑ `tests/app/core/test_db_security.py`
**2 issue(s)** | Effort: 6min

### Riga 74 üü° üü¢ MINOR

**üéØ Problema:** Remove this redundant Exception class; it derives from another which is already caught.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5713` - A subclass should not be in the same "except" statement as a parent class |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 35-59 |
| Tags | bad-practice, error-handling, unused |

**üíª Codice attuale:**
```python
     72:         c_disk.execute("SELECT * FROM test")
     73:         assert False, "Should not be able to open encrypted DB"
 >>> 74:     except (sqlite3.DatabaseError, sqlite3.OperationalError):
     75:         pass
     76:     except Exception:
```

**‚ùì Perch√© √® un problema:**

In Python it is possible to catch multiple types of exception in a single `except` statement using a tuple of the exceptions.

Repeating an exception class in a single `except` statement will not fail but it does not have any effect. Either the exception class is
not the one which should be caught, or it is duplicated code which should be removed.

Having a subclass and a parent class in the same `except` statement does not provide any benefit either. It is enough to keep only the
parent class.

##### Noncompliant code example

```
try:
 ...
except (TypeError, TypeError): # Noncompliant: duplicated code or incorrect exception class.
 print("Foo")

try:
 ...
except (NotImplementedError, RuntimeError): # Noncompliant: NotImplementedError inherits from RuntimeError.
 print("Foo")
```

##### Compliant solution

```
try:
 ...
except (TypeError, ValueError):
 print("Foo")

try:
 ...
except RuntimeError:
 print("Foo")
```

**üìù Descrizione:**

This rule raises an issue when an exception class is duplicated in an `except` statement, or when an exception class has a parent class
in the same `except` statement.

### Why is this an issue?

In Python it is possible to catch multiple types of exception in a single `except` statement using a tuple of the exceptions.

Repeating an exception class in a single `except` statement will not fail but it does not have any effect. Either the exception class is
not the one which should be caught, or it is duplicated code which should be removed.

Having a subclass and a parent class in the same `except` statement does not provide any benefit either. It is enough to keep only the
parent class.

#### Code examples

##### Noncompliant code example

```
try:
 ...
except (TypeError, TypeError): # Noncompliant: duplicated code or incorrect exception class.
 print("Foo")

try:
 ...
except (NotImplementedError, RuntimeError): # Noncompliant: NotImplementedError inherits from RuntimeError.
 print("Fo...

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Handling Exceptions](https://docs.python.org/3/tutorial/errors.html#handling-exceptions) 

 - Python Documentation - [Exception hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)

---

### Riga 110 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "conn2".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-9 |
| Tags | unused |

**üíª Codice attuale:**
```python
     108:     manager2 = DBSecurityManager(db_name=db_name)
     109:     manager2.load_memory_db() # Should succeed now
 >>> 110:     conn2 = manager2.get_connection() # Initialize connection
     111: 
     112:     # Try to acquire lock
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `app/utils/file_security.py`
**2 issue(s)** | Effort: 10min

### Riga 18 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "text".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | unused |

**üíª Codice attuale:**
```python
     16:             # Try to decode as UTF-8 (or other common encodings if needed)
     17:             # If it fails, it's likely binary
 >>> 18:             text = file_content.decode('utf-8')
     19:         except UnicodeDecodeError:
     20:             try:
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

### Riga 25 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     23:                 try:
     24:                      text = file_content.decode('latin-1')
 >>> 25:                 except:
     26:                      return False
     27: 
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

## üìÑ `tests/tools/test_tools.py`
**2 issue(s)** | Effort: 7min

### Riga 11 üü° üü¢ MINOR

**üéØ Problema:** Remove this unnecessary `list()` call on an already iterable object.

| Campo | Valore |
|-------|--------|
| Regola | `python:S7504` - When iterating over an iterable object, using "list()" should be avoided |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 17-21 |

**üíª Codice attuale:**
```python
     9:     with patch.dict(sys.modules, modules):
     10:         # Ensure we don't have cached modules
 >>> 11:         for k in list(sys.modules.keys()):
     12:              if k.startswith('tools.prepare_installer_assets'):
     13:                  del sys.modules[k]
```

**‚ùì Perch√© √® un problema:**

When iterating over an already iterable object with a for loop or a comprehension, wrapping it with `list()` adds meaningless clutter
that doesn‚Äôt provide any functional value. Additionally, it creates unnecessary overhead by generating an intermediate list in memory, which
inefficiently consumes memory and can degrade performance, especially with large data structures. Iterating directly over the original object is
cleaner and more efficient.

**‚úÖ Come risolvere:**

Remove the redundant `list()` call and iterate directly over the original iterable.

##### Noncompliant code example

```
some_iterable = range(10)
for i in list(some_iterable): # Noncompliant: unnecessary list() call
 print(i)
```

##### Compliant solution

```
some_iterable = range(10)
for i in some_iterable: # Compliant
 print(i)
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Iterable Glossary Entry](https://docs.python.org/3/glossary.html#term-iterable) 

 - Python Documentation - [list()](https://docs.python.domainunion.de/3/library/stdtypes.html#list)

---

### Riga 31 üü° üü¢ MINOR

**üéØ Problema:** Remove this unneeded "pass".

| Campo | Valore |
|-------|--------|
| Regola | `python:S2772` - "pass" should not be used needlessly |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 9-13 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     29:          # We can check if QPainter was instantiated
     30:          # sys.modules['PyQt6.QtGui'].QPainter.assert_called()
 >>> 31:          pass
     32: 
```

**‚ùì Perch√© √® un problema:**

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

**üìù Descrizione:**

This rule raises an issue when a `pass` statement is redundant.

### Why is this an issue?

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

#### Code examples

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

### Resources

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

**üìö Risorse:**

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

---

## üìÑ `app/schemas/schemas.py`
**2 issue(s)** | Effort: 16min

### Riga 76 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal '%d/%m/%Y' 4 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 8min |
| Posizione | Colonne 33-43 |
| Tags | design |

**üíª Codice attuale:**
```python
     74:             raise ValueError("La data di rilascio non pu√≤ essere vuota.")
     75:         try:
 >>> 76:             datetime.strptime(v, '%d/%m/%Y')
     77:         except ValueError:
     78:             raise ValueError("Formato data non valido. Usare DD/MM/YYYY.")
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

### Riga 78 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "Formato data non valido. Usare DD/MM/YYYY." 4 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 8min |
| Posizione | Colonne 29-73 |
| Tags | design |

**üíª Codice attuale:**
```python
     76:             datetime.strptime(v, '%d/%m/%Y')
     77:         except ValueError:
 >>> 78:             raise ValueError("Formato data non valido. Usare DD/MM/YYYY.")
     79:         return v
     80: 
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

## üìÑ `desktop_app/views/edit_dialog.py`
**2 issue(s)** | Effort: 17min

### Riga 39 üü° üü¢ MINOR

**üéØ Problema:** Remove this redundant call.

| Campo | Valore |
|-------|--------|
| Regola | `python:S7508` - Redundant collection functions should be avoided |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 35-39 |

**üíª Codice attuale:**
```python
     37:         self.categoria_edit = QComboBox()
     38: 
 >>> 39:         unique_categories = sorted(list(set(categories)))
     40:         self.categoria_edit.addItems(unique_categories)
     41: 
```

**‚ùì Perch√© √® un problema:**

Python‚Äôs built-in functions for processing iterables such as `list()`, `tuple()`, `set()`, `sorted()`,
and `reversed()` are designed to accept any iterable as input. When these functions are unnecessarily nested within each other, it creates
redundant operations that add unnecessary computational overhead by creating intermediate data structures, decrease code readability and make the
intention less clear, and waste memory by duplicating data structures temporarily.

**‚úÖ Come risolvere:**

When the outer function is given a collection but could have been given an iterable, the unnecessary conversion should be removed. For example, in
`sorted(list(iterable))`, the outer `sorted()` function can accept an iterable directly, so the inner `list()` call
is redundant and should be removed.

When the function `sorted()` is wrapped with `list()`, remove this conversion operation, since `sorted()` already
returns a list.

##### Noncompliant code example

```
iterable = (3, 1, 4, 1)

sorted_of_list = list(sorted(iterable)) # Noncompliant
```

##### Compliant solution

```
iterable = (3, 1, 4, 1)

sorted_of_list = sorted(iterable)
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [list](https://docs.python.org/3/library/stdtypes.html#list) 

 - Python Documentation - [tuple](https://docs.python.org/3/library/stdtypes.html#tuple) 

 - Python Documentation - [set](https://docs.python.org/3/library/stdtypes.html#set) 

 - Python Documentation - [sorted](https://docs.python.org/3/library/functions.html#sorted) 

 - Python Documentation - [reversed](https://docs.python.org/3/library/functions.html#reversed)

---

### Riga 49 üü° üî¥ CRITICAL

**üéØ Problema:** Define a constant instead of duplicating this literal "dd/MM/yyyy" 6 times.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1192` - String literals should not be duplicated |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 12min |
| Posizione | Colonne 49-61 |
| Tags | design |

**üíª Codice attuale:**
```python
     47: 
     48:         self.data_rilascio_edit = QDateEdit()
 >>> 49:         self.data_rilascio_edit.setDisplayFormat("dd/MM/yyyy")
     50:         rilascio_date = QDate.fromString(data['data_rilascio'], "dd/MM/yyyy")
     51:         self.data_rilascio_edit.setDate(rilascio_date if rilascio_date.isValid() else QDate.currentDate())
```

**‚ùì Perch√© √® un problema:**

Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.

#### Exceptions

No issue will be raised on:

 - duplicated string in decorators 

 - strings with less than 5 characters 

 - strings with only letters, numbers and underscores

**‚úÖ Come risolvere:**

Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.

##### Noncompliant code example

With the default threshold of 3:

```
def run():
 prepare("action1") # Noncompliant - "action1" is duplicated 3 times
 execute("action1")
 release("action1")

@app.route("/api/users/", methods=['GET', 'POST', 'PUT'])
def users():
 pass

@app.route("/api/projects/", methods=['GET', 'POST', 'PUT']) # Compliant - strings inside decorators are ignored
def projects():
 pass
```

##### Compliant solution

```
ACTION_1 = "action1"

def run():
 prepare(ACTION_1)
 execute(ACTION_1)
 release(ACTION_1)
```

---

## üìÑ `tests/desktop_app/test_api_client_coverage.py`
**1 issue(s)** | Effort: 5min

### Riga 62 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "kwargs" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 14-20 |
| Tags | unused |

**üíª Codice attuale:**
```python
     60:         # Verify URL construction
     61:         mock_get.assert_called()
 >>> 62:         args, kwargs = mock_get.call_args
     63:         self.assertTrue(args[0].endswith("/api/v1/endpoint"))
     64: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/desktop_app/components/test_update_dialog.py`
**1 issue(s)** | Effort: 5min

### Riga 26 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "args".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | unused |

**üíª Codice attuale:**
```python
     24:             
     25:             mock_ds.openUrl.assert_called()
 >>> 26:             args = mock_ds.openUrl.call_args[0][0]
     27:             # Verify URL passed to openUrl logic (Mock QUrl might be tricky to inspect property, but call is made)
     28:             mock_accept.assert_called()
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/desktop_app/views/test_config_view_coverage.py`
**1 issue(s)** | Effort: 2min

### Riga 70 üü° üü¢ MINOR

**üéØ Problema:** Remove this unneeded "pass".

| Campo | Valore |
|-------|--------|
| Regola | `python:S2772` - "pass" should not be used needlessly |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 12-16 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     68:         with patch('desktop_app.views.config_view.CustomMessageDialog.show_question', return_value=False):
     69:             self.view.switch_tab(1)
 >>> 70:             pass
     71: 
     72:     def test_user_dialog_data(self):
```

**‚ùì Perch√© √® un problema:**

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

**üìù Descrizione:**

This rule raises an issue when a `pass` statement is redundant.

### Why is this an issue?

The use of a `pass` statement where it is not required by the syntax is redundant. It makes the code less readable and its intent
confusing.

To fix this issue, remove `pass` statements that do not affect the behaviour of the program.

#### Code examples

##### Noncompliant code example

```
def foo(arg):
 print(arg)
 pass # Noncompliant: the `pass` statement is not needed as it does not change the behaviour of the program.
```

##### Compliant solution

```
def foo(arg):
 print(arg)
```

### Resources

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

**üìö Risorse:**

#### Documentation

 - Python Documentation - [The pass statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)

---

## üìÑ `tests/desktop_app/views/test_database_view_coverage.py`
**1 issue(s)** | Effort: 2min

### Riga 101 üü° üü¢ MINOR

**üéØ Problema:** Rename this parameter "MockMenu" to match the regular expression ^[_a-z][a-z0-9_]*$.

| Campo | Valore |
|-------|--------|
| Regola | `python:S117` - Local variable and function parameter names should comply with a naming convention |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 32-40 |
| Tags | convention |

**üíª Codice attuale:**
```python
     99: 
     100:     @patch('desktop_app.views.database_view.QMenu')
 >>> 101:     def test_context_menu(self, MockMenu):
     102:         self.view.on_data_changed() # populate model
     103:         
```

**‚ùì Perch√© √® un problema:**

A naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.
 Local
variables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily
recognizable pattern.
 Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to
maintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.

This rule checks that local variable and function parameter names match a provided regular expression.

#### What is the potential impact?

Inconsistent naming of local variables and function parameters can lead to several issues in your code:

 - **Reduced Readability**: Inconsistent local variable and function parameter names make the code harder to read and understand;
 consequently, it is more difficult to identify the purpose of each...

**‚úÖ Come risolvere:**

First, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as
well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.

##### Noncompliant code example

With the default regular expression `^[_a-z][a-z0-9_]*$`:

```
def print_something(IMPORTANT_PARAM): # Noncompliant
 localVariable = "" # Noncompliant
 print(IMPORTANT_PARAM + localVariable)
```

##### Compliant solution

```
def print_something(important_param):
 local_variable = ""
 print(important_param + local_variable)
```

**üìö Risorse:**

#### Documentation

 - Python Enhancement Proposals - [PEP8 - Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions) 

 - Wikipedia - [Naming Convention (programming)](https://en.wikipedia.org/wiki/Naming_convention_(programming)) 

#### Related rules

 - S100 - Method names should comply with a naming convention 

 - S101 - Class names should comply with a naming convention 

 - S116 - Field names should comply with a naming convention 

 - S1542 - Function names should comply with a naming convention 

 - S1578 - Module names should comply with a naming convention 

 - S27...

---

## üìÑ `tests/test_launcher_coverage.py`
**1 issue(s)** | Effort: 5min

### Riga 85 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "args" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 12-16 |
| Tags | unused |

**üíª Codice attuale:**
```python
     83:             
     84:             # Verify Thread was created with start_server as target
 >>> 85:             args, kwargs = mock_thread.call_args
     86:             self.assertEqual(kwargs.get('target'), mock_server)
     87:             self.assertEqual(kwargs.get('args'), (8000,))
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/app/services/test_sync_service_orphans.py`
**1 issue(s)** | Effort: 5min

### Riga 54 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "mock_makedirs".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 33-46 |
| Tags | unused |

**üíª Codice attuale:**
```python
     52:          patch("app.services.sync_service.get_unique_filename", return_value="Mario Rossi.pdf"), \
     53:          patch("os.path.exists", return_value=True), \
 >>> 54:          patch("os.makedirs") as mock_makedirs, \
     55:          patch("shutil.move") as mock_move, \
     56:          patch("app.services.sync_service.remove_empty_folders") as mock_cleanup, \
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/desktop_app/views/test_splash_screen.py`
**1 issue(s)** | Effort: 10min

### Riga 23 üü° üî¥ CRITICAL

**üéØ Problema:** Remove this identity check; it will always be True.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5727` - Comparison to None should not be constant |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 11-29 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     21: 
     22:     splash = CustomSplashScreen()
 >>> 23:     assert splash is not None
     24:     assert splash.windowFlags() is not None
     25: 
```

**‚ùì Perch√© √® un problema:**

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

**üìù Descrizione:**

This rule raises an issue when a comparison to `None` is invariant.

### Why is this an issue?

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

#### Code examples

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

### Resources

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

**üìö Risorse:**

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

---

## üìÑ `tests/desktop_app/views/test_stats_view.py`
**1 issue(s)** | Effort: 10min

### Riga 18 üü° üî¥ CRITICAL

**üéØ Problema:** Remove this identity check; it will always be True.

| Campo | Valore |
|-------|--------|
| Regola | `python:S5727` - Comparison to None should not be constant |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 10min |
| Posizione | Colonne 11-27 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     16:     view = StatsView(mock_api)
     17:     
 >>> 18:     assert view is not None
     19:     # Check if layout was set
     20:     assert view.layout is not None
```

**‚ùì Perch√© √® un problema:**

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

**üìù Descrizione:**

This rule raises an issue when a comparison to `None` is invariant.

### Why is this an issue?

Checking if a variable or parameter is `None` should only be done when you expect that it can be `None`. Doing so when the
variable is always `None` or never `None` is confusing at best. At worse, there is a bug and the variable is not updated
properly.

This rule raises an issue when expressions `X is None`, `X is not None`, `X == None` or `X != None` are
constant, i.e. `X` is always None or never None.

#### Code examples

##### Noncompliant code example

```
def foo():
 my_var = None
 if my_var == None: # Noncompliant: always True.
 ...
```

##### Compliant solution

```
def foo(my_var):
 if my_var == None:
 ...
```

### Resources

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

**üìö Risorse:**

#### Documentation

 - Python documentation - [Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not) 

 - Python documentation - [`__eq__` operator](https://docs.python.org/3/reference/datamodel.html#object.__eq__)

---

## üìÑ `tests/app/api/test_update_cert_file_sync.py`
**1 issue(s)** | Effort: 5min

### Riga 44 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "mock_move".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 33-42 |
| Tags | unused |

**üíª Codice attuale:**
```python
     42:     # Verification of mock_move.assert_called() is skipped because of test environment patching complexities,
     43:     # but the presence of the patch protects the FS.
 >>> 44:     with patch("shutil.move") as mock_move:
     45:         
     46:         response = test_client.put(f"/certificati/{cert.id}", json=payload)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/app/services/test_chat_service_full.py`
**1 issue(s)** | Effort: 5min

### Riga 29 üü° üü° MAJOR

**üéØ Problema:** Remove this commented out code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S125` - Sections of code should not be commented out |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 61-85 |
| Tags | unused |

**üíª Codice attuale:**
```python
     27:     # Mock counts
     28:     # Code calls Certificato count first, then Dipendente count using scalar()
 >>> 29:     mock_db.query.return_value.scalar.side_effect = [50, 10] # Certs=50, Employees=10
     30:     # We need to simulate the objects structure
     31:     cert_expired = MagicMock(spec=Certificato)
```

**‚ùì Perch√© √® un problema:**

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

**üìù Descrizione:**

### Why is this an issue?

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

---

## üìÑ `tests/app/services/test_sync_service.py`
**1 issue(s)** | Effort: 5min

### Riga 95 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "mock_listdir".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 32-44 |
| Tags | unused |

**üíª Codice attuale:**
```python
     93:     with patch("os.rmdir") as mock_rmdir, \
     94:          patch("os.path.isdir", return_value=True), \
 >>> 95:          patch("os.listdir") as mock_listdir:
     96:          
     97:          # Setup mocks
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `app/services/file_maintenance.py`
**1 issue(s)** | Effort: 22min

### Riga 16 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 32 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 22min |
| Posizione | Colonne 4-28 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     14: logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
     15: 
 >>> 16: def scan_and_archive_orphans(db: Session, database_path: str):
     17:     """
     18:     Bug 8 Fix: Identify files in 'DOCUMENTI DIPENDENTI' that are NOT in the database.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `app/services/certificate_logic.py`
**1 issue(s)** | Effort: 19min

### Riga 72 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 29 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 19min |
| Posizione | Colonne 4-33 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     70:     return "archiviato" if newer_cert_exists else "scaduto"
     71: 
 >>> 72: def get_bulk_certificate_statuses(db: Session, certificati: List[Certificato]) -&gt; Dict[int, str]:
     73:     """
     74:     Calcola lo stato per una lista di certificati in modo efficiente (bulk).
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `desktop_app/workers/file_scanner_worker.py`
**1 issue(s)** | Effort: 13min

### Riga 11 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 23 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 13min |
| Posizione | Colonne 8-11 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     9:         self.urls = urls
     10: 
 >>> 11:     def run(self):
     12:         files_to_process = []
     13:         for url in self.urls:
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `desktop_app/components/notification_center.py`
**1 issue(s)** | Effort: 5min

### Riga 85 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     83:                 elif isinstance(ts_str, datetime):
     84:                     time_str = ts_str.strftime("%H:%M")
 >>> 85:             except:
     86:                 pass
     87: 
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

## üìÑ `desktop_app/components/toast.py`
**1 issue(s)** | Effort: 7min

### Riga 191 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 17 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 7min |
| Posizione | Colonne 8-24 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     189: 
     190:     @pyqtSlot(object, str, str, str, int)
 >>> 191:     def _show_toast_slot(self, parent, type, title, message, duration):
     192:         # Add to history
     193:         self.add_to_history(type, title, message)
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `tests/app/services/test_notification_service_lock.py`
**1 issue(s)** | Effort: 5min

### Riga 30 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "MockSession".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 72-83 |
| Tags | unused |

**üíª Codice attuale:**
```python
     28:         mock_data.return_value = ([], [], [])
     29:         # Mock SessionLocal to avoid DB connection
 >>> 30:         with patch("app.services.notification_service.SessionLocal") as MockSession:
     31:              check_and_send_alerts()
     32:              mock_data.assert_called_once()
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/desktop_app/views/test_database_view_rendering.py`
**1 issue(s)** | Effort: 1min

### Riga 24 üü° üü° MAJOR

**üéØ Problema:** Remove this assignment to local variable 'app'; the value is never used.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1854` - Unused assignments should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 8-34 |
| Tags | cwe, unused |

**üíª Codice attuale:**
```python
     22:     app = QCoreApplication.instance()
     23:     if not app:
 >>> 24:         app = QCoreApplication([])
     25: 
     26:     # Setup data with lowercase and special chars
```

**‚ùì Perch√© √® un problema:**

Dead stores refer to assignments made to local variables that are subsequently never used or immediately overwritten. Such assignments are
unnecessary and don‚Äôt contribute to the functionality or clarity of the code. They may even negatively impact performance. Removing them enhances code
cleanliness and readability. Even if the unnecessary operations do not do any harm in terms of the program‚Äôs correctness, they are - at best - a waste
of computing resources.

#### Exceptions

This rule ignores initializations to `-1`, `0`, `1`, `None`, `True`, `False` and
`""`. No issue will be raised on unpacked variables.

**‚úÖ Come risolvere:**

Remove the unnecessary assignment, then test the code to make sure that the right-hand side of a given assignment had no side effects (e.g. a
method that writes certain data to a file and returns the number of written bytes).

##### Noncompliant code example

```
def func(a, b, compute):
 i = a + b # Noncompliant; calculation result not used before value is overwritten
 i = compute()
 return i
```

##### Compliant solution

```
def func(a, b, compute):
 i = a + b
 i += compute()
 return i
```

**üìö Risorse:**

#### Standards

 - CWE - [CWE-563 - Assignment to Variable without Use ('Unused Variable')](https://cwe.mitre.org/data/definitions/563) 

#### Related rules

 - S1763 - All code should be reachable 

 - S3516 - Functions returns should not be invariant 

 - S3626 - Jump statements should not be redundant

---

## üìÑ `tests/app/api/routers/test_system_edge_cases.py`
**1 issue(s)** | Effort: 5min

### Riga 12 üü° üü¢ MINOR

**üéØ Problema:** Replace this comprehension with passing the iterable to the collection constructor call

| Campo | Valore |
|-------|--------|
| Regola | `python:S7500` - Comprehensions only used to copy should be replaced with the respective constructor calls |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 56-71 |

**üíª Codice attuale:**
```python
     10:     # When 'from desktop_app.ipc_bridge import IPCBridge' runs, it does getattr(module, 'IPCBridge')
     11:     # We make that raise ImportError
 >>> 12:     type(mock_module).IPCBridge = property(lambda self: (_ for _ in ()).throw(ImportError("No IPC")))
     13: 
     14:     with patch.dict(sys.modules, {"desktop_app.ipc_bridge": mock_module}):
```

**‚ùì Perch√© √® un problema:**

Python comprehensions are a concise way to create new collections while transforming or filtering elements. However, using a comprehension that
copies elements from one collection to another without any transformation is less readable than using the respective constructor directly.

Therefore, when a comprehension is only copying elements, use the appropriate constructor instead:

 - Replace `[x for x in iterable]` with `list(iterable)` 

 - Replace `{x for x in iterable}` with `set(iterable)` 

 - Replace `{k: v for k, v in iterable.items()}` with `dict(iterable)`

**‚úÖ Come risolvere:**

Replace comprehensions that copy elements from one collection to another with the respective constructor.

##### Noncompliant code example

```
some_list = [1, 2, 3, 2]
[x for x in some_list] # Noncompliant
```

##### Compliant solution

```
some_list = [1, 2, 3, 2]
list(some_list) # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [dict()](https://docs.python.org/3/library/stdtypes.html#dict) 

 - Python Documentation - [list()](https://docs.python.org/3/library/stdtypes.html#list) 

 - Python Documentation - [set()](https://docs.python.org/3/library/stdtypes.html#set)

---

## üìÑ `tests/app/api/routers/test_stats_full.py`
**1 issue(s)** | Effort: 5min

### Riga 26 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "threshold".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-13 |
| Tags | unused |

**üíª Codice attuale:**
```python
     24:     # Certificati
     25:     today = date.today()
 >>> 26:     threshold = today + timedelta(days=settings.ALERT_THRESHOLD_DAYS)
     27: 
     28:     # 1. Valid (Active)
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/app/api/routers/test_auth_security_critical.py`
**1 issue(s)** | Effort: 5min

### Riga 45 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused loop index "i" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 8-9 |
| Tags | unused |

**üíª Codice attuale:**
```python
     43:     # 5 past failures -&gt; 6th attempt fails -&gt; Log CRITICAL.
     44: 
 >>> 45:     for i in range(5):
     46:         response = test_client.post(
     47:             "/auth/login", # relative to base_url set in test_client
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/app/services/test_ai_extraction_robustness.py`
**1 issue(s)** | Effort: 5min

### Riga 77 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "client".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-10 |
| Tags | unused |

**üíª Codice attuale:**
```python
     75: def mock_model(mock_settings, mock_genai, reset_singleton):
     76:     """Initializes the client and returns the mocked model."""
 >>> 77:     client = GeminiClient()
     78:     mock_model_instance = mock_genai.GenerativeModel.return_value
     79:     return mock_model_instance
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `desktop_app/chat/chat_controller.py`
**1 issue(s)** | Effort: 5min

### Riga 233 üü° üî¥ CRITICAL

**üéØ Problema:** Add a nested comment explaining why this method is empty, or complete the implementation.

| Campo | Valore |
|-------|--------|
| Regola | `python:S1186` - Functions and methods should not be empty |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-26 |
| Tags | suspicious |

**üíª Codice attuale:**
```python
     231:         self.response_ready.emit(f"Errore: {error_msg}")
     232: 
 >>> 233:     def _on_worker_cleanup(self):
     234:         pass
     235: 
```

**‚ùì Perch√© √® un problema:**

An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no
functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.

There are several reasons for a method not to have a body:

 - It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. 

 - It is not yet, or never will be, supported. In this case an exception should be thrown. 

 - The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. 

#### Exceptions

No issue will be raised when the empty method is abstract and meant to be overridden in a subclass, i.e. it is decorated with
`abc.abstractmethod`, `abc.abstractstaticmethod`, `abc.abstractclassmethod` or `abc.abstractproperty`.
Note however that these methods should normally have a docstring explaining how subc...

**‚úÖ Come risolvere:**

##### Noncompliant code example

```
def shouldNotBeEmpty(): # Noncompliant - method is empty
 pass

def notImplemented(): # Noncompliant - method is empty
 pass

def emptyOnPurpose(): # Noncompliant - method is empty
 pass
```

##### Compliant solution

```
def shouldNotBeEmpty():
 doSomething()

def notImplemented():
 raise NotImplementedError("notImplemented() cannot be performed because ...")

def emptyOnPurpose():
 pass # comment explaining why the method is empty

def emptyOnPurposeBis():
 """
 Docstring explaining why this function is empty.
 """
```

---

## üìÑ `desktop_app/workers/chat_worker.py`
**1 issue(s)** | Effort: 5min

### Riga 104 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 16-22 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     102:                         status_emoji = "‚ö†Ô∏è" if expiry &lt;= today else "üìÖ"
     103:                         results.append(f"{status_emoji} {c.get('nome')} - {c.get('nome_corso')}: Scade il {expiry_str}")
 >>> 104:                 except:
     105:                     continue
     106:             return results[:30]
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

## üìÑ `desktop_app/services/voice_service.py`
**1 issue(s)** | Effort: 5min

### Riga 140 üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 12-18 |
| Tags | bad-practice, error-handling, suspicious |

**üíª Codice attuale:**
```python
     138:             try:
     139:                 os.remove(self._current_file)
 >>> 140:             except:
     141:                 pass
     142: 
```

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

## üìÑ `app/api/routers/stats.py`
**1 issue(s)** | Effort: 5min

### Riga 39 üü° üü° MAJOR

**üéØ Problema:** Remove this commented out code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S125` - Sections of code should not be commented out |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 8-48 |
| Tags | unused |

**üíª Codice attuale:**
```python
     37:     compliance = 0
     38:     if total_certificati &gt; 0:
 >>> 39:         # Compliance = (Total - Scaduti) / Total
     40:         compliance = int(((total_certificati - scaduti) / total_certificati) * 100)
     41: 
```

**‚ùì Perch√© √® un problema:**

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

**üìù Descrizione:**

### Why is this an issue?

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

---

## üìÑ `desktop_app/views/stats_view.py`
**1 issue(s)** | Effort: 5min

### Riga 44 üü° üü° MAJOR

**üéØ Problema:** Extract this nested conditional expression into an independent statement.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3358` - Conditional expressions should not be nested |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 113-160 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     42:         header.addStretch()
     43:         lbl_val = QLabel(f"{compliance_pct}%")
 >>> 44:         lbl_val.setStyleSheet(f"font-weight: 700; font-size: 14px; color: {'#10B981' if compliance_pct &gt; 80 else '#F59E0B' if compliance_pct &gt; 50 else '#EF4444'};")
     45:         header.addWidget(lbl_val)
     46:         layout.addLayout(header)
```

**‚ùì Perch√© √® un problema:**

Nested conditionals are hard to read and can make the order of operations complex to understand.

```
class Job:
 @property
 def readable_status(self):
 return "Running" if job.is_running else "Failed" if job.errors else "Succeeded" # Noncompliant
```

Instead, use another line to express the nested operation in a separate statement.

```
class Job:
 @property
 def readable_status(self):
 if job.is_running:
 return "Running"
 return "Failed" if job.errors else "Succeeded"
```

#### Exceptions

No issue is raised on conditional expressions in comprehensions.

```
job_statuses = ["Running" if job.is_running else "Failed" if job.errors else "Succeeded" for job in jobs] # Compliant by exception
```

**üìù Descrizione:**

### Why is this an issue?

Nested conditionals are hard to read and can make the order of operations complex to understand.

```
class Job:
 @property
 def readable_status(self):
 return "Running" if job.is_running else "Failed" if job.errors else "Succeeded" # Noncompliant
```

Instead, use another line to express the nested operation in a separate statement.

```
class Job:
 @property
 def readable_status(self):
 if job.is_running:
 return "Running"
 return "Failed" if job.errors else "Succeeded"
```

#### Exceptions

No issue is raised on conditional expressions in comprehensions.

```
job_statuses = ["Running" if job.is_running else "Failed" if job.errors else "Succeeded" for job in jobs] # Compliant by exception
```

---

## üìÑ `desktop_app/api_client.py`
**1 issue(s)** | Effort: 20min

### Riga 91 üü° üü° MAJOR

**üéØ Problema:** Replace this generic exception class with a more specific one.

| Campo | Valore |
|-------|--------|
| Regola | `python:S112` - "Exception" and "BaseException" should not be raised |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 20min |
| Posizione | Colonne 18-88 |
| Tags | cwe, error-handling |

**üíª Codice attuale:**
```python
     89:             return response.json()
     90:         except (requests.exceptions.ConnectionError, requests.exceptions.Timeout):
 >>> 91:             raise Exception("Impossibile connettersi al server (Rete irraggiungibile).")
     92: 
     93:     def change_password(self, old_password, new_password):
```

**‚ùì Perch√© √® un problema:**

Raising instances of [`Exception`](https://docs.python.org/3/library/exceptions.html#Exception) and [`BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException) will have a negative impact on any code trying
to catch these exceptions.

From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.

Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.

For instance, if an exception such as `SystemExit` is caught and not re-raised, it will preve...

**‚úÖ Come risolvere:**

To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:

 - Raise a specific [Built-in exception](https://docs.python.org/3/library/exceptions.html) when one matches. For example
 `TypeError` should be raised when the type of a parameter is not the one expected. 

 - Create a custom exception class deriving from `Exception` or one of its subclasses. 

##### Noncompliant code example

```
def check_value(value):
 if value &lt; 0:
 raise BaseException("Value cannot be negative") # Noncompliant: this will be difficult for consumers to handle
```

##### Compliant solution

```
def check_value(value):
 if value &lt; 0:
 raise ValueError("Value cannot be negative") # Compliant
```

**üìö Risorse:**

#### Documentation

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html#BaseException) 

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes)

---

## üìÑ `desktop_app/components/visuals.py`
**1 issue(s)** | Effort: 5min

### Riga 43 üü° üü° MAJOR

**üéØ Problema:** Remove this commented out code.

| Campo | Valore |
|-------|--------|
| Regola | `python:S125` - Sections of code should not be commented out |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 12-31 |
| Tags | unused |

**üíª Codice attuale:**
```python
     41:                 p['life'] = 0 # Arrived
     42:                 
 >>> 43:             # p['life'] -= 0.01
     44:             
     45:         self.particles = [p for p in self.particles if p['life'] &gt; 0]
```

**‚ùì Perch√© √® un problema:**

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

**üìù Descrizione:**

### Why is this an issue?

Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.

Commented-out code should be deleted and can be retrieved from source control history if required.

---

## üìÑ `desktop_app/views/splash_screen.py`
**1 issue(s)** | Effort: 6min

### Riga 329 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 8-21 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     327:             self.detail_timer.stop()
     328: 
 >>> 329:     def update_status(self, message, progress=None):
     330:         clean_message = message.rstrip('.')
     331: 
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `tests/desktop_app/services/test_security_service.py`
**1 issue(s)** | Effort: 5min

### Riga 70 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "msg" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 16-19 |
| Tags | unused |

**üíª Codice attuale:**
```python
     68:         mock_gettrace.return_value = None
     69: 
 >>> 70:         is_dbg, msg = is_debugger_active()
     71:         assert is_dbg is False
     72: 
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `tests/conftest.py`
**1 issue(s)** | Effort: 5min

### Riga 150 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "connection".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 4-14 |
| Tags | unused |

**üíª Codice attuale:**
```python
     148:     # 4. Initialize Connection (This triggers load_memory_db, which will find no file and start empty)
     149:     # We call get_connection explicitly to ensure the global 'active_connection' is set
 >>> 150:     connection = db_security.get_connection()
     151:     
     152:     # 5. Create Tables
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `guide_frontend/src/components/FeedbackFooter.jsx`
**1 issue(s)** | Effort: 2min

### Riga 26 üü° üü¢ MINOR

**üéØ Problema:** Unexpected negated condition.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S7735` - Negated conditions should be avoided when an else clause is present |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 11-17 |
| Tags | readability |

**üíª Codice attuale:**
```jsx
     24: 
     25:         &lt;AnimatePresence mode="wait"&gt;
 >>> 26:           {!voted ? (
     27:             &lt;motion.div
     28:               key="voting"
```

**‚ùì Perch√© √® un problema:**

Negated conditions in if-else statements can make code harder to read and understand. When you see `if (!condition)`, your brain has to
process the negation, which adds cognitive load.

Positive conditions are generally easier to understand because they describe what **is** true rather than what **is not**
true. When you have both an if and else branch, you can usually invert the condition and swap the branches to make the code more readable.

For example, `if (!user.isActive)` requires you to think "if the user is NOT active", while `if (user.isActive)` is more
direct: "if the user is active".

This pattern is especially problematic with:

 - Boolean negation using the `!` operator 

 - Inequality comparisons like `!==` and `!=` 

 - Complex expressions where the negation makes the logic harder to follow 

The rule only flags cases where there‚Äôs an else clause because single if statements with negated conditions are sometimes the clearest way to
express "do something when this conditi...

**üìù Descrizione:**

This rule raises an issue when an if-else statement or ternary operator uses a negated condition that could be inverted to improve readability.

### Why is this an issue?

Negated conditions in if-else statements can make code harder to read and understand. When you see `if (!condition)`, your brain has to
process the negation, which adds cognitive load.

Positive conditions are generally easier to understand because they describe what **is** true rather than what **is not**
true. When you have both an if and else branch, you can usually invert the condition and swap the branches to make the code more readable.

For example, `if (!user.isActive)` requires you to think "if the user is NOT active", while `if (user.isActive)` is more
direct: "if the user is active".

This pattern is especially problematic with:

 - Boolean negation using the `!` operator 

 - Inequality comparisons like `!==` and `!=` 

 - Complex expressions where the negation makes the logic harder to follow 

The rule ...

---

## üìÑ `guide_frontend/src/components/Header.jsx`
**1 issue(s)** | Effort: 5min

### Riga 93 üü° üü° MAJOR

**üéØ Problema:** Do not use Array index in keys

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S6479` - JSX list components should not use array indexes as key |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 5min |
| Posizione | Colonne 25-30 |
| Tags | jsx, performance, react |

**üíª Codice attuale:**
```jsx
     91:                 results.map((result, index) =&gt; (
     92:                   &lt;button
 >>> 93:                     key={index}
     94:                     onClick={() =&gt; selectResult(result.path)}
     95:                     className="w-full text-left px-4 py-2.5 hover:bg-blue-50 flex items-center gap-3 transition-colors group"
```

**‚ùì Perch√© √® un problema:**

To optimize the rendering of React list components, a unique identifier (UID) is required for each list item. This UID lets React identify the item
throughout its lifetime. Avoid array indexes since the order of the items may change, which will cause keys to not match up between renders,
recreating the DOM. It can negatively impact performance and may cause issues with the component state.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((post, index) =&gt;
 &lt;li key={index}&gt; &lt;!-- Noncompliant: When 'posts' are reordered, React will need to recreate the list DOM --&gt;
 {post.title}
 &lt;/li&gt;
 )}
 &lt;/ul&gt;
 );
}
```

To fix it, use a string or a number that uniquely identifies the list item. The key must be unique among its siblings, not globally.

If the data comes from a database, database IDs are already unique and are the best option. Otherwise, use a counter or a UUID generator.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((p...

**üìù Descrizione:**

### Why is this an issue?

To optimize the rendering of React list components, a unique identifier (UID) is required for each list item. This UID lets React identify the item
throughout its lifetime. Avoid array indexes since the order of the items may change, which will cause keys to not match up between renders,
recreating the DOM. It can negatively impact performance and may cause issues with the component state.

```
function Blog(props) {
 return (
 &lt;ul&gt;
 {props.posts.map((post, index) =&gt;
 &lt;li key={index}&gt; &lt;!-- Noncompliant: When 'posts' are reordered, React will need to recreate the list DOM --&gt;
 {post.title}
 &lt;/li&gt;
 )}
 &lt;/ul&gt;
 );
}
```

To fix it, use a string or a number that uniquely identifies the list item. The key must be unique among its siblings, not globally.

If the data comes from a database, database IDs are already unique and are the best option. Otherwise, use a counter or a UUID generator.

```
function Blog(props) {
 return (
 &lt;...

**üìö Risorse:**

#### Documentation

 - [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) - Rule [no-array-index-key](https://github.com/jsx-eslint/eslint-plugin-react/blob/HEAD/docs/rules/no-array-index-key.md) 

 - React Documentation - [Rendering lists](https://react.dev/learn/rendering-lists#rules-of-keys) 

 - React Documentation - [Recursing On Children](https://reactjs.org/docs/reconciliation.html#recursing-on-children) 

 - MDN web docs - [Crypto: randomUUID() method](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID) 

 - Wikipedia - [UUID](https://en.wikipedia....

---

## üìÑ `guide_frontend/src/components/ValidationSimulator.jsx`
**1 issue(s)** | Effort: 2min

### Riga 102 üü° üü¢ MINOR

**üéØ Problema:** Prefer `globalThis` over `window`.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S7764` - Use "globalThis" instead of "window", "self", or "global" |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 2min |
| Posizione | Colonne 39-45 |
| Tags | es2020, portability |

**üíª Codice attuale:**
```jsx
     100:                 &lt;Check size={48} className="mb-4 text-green-200" /&gt;
     101:                 &lt;p&gt;Tutto fatto! Nessun documento in attesa.&lt;/p&gt;
 >>> 102:                 &lt;button onClick={() =&gt; window.location.reload()} className="mt-4 text-xs text-blue-500 underline"&gt;
     103:                     Ricarica simulazione
     104:                 &lt;/button&gt;
```

**‚ùì Perch√© √® un problema:**

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
properties.

#### What is the potential impact?

Using environment-specific global references reduces code portability and can cause runtime errors when code is moved between different...

**üìù Descrizione:**

This rule raises an issue when code uses `window`, `self`, or `global` to access the global object, except for
environment-specific APIs and events.

### Why is this an issue?

`globalThis` is the standardized way to access the global object across all JavaScript environments. Before `globalThis`,
developers had to use different global references depending on the environment:

 - `window` in browsers 

 - `global` in Node.js 

 - `self` in Web Workers 

This created compatibility issues when code needed to run in multiple environments. Using environment-specific globals makes code less portable and
harder to maintain.

`globalThis` was introduced in ES2020 as a unified solution that works consistently across all JavaScript environments. It provides the
same global object reference regardless of whether your code runs in a browser, Node.js, or Web Worker.

Using `globalThis` makes your code more future-proof and eliminates the need for environment detection when accessing global
propert...

---

## üìÑ `guide_frontend/src/hooks/useSearch.js`
**1 issue(s)** | Effort: 1min

### Riga 1 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'useMemo'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 30-37 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```javascript
 >>> 1: import { useState, useEffect, useMemo } from 'react';
     2: import { useNavigate } from 'react-router-dom';
     3: 
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

## üìÑ `guide_frontend/src/pages/MaintenanceGuide.jsx`
**1 issue(s)** | Effort: 1min

### Riga 5 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'HardDrive'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 18-27 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     3: import Note from '../components/ui/Note';
     4: import Step from '../components/ui/Step';
 >>> 5: import { Archive, HardDrive, RefreshCw } from 'lucide-react';
     6: 
     7: const MaintenanceGuide = () =&gt; {
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

## üìÑ `guide_frontend/src/pages/TroubleshootingGuide.jsx`
**1 issue(s)** | Effort: 1min

### Riga 3 üü° üü¢ MINOR

**üéØ Problema:** Remove this unused import of 'Note'.

| Campo | Valore |
|-------|--------|
| Regola | `javascript:S1128` - Unnecessary imports should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 1min |
| Posizione | Colonne 7-11 |
| Tags | es2015, type-dependent, unused |

**üíª Codice attuale:**
```jsx
     1: import React from 'react';
     2: import GuideCard from '../components/ui/GuideCard';
 >>> 3: import Note from '../components/ui/Note';
     4: import Accordion from '../components/ui/Accordion';
     5: import { HelpCircle, WifiOff, FileX, ShieldAlert } from 'lucide-react';
```

**‚ùì Perch√© √® un problema:**

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

**üìù Descrizione:**

### Why is this an issue?

Unnecessary imports refer to importing modules, libraries, or dependencies that are not used or referenced anywhere in the code. These imports do
not contribute to the functionality of the application and only add extra weight to the JavaScript bundle, leading to potential performance and
maintainability issues.

```
import A from 'a'; // Noncompliant: The imported symbol 'A' isn't used
import { B1 } from 'b';

console.log(B1);
```

To mitigate the problems associated with unnecessary imports, you should regularly review and remove any imports that are not being used. Modern
JavaScript build tools and bundlers often provide features like tree shaking, which eliminates unused code during the bundling process, resulting in a
more optimized bundle size.

```
import { B1 } from 'b';

console.log(B1);
```

### Resources

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Rela...

**üìö Risorse:**

#### Documentation

 - MDN web docs - [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 

#### Related rules

 - S1481 - Unused local variables and functions should be removed

---

## üìÑ `app/services/document_locator.py`
**1 issue(s)** | Effort: 9min

### Riga 5 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 19 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 9min |
| Posizione | Colonne 4-17 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     3: from app.utils.file_security import sanitize_filename
     4: 
 >>> 5: def find_document(database_path: str, cert_data: dict) -&gt; str | None:
     6:     """
     7:     Locates the certificate PDF within the database directory structure.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `desktop_app/services/time_service.py`
**1 issue(s)** | Effort: 5min

### Riga 75 üü° üü¢ MINOR

**üéØ Problema:** Replace the unused local variable "address" with "_".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 14-21 |
| Tags | unused |

**üíª Codice attuale:**
```python
     73:         data = b'\x1b' + 47 * b'\0'
     74:         client.sendto(data, (NTP_SERVER, 123))
 >>> 75:         data, address = client.recvfrom(1024)
     76:         if data:
     77:             t = struct.unpack('!12I', data)[10]
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `admin/offusca/rthook_pyqt6.py`
**1 issue(s)** | Effort: 5min

### Riga 16 üü° üü¢ MINOR

**üéØ Problema:** Remove the unused local variable "e".

| Campo | Valore |
|-------|--------|
| Regola | `python:S1481` - Unused local variables should be removed |
| Categoria | MAINTAINABILITY |
| Severit√† | MINOR |
| Effort | 5min |
| Posizione | Colonne 26-27 |
| Tags | unused |

**üíª Codice attuale:**
```python
     14:         import PyQt6.QtNetwork
     15:         import PyQt6.QtPrintSupport
 >>> 16:     except ImportError as e:
     17:         # Ignora errori in fase di hook, verranno gestiti dal main se bloccanti
     18:         pass
```

**‚ùì Perch√© √® un problema:**

An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.

#### What is the potential impact?

Having unused local variables in your code can lead to several issues:

 - **Decreased Readability**: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
 can distract from the main logic of the code. 

 - **Misunderstanding**: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
 to confusion and misinterpretation of the code‚Äôs intent. 

 - **Potential for Bugs**: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
 declared a variable intending to use it in a calculation, but then ...

**‚úÖ Come risolvere:**

The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.

##### Noncompliant code example

```
def hello(name):
 message = "Hello " + name # Noncompliant - message is unused
 print(name)
for i in range(10): # Noncompliant - i is unused
 foo()
```

##### Compliant solution

```
def hello(name):
 message = "Hello " + name
 print(message)
for _ in range(10):
 foo()
```

---

## üìÑ `app/main.py`
**1 issue(s)** | Effort: 5min

### Riga ? üü° üî¥ CRITICAL

**üéØ Problema:** Specify an exception class to catch or reraise the exception

| Campo | Valore |
|-------|--------|
| Regola | `python:S5754` - "SystemExit" should be re-raised |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 5min |
| Posizione | Colonne 8-14 |
| Tags | bad-practice, error-handling, suspicious |

**‚ùì Perch√© √® un problema:**

A [`SystemExit`](https://docs.python.org/3/library/exceptions.html#SystemExit) exception is raised when [`sys.exit()`](https://docs.python.org/3/library/sys.html#sys.exit) is called. This exception is used to signal the interpreter to
exit. The exception is expected to propagate up until the program stops. It is possible to catch this exception in order to perform, for example,
clean-up tasks. It should, however, be raised again to allow the interpreter to exit as expected. Not re-raising such exception could lead to
undesired behaviour.

A [bare `except:` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement), i.e. an
`except` block without any exception class, is equivalent to [`except BaseException`](https://docs.python.org/3/library/exceptions.html#BaseException). Both statements will catch every
exceptions, including `SystemExit`. It is recommended to catch instead a more specific exception. If it is not possible, the exception
should be raised again...

**‚úÖ Come risolvere:**

Re-raise `SystemExit`, `BaseException` and any exceptions caught in a bare `except` clause.

##### Noncompliant code example

```
try:
 ...
except SystemExit: # Noncompliant: the SystemExit exception is not re-raised.
 pass

try:
 ...
except BaseException: # Noncompliant: BaseExceptions encompass SystemExit exceptions and should be re-raised.
 pass

try:
 ...
except: # Noncompliant: exceptions caught by this statement should be re-raised or a more specific exception should be caught.
 pass
```

##### Compliant solution

```
try:
 ...
except SystemExit as e:
 ...
 raise e

try:
 ...
except BaseException as e:
 ...
 raise e

try:
 ...
except FileNotFoundError:
 ... # Handle a more specific exception
```

**üìö Risorse:**

#### Documentation

 - PEP 352 - [Required Superclass for Exceptions](https://www.python.org/dev/peps/pep-0352/#id5) 

 - Python Documentation - [Built-in exceptions](https://docs.python.org/3/library/exceptions.html) 

 - Python Documentation - [The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)
 

 - CWE - [CWE-391, Unchecked Error Condition](https://cwe.mitre.org/data/definitions/391)

---

## üìÑ `app/utils/audit.py`
**1 issue(s)** | Effort: 6min

### Riga 8 üü° üî¥ CRITICAL

**üéØ Problema:** Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3776` - Cognitive Complexity of functions should not be too high |
| Categoria | MAINTAINABILITY |
| Severit√† | CRITICAL |
| Effort | 6min |
| Posizione | Colonne 4-23 |
| Tags | brain-overload |

**üíª Codice attuale:**
```python
     6: from app.services.geo_service import GeoLocationService
     7: 
 >>> 8: def log_security_action(db: Session, user: Optional[User], action: str, details: str = None, category: str = None, request: Request = None, severity: str = "LOW", changes: str = None, device_id: str = None):
     9:     """
     10:     Logs a security-critical action to the database.
```

**‚ùì Perch√© √® un problema:**

Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.

As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.

#### Which syntax in code does impact cognitive complexity score?

Here are the core concepts:

 - **Cognitive complexity is incremented each time the code breaks the normal linear reading flow.**
 This concerns, for example,
 loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. 

 - **Each nesting level increases complexity.**
 During code reading, the deeper you go through nested layers, the harder it
 becomes to keep the context in mind. 

 - **Method calls are free**
 A well-picked method name is a summary of multiple lines of code. A reader can first explore a
 high-level view of what the code is performing then go...

**‚úÖ Come risolvere:**

Reducing cognitive complexity can be challenging.
 Here are a few suggestions:

 - **Extract complex conditions in a new function.**
 Mixed operators in condition will increase complexity. Extracting the
 condition in a new function with an appropriate name will reduce cognitive load. 

 - **Break down large functions.**
 Large functions can be hard to understand and maintain. If a function is doing too many
 things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. 

 - **Avoid deep nesting by returning early.**
 To avoid the nesting of conditions, process exceptional cases first and return
 early. 

**Extraction of a complex condition in a new function.**

##### Noncompliant code example

The code is using a complex condition and has a cognitive cost of 5.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if ((user.is_active and # +1 (if) +1 (nested) +1 (multiple conditions)
 user.has_profile) or # +1 (mixed operator)
 user.age &gt; 18 ):
 user.process()
```

##### Compliant solution

Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
`process_eligible_users` function, which now only has a cognitive cost of 3.

```
def process_eligible_users(users):
 for user in users: # +1 (for)
 if is_eligible_user(user): # +1 (if) +1 (nested)
 user.process()

def is_eligible_user(user):
 return ((user.is_active and user.has_p...

**üìö Risorse:**

#### Documentation

 - Sonar - [Cognitive Complexity](https://www.sonarsource.com/docs/CognitiveComplexity.pdf) 

#### Articles & blog posts

 - Sonar Blog - 5 Clean Code Tips for Reducing
 Cognitive Complexity

---

## üìÑ `tests/app/api/test_audit_advanced.py`
**1 issue(s)** | Effort: 1min

### Riga 45 üü° üü° MAJOR

**üéØ Problema:** Add replacement fields or use a normal string instead of an f-string.

| Campo | Valore |
|-------|--------|
| Regola | `python:S3457` - String formatting should be used correctly |
| Categoria | MAINTAINABILITY |
| Severit√† | MAJOR |
| Effort | 1min |
| Posizione | Colonne 27-51 |
| Tags | confusing |

**üíª Codice attuale:**
```python
     43: 
     44:     # 4. Filter by Category
 >>> 45:     resp = test_client.get(f"/audit/?category=AUTH")
     46:     assert resp.status_code == 200
     47:     data = resp.json()
```

**‚ùì Perch√© √® un problema:**

A format string is a string that contains placeholders, usually represented by special characters such as "%s" or "{}", depending on the technology
in use. These placeholders are replaced by values when the string is printed or logged. Thus, it is required that a string is valid and arguments
match replacement fields in this string.

This applies to [the % operator](https://docs.python.org/3/tutorial/inputoutput.html#old-string-formatting), the [str.format](https://docs.python.org/3/tutorial/inputoutput.html#the-string-format-method) method, and loggers from the [logging](https://docs.python.org/3/library/logging.html) module. Internally, the latter use the `%-formatting`. The only
difference is that they will log an error instead of raising an exception when the provided arguments are invalid.

Formatted string literals (also called "f-strings"; available since Python 3.6) are generally simpler to use, and any syntax mistake will cause a
failure at compile time. However, it is easy to...

**‚úÖ Come risolvere:**

A `printf-`-style format string is a string that contains placeholders, which are replaced by values when the string is printed or
logged. Mismatch in the format specifiers and the arguments provided can lead to incorrect strings being created.

To avoid issues, a developer should ensure that the provided arguments match format specifiers.

##### Noncompliant code example

```
"Error %(message)s" % {"message": "something failed", "extra": "some dead code"} # Noncompliant. Remove the unused argument "extra" or add a replacement field.

"Error: User {} has not been able to access []".format("Alice", "MyFile") # Noncompliant. Remove 1 unexpected argument or add a replacement field.

user = "Alice"
resource = "MyFile"
message = f"Error: User [user] has not been able to access [resource]" # Noncompliant. Add replacement fields or use a normal string instead of an f-string.

import logging
logging.error("Error: User %s has not been able to access %s", "Alice") # Noncompliant. Add 1 missing argument.
```

##### Compliant solution

```
"Error %(message)s" % {"message": "something failed"}

"Error: User {} has not been able to access {}".format("Alice", "MyFile")

user = "Alice"
resource = "MyFile"
message = f"Error: User {user} has not been able to access {resource}"

import logging
logging.error("Error: User %s has not been able to access %s", "Alice", "MyFile")
```

**üìö Risorse:**

- [Python documentation - Format String Syntax](https://docs.python.org/3/library/string.html#format-string-syntax) 

 - Python documentation - printf-style String
 Formatting 

 - [Python documentation - Loggers](https://docs.python.org/3/howto/logging.html#loggers) 

 - Python
 documentation - Using particular formatting styles throughout your application 

 - Python documentation - Formatted string
 literals

---
