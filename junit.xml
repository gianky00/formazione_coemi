<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="26" skipped="16" tests="583" time="103.837" timestamp="2025-12-08T13:10:44.812754+01:00" hostname="gianky-PC"><testcase classname="tests.app.api.routers.test_app_config" name="test_get_updater_config" time="0.017" /><testcase classname="tests.app.api.routers.test_app_config" name="test_get_mutable_config_as_admin" time="0.015" /><testcase classname="tests.app.api.routers.test_app_config" name="test_get_mutable_config_as_non_admin" time="0.008" /><testcase classname="tests.app.api.routers.test_app_config" name="test_update_mutable_config_as_admin" time="0.010" /><testcase classname="tests.app.api.routers.test_app_config" name="test_update_mutable_config_as_non_admin" time="0.008" /><testcase classname="tests.app.api.routers.test_app_config" name="test_update_mutable_config_with_invalid_data" time="0.008" /><testcase classname="tests.app.api.routers.test_app_config" name="test_update_mutable_config_with_empty_body" time="0.008" /><testcase classname="tests.app.api.routers.test_audit_edge_cases" name="test_export_audit_logs_empty" time="0.015" /><testcase classname="tests.app.api.routers.test_audit_edge_cases" name="test_read_audit_logs_end_date_midnight" time="0.014" /><testcase classname="tests.app.api.routers.test_auth_router" name="test_login_success" time="0.399" /><testcase classname="tests.app.api.routers.test_auth_router" name="test_login_failure" time="0.016" /><testcase classname="tests.app.api.routers.test_auth_router" name="test_login_brute_force_detection" time="0.034" /><testcase classname="tests.app.api.routers.test_auth_router" name="test_logout" time="0.014" /><testcase classname="tests.app.api.routers.test_auth_router" name="test_change_password_success" time="0.771" /><testcase classname="tests.app.api.routers.test_auth_router" name="test_change_password_wrong_old" time="0.390" /><testcase classname="tests.app.api.routers.test_auth_security_critical" name="test_brute_force_detection" time="1.369" /><testcase classname="tests.app.api.routers.test_auth_security_critical" name="test_login_session_locked" time="0.393" /><testcase classname="tests.app.api.routers.test_auth_security_critical" name="test_login_session_unlocked" time="0.393" /><testcase classname="tests.app.api.routers.test_auth_security_critical" name="test_logout_cleanup_called" time="0.397" /><testcase classname="tests.app.api.routers.test_chat" name="test_chat_endpoint_success" time="0.010" /><testcase classname="tests.app.api.routers.test_chat" name="test_chat_endpoint_error" time="0.009" /><testcase classname="tests.app.api.routers.test_config" name="test_move_database_endpoint" time="0.018" /><testcase classname="tests.app.api.routers.test_notifications" name="test_send_manual_alert_success" time="0.009" /><testcase classname="tests.app.api.routers.test_routers_complete" name="test_get_audit_logs_filters" time="0.018" /><testcase classname="tests.app.api.routers.test_routers_complete" name="test_audit_logs_export" time="0.010" /><testcase classname="tests.app.api.routers.test_routers_complete" name="test_system_maintenance" time="0.015" /><testcase classname="tests.app.api.routers.test_routers_complete" name="test_system_lock_status" time="0.009" /><testcase classname="tests.app.api.routers.test_routers_complete" name="test_system_optimize" time="0.013" /><testcase classname="tests.app.api.routers.test_routers_complete" name="test_system_open_action" time="0.008" /><testcase classname="tests.app.api.routers.test_routers_complete" name="test_toggle_security_mode" time="0.012" /><testcase classname="tests.app.api.routers.test_stats_full" name="test_get_stats_summary_logic" time="0.020" /><testcase classname="tests.app.api.routers.test_stats_full" name="test_get_compliance_by_category_logic" time="0.014" /><testcase classname="tests.app.api.routers.test_system" name="test_optimize_endpoint_async" time="0.001" /><testcase classname="tests.app.api.routers.test_system_edge_cases" name="test_open_action_ipc_import_error" time="0.010" /><testcase classname="tests.app.api.routers.test_system_edge_cases" name="test_open_action_generic_exception" time="0.009" /><testcase classname="tests.app.api.routers.test_users_full" name="test_read_users" time="0.010" /><testcase classname="tests.app.api.routers.test_users_full" name="test_create_user_success" time="0.013"><failure message="NameError: name 'os' is not defined. Did you forget to import 'os'">test_client = &lt;starlette.testclient.TestClient object at 0x000002B9CA33D3D0&gt;, admin_token_headers = {'Authorization': 'Bearer admin-token'}, admin_user = &lt;app.db.models.User object at 0x000002B9CA3CA930&gt;

    def test_create_user_success(test_client, admin_token_headers, admin_user):
        payload = {
            "username": "newuser",
            "account_name": "New User",
            "is_admin": False,
            "password": "initialpassword"
        }
    
&gt;       response = test_client.post("/users/", json=payload, headers=admin_token_headers)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\app\api\routers\test_users_full.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Lib\site-packages\starlette\testclient.py:552: in post
    return super().post(
Lib\site-packages\httpx\_client.py:1144: in post
    return self.request(
Lib\site-packages\starlette\testclient.py:451: in request
    return super().request(
Lib\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
Lib\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
Lib\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
Lib\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
Lib\site-packages\anyio\from_thread.py:326: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python312\Lib\concurrent\futures\_base.py:456: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python312\Lib\concurrent\futures\_base.py:401: in __get_result
    raise self._exception
Lib\site-packages\anyio\from_thread.py:257: in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\fastapi\applications.py:1134: in __call__
    await super().__call__(scope, receive, send)
Lib\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
Lib\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
Lib\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
Lib\site-packages\starlette\middleware\base.py:191: in __call__
    with recv_stream, send_stream, collapse_excgroups():
                                   ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python312\Lib\contextlib.py:158: in __exit__
    self.gen.throw(value)
Lib\site-packages\starlette\_utils.py:85: in collapse_excgroups
    raise exc
Lib\site-packages\starlette\middleware\base.py:193: in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app\main.py:140: in check_startup_error
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\starlette\middleware\base.py:168: in call_next
    raise app_exc from app_exc.__cause__ or app_exc.__context__
Lib\site-packages\starlette\middleware\base.py:144: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
Lib\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
Lib\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
Lib\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
Lib\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
Lib\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
Lib\site-packages\fastapi\routing.py:125: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
Lib\site-packages\fastapi\routing.py:111: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
Lib\site-packages\fastapi\routing.py:391: in app
    raw_response = await run_endpoint_function(
Lib\site-packages\fastapi\routing.py:292: in run_endpoint_function
    return await run_in_threadpool(dependant.call, **values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\starlette\concurrency.py:38: in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\anyio\to_thread.py:61: in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
Lib\site-packages\anyio\_backends\_asyncio.py:2525: in run_sync_in_worker_thread
    return await future
           ^^^^^^^^^^^^
Lib\site-packages\anyio\_backends\_asyncio.py:986: in run
    result = context.run(func, *args)
             ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @router.post("/", response_model=User, dependencies=[Depends(deps.check_write_permission)])
    def create_user(
        *,
        db: Session = Depends(get_db),
        user_in: UserCreate,
        current_user: UserModel = Depends(deps.get_current_active_admin),
    ) -&gt; Any:
        """
        Create new user.
        """
        user = db.query(UserModel).filter(UserModel.username == user_in.username).first()
        if user:
            raise HTTPException(
                status_code=400,
                detail="The user with this username already exists in the system.",
            )
    
        # Force default password to "primoaccesso"
&gt;       default_password = os.getenv("DEFAULT_USER_PASSWORD", "primoaccesso") # NOSONAR
                           ^^
E       NameError: name 'os' is not defined. Did you forget to import 'os'

app\api\routers\users.py:45: NameError</failure></testcase><testcase classname="tests.app.api.routers.test_users_full" name="test_create_user_duplicate" time="0.011" /><testcase classname="tests.app.api.routers.test_users_full" name="test_update_user_success" time="0.013" /><testcase classname="tests.app.api.routers.test_users_full" name="test_update_user_password" time="0.391" /><testcase classname="tests.app.api.routers.test_users_full" name="test_update_user_duplicate_username" time="0.013" /><testcase classname="tests.app.api.routers.test_users_full" name="test_update_user_not_found" time="0.011" /><testcase classname="tests.app.api.routers.test_users_full" name="test_delete_user_success" time="0.012" /><testcase classname="tests.app.api.routers.test_users_full" name="test_delete_user_self_prevention" time="0.010" /><testcase classname="tests.app.api.routers.test_users_full" name="test_delete_user_not_found" time="0.010" /><testcase classname="tests.app.api.test_audit_advanced" name="test_audit_log_filtering" time="0.021" /><testcase classname="tests.app.api.test_auth_flow" name="test_login_updates_previous_access" time="0.590" /><testcase classname="tests.app.api.test_csv_dates" name="test_csv_import_flexible_dates" time="0.016" /><testcase classname="tests.app.api.test_csv_import_linking" name="test_csv_import_links_orphaned_certificates" time="0.026" /><testcase classname="tests.app.api.test_csv_matricola_update" name="test_csv_rehiring_update_matricola" time="0.013" /><testcase classname="tests.app.api.test_csv_matricola_update" name="test_csv_duplicate_error" time="0.014" /><testcase classname="tests.app.api.test_csv_matricola_update" name="test_csv_broad_effect_linking" time="0.017" /><testcase classname="tests.app.api.test_csv_orphan_sync" name="test_csv_import_moves_orphan_file" time="0.021"><failure message="AssertionError: Old orphan file should be moved&#10;assert not True&#10; +  where True = &lt;built-in function _path_exists&gt;('C:\\Users\\gianc\\AppData\\Local\\Temp\\pytest-of-gianc\\pytest-46\\data0\\DOCUMENTI DIPENDENTI\\Bianchi Mario (N-A)\\ANTINCENDIO\\ATTIVO\\Bianchi Mario (N-A) - ANTINCENDIO - 01_01_2030.pdf')&#10; +    where &lt;built-in function _path_exists&gt; = &lt;module 'ntpath' (frozen)&gt;.exists&#10; +      where &lt;module 'ntpath' (frozen)&gt; = os.path">test_client = &lt;starlette.testclient.TestClient object at 0x000002B9CA0141A0&gt;, db_session = &lt;sqlalchemy.orm.session.Session object at 0x000002B9CA0145F0&gt;
test_dirs = WindowsPath('C:/Users/gianc/AppData/Local/Temp/pytest-of-gianc/pytest-46/data0')

    def test_csv_import_moves_orphan_file(test_client, db_session, test_dirs):
        # 1. Setup Orphan Cert
        cat = "ANTINCENDIO"
        orphan_name = "Bianchi Mario"
        corso = Corso(nome_corso="Corso A", categoria_corso=cat)
        cert = Certificato(
            dipendente_id=None,
            nome_dipendente_raw=orphan_name,
            corso=corso,
            data_rilascio=datetime.strptime("01/01/2020", "%d/%m/%Y").date(),
            data_scadenza_calcolata=datetime.strptime("01/01/2030", "%d/%m/%Y").date()
        )
        db_session.add(corso)
        db_session.add(cert)
        db_session.commit()
        db_session.refresh(cert)
    
        # 2. Setup Orphan File
        # Folder: Bianchi Mario (N-A)
        # Filename: Bianchi Mario (N-A) - ANTINCENDIO - 01_01_2030.pdf
        safe_name = sanitize_filename(orphan_name)
        folder = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI", f"{safe_name} (N-A)", cat, "ATTIVO")
        os.makedirs(folder, exist_ok=True)
        filename = f"{safe_name} (N-A) - {cat} - 01_01_2030.pdf"
        orphan_path = os.path.join(folder, filename)
    
        with open(orphan_path, "w") as f:
            f.write("content")
    
        assert os.path.exists(orphan_path)
    
        # 3. Create CSV Content
        # Cognome;Nome;Data_nascita;Badge;Data_assunzione
        csv_content = "Cognome;Nome;Data_nascita;Badge;Data_assunzione\nBianchi;Mario;;999;"
    
        # 4. Upload CSV
        response = test_client.post(
            "/dipendenti/import-csv",
            files={"file": ("test.csv", csv_content, "text/csv")}
        )
        assert response.status_code == 200
        assert "1 certificati orfani collegati" in response.json()["message"]
    
        # 5. Verify DB Link
        db_session.refresh(cert)
        assert cert.dipendente_id is not None
        assert cert.dipendente.matricola == "999"
    
        # 6. Verify File Move
        # Old path should be gone
&gt;       assert not os.path.exists(orphan_path), "Old orphan file should be moved"
E       AssertionError: Old orphan file should be moved
E       assert not True
E        +  where True = &lt;built-in function _path_exists&gt;('C:\\Users\\gianc\\AppData\\Local\\Temp\\pytest-of-gianc\\pytest-46\\data0\\DOCUMENTI DIPENDENTI\\Bianchi Mario (N-A)\\ANTINCENDIO\\ATTIVO\\Bianchi Mario (N-A) - ANTINCENDIO - 01_01_2030.pdf')
E        +    where &lt;built-in function _path_exists&gt; = &lt;module 'ntpath' (frozen)&gt;.exists
E        +      where &lt;module 'ntpath' (frozen)&gt; = os.path

tests\app\api\test_csv_orphan_sync.py:58: AssertionError</failure></testcase><testcase classname="tests.app.api.test_delete_cert_file_cleanup" name="test_delete_certificate_deletes_file" time="0.014"><failure message="Failed: File was not removed from original location.">test_client = &lt;starlette.testclient.TestClient object at 0x000002B9CA014710&gt;, db_session = &lt;sqlalchemy.orm.session.Session object at 0x000002B9CA016EA0&gt;
test_dirs = WindowsPath('C:/Users/gianc/AppData/Local/Temp/pytest-of-gianc/pytest-46/data0')

    def test_delete_certificate_deletes_file(test_client, db_session, test_dirs):
        # 1. Setup Data in DB
        cat = "ANTINCENDIO"
        dip = Dipendente(nome="Mario", cognome="Rossi", matricola="123")
        corso = Corso(nome_corso="Corso A", categoria_corso=cat)
        cert = Certificato(
            dipendente=dip,
            corso=corso,
            data_rilascio=datetime.strptime("01/01/2020", "%d/%m/%Y").date(),
            data_scadenza_calcolata=datetime.strptime("01/01/2025", "%d/%m/%Y").date()
        )
    
        db_session.add(dip)
        db_session.add(corso)
        db_session.add(cert)
        db_session.commit()
        db_session.refresh(cert)
    
        cert_id = cert.id
    
        # 2. Setup File on Disk
        # Full name: Rossi Mario
        nome_fs = sanitize_filename("Rossi Mario")
        matr_fs = sanitize_filename("123")
        cat_fs = sanitize_filename(cat)
    
        # Assuming "ATTIVO" status. document_locator searches all statuses so exact folder matters less,
        # but let's put it in ATTIVO for realism.
        folder = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI", f"{nome_fs} ({matr_fs})", cat_fs, "ATTIVO")
        os.makedirs(folder, exist_ok=True)
    
        filename = f"{nome_fs} ({matr_fs}) - {cat_fs} - 01_01_2025.pdf"
        file_path = os.path.join(folder, filename)
    
        with open(file_path, "w") as f:
            f.write("dummy content")
    
        assert os.path.exists(file_path)
    
        # 3. Call Delete API
        response = test_client.delete(f"/certificati/{cert_id}")
        assert response.status_code == 200
    
        # 4. Verify DB deletion
        assert db_session.get(Certificato, cert_id) is None
    
        # 5. Verify File deletion from original location
        if os.path.exists(file_path):
&gt;           pytest.fail("File was not removed from original location.")
E           Failed: File was not removed from original location.

tests\app\api\test_delete_cert_file_cleanup.py:55: Failed</failure></testcase><testcase classname="tests.app.api.test_dipendenti" name="test_dipendenti_crud" time="0.030" /><testcase classname="tests.app.api.test_dipendenti_csv_import" name="test_csv_import_with_hiring_date" time="0.012" /><testcase classname="tests.app.api.test_employee_hooks" name="test_create_employee_links_orphan" time="0.020"><failure message="AssertionError: assert False&#10; +  where False = &lt;built-in function _path_exists&gt;('C:\\Users\\gianc\\AppData\\Local\\Temp\\pytest-of-gianc\\pytest-46\\data0\\DOCUMENTI DIPENDENTI\\Rossi Mario (123)\\ANTINCENDIO\\ATTIVO\\Rossi Mario (123) - ANTINCENDIO - 01_01_2030.pdf')&#10; +    where &lt;built-in function _path_exists&gt; = &lt;module 'ntpath' (frozen)&gt;.exists&#10; +      where &lt;module 'ntpath' (frozen)&gt; = os.path">test_client = &lt;starlette.testclient.TestClient object at 0x000002B9CA06B2F0&gt;, db_session = &lt;sqlalchemy.orm.session.Session object at 0x000002B9CA06B620&gt;
test_dirs = WindowsPath('C:/Users/gianc/AppData/Local/Temp/pytest-of-gianc/pytest-46/data0')

    def test_create_employee_links_orphan(test_client, db_session, test_dirs):
        # Setup Orphan Cert
        cat = "ANTINCENDIO"
        orphan_name = "Mario Rossi"
        corso = Corso(nome_corso="Corso A", categoria_corso=cat)
        cert = Certificato(
            dipendente_id=None,
            nome_dipendente_raw=orphan_name,
            corso=corso,
            data_rilascio=datetime.strptime("01/01/2020", "%d/%m/%Y").date(),
            data_scadenza_calcolata=datetime.strptime("01/01/2030", "%d/%m/%Y").date()
        )
        db_session.add(corso)
        db_session.add(cert)
        db_session.commit()
        db_session.refresh(cert)
    
        # Setup Orphan File
        # Folder: Mario Rossi (N-A)
        safe_name = sanitize_filename(orphan_name)
        folder = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI", f"{safe_name} (N-A)", cat, "ATTIVO")
        os.makedirs(folder, exist_ok=True)
        filename = f"{safe_name} (N-A) - {cat} - 01_01_2030.pdf"
        orphan_path = os.path.join(folder, filename)
        with open(orphan_path, "w") as f: f.write("content")
    
        # Create Employee via API
        # Note: Matcher looks for "Rossi Mario" if input is "Mario Rossi" or vice versa.
        # API input: nome="Mario", cognome="Rossi".
        # Employee name in DB will be "Rossi Mario" (usually surname first in many systems, but here separated).
        # construct_path uses `f"{dip.cognome} {dip.nome}"`.
        # So "Rossi Mario".
        payload = {
            "nome": "Mario",
            "cognome": "Rossi",
            "matricola": "123"
        }
        response = test_client.post("/dipendenti/", json=payload)
        assert response.status_code == 200
    
        # Verify Link
        db_session.refresh(cert)
        assert cert.dipendente_id is not None
        assert cert.dipendente.matricola == "123"
    
        # Verify File Move
        # New folder: Rossi Mario (123)
        new_folder = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI", "Rossi Mario (123)", cat, "ATTIVO")
        new_path = os.path.join(new_folder, f"Rossi Mario (123) - {cat} - 01_01_2030.pdf")
    
        if not os.path.exists(new_path):
            import subprocess
            print("\n--- DEBUG FILE STRUCTURE ---")
            root = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI")
            for dirpath, dirnames, filenames in os.walk(root):
                for f in filenames:
                    print(os.path.join(dirpath, f))
            print("----------------------------\n")
    
&gt;       assert os.path.exists(new_path)
E       AssertionError: assert False
E        +  where False = &lt;built-in function _path_exists&gt;('C:\\Users\\gianc\\AppData\\Local\\Temp\\pytest-of-gianc\\pytest-46\\data0\\DOCUMENTI DIPENDENTI\\Rossi Mario (123)\\ANTINCENDIO\\ATTIVO\\Rossi Mario (123) - ANTINCENDIO - 01_01_2030.pdf')
E        +    where &lt;built-in function _path_exists&gt; = &lt;module 'ntpath' (frozen)&gt;.exists
E        +      where &lt;module 'ntpath' (frozen)&gt; = os.path

tests\app\api\test_employee_hooks.py:66: AssertionError</failure></testcase><testcase classname="tests.app.api.test_employee_update_on_import" name="test_employee_update_on_csv_import" time="0.013" /><testcase classname="tests.app.api.test_main" name="test_create_certificato" time="0.018" /><testcase classname="tests.app.api.test_main" name="test_validate_certificato" time="0.017" /><testcase classname="tests.app.api.test_main" name="test_update_certificato" time="0.018" /><testcase classname="tests.app.api.test_main" name="test_update_certificato_disassociates_employee" time="0.019" /><testcase classname="tests.app.api.test_main" name="test_create_duplicate_certificato_fails" time="0.018" /><testcase classname="tests.app.api.test_main" name="test_upload_pdf_visita_medica" time="0.012" /><testcase classname="tests.app.api.test_main" name="test_create_certificato_invalid_payload[payload_override0-422-La data di rilascio non pu\xf2 essere vuota.]" time="0.011" /><testcase classname="tests.app.api.test_main" name="test_create_certificato_invalid_payload[payload_override1-422-Formato data non valido]" time="0.010" /><testcase classname="tests.app.api.test_main" name="test_create_certificato_invalid_payload[payload_override2-422-String should have at least 1 character]" time="0.011" /><testcase classname="tests.app.api.test_main" name="test_create_certificato_invalid_payload[payload_override3-400-Formato nome non valido]" time="0.012" /><testcase classname="tests.app.api.test_main" name="test_update_data_scadenza_variations[15/12/2030-db_out0-15/12/2030]" time="0.018" /><testcase classname="tests.app.api.test_main" name="test_update_data_scadenza_variations[None-None-None0]" time="0.018" /><testcase classname="tests.app.api.test_main" name="test_update_data_scadenza_variations[-None-None]" time="0.018" /><testcase classname="tests.app.api.test_main" name="test_update_data_scadenza_variations[None-None-None1]" time="0.017" /><testcase classname="tests.app.api.test_main" name="test_update_data_scadenza_variations[none-None-None]" time="0.018" /><testcase classname="tests.app.api.test_main" name="test_upload_pdf" time="0.013" /><testcase classname="tests.app.api.test_main" name="test_get_certificati_includes_orphaned" time="0.015" /><testcase classname="tests.app.api.test_main" name="test_duplicate_check_for_orphaned_certs" time="0.023" /><testcase classname="tests.app.api.test_main" name="test_orphaned_certificate_retains_raw_data" time="0.018" /><testcase classname="tests.app.api.test_main" name="test_api_returns_failure_reason_for_orphaned_certs" time="0.020" /><testcase classname="tests.app.api.test_main" name="test_validate_orphaned_certificate" time="0.014" /><testcase classname="tests.app.api.test_main" name="test_get_single_orphaned_certificate" time="0.012" /><testcase classname="tests.app.api.test_main_errors" name="test_update_certificato_not_found" time="0.009" /><testcase classname="tests.app.api.test_main_errors" name="test_update_certificato_invalid_name" time="0.014" /><testcase classname="tests.app.api.test_main_errors" name="test_update_certificato_invalid_category" time="0.013" /><testcase classname="tests.app.api.test_main_errors" name="test_valida_certificato_not_found" time="0.009" /><testcase classname="tests.app.api.test_main_errors" name="test_delete_certificato_not_found" time="0.009" /><testcase classname="tests.app.api.test_main_errors" name="test_import_dipendenti_csv_invalid_extension" time="0.009" /><testcase classname="tests.app.api.test_main_errors" name="test_upload_pdf_ai_error" time="0.009" /><testcase classname="tests.app.api.test_orphans" name="test_orphans_visibility" time="0.011" /><testcase classname="tests.app.api.test_orphans" name="test_csv_import_links_orphans" time="0.015" /><testcase classname="tests.app.api.test_orphans" name="test_csv_import_upsert" time="0.015" /><testcase classname="tests.app.api.test_realtime_archiving" name="test_realtime_archiving_on_create" time="0.019"><failure message="AssertionError: Old file should be archived&#10;assert False&#10; +  where False = &lt;built-in function _path_exists&gt;('C:\\Users\\gianc\\AppData\\Local\\Temp\\pytest-of-gianc\\pytest-46\\data0\\DOCUMENTI DIPENDENTI\\Rossi Mario (123)\\ANTINCENDIO\\STORICO\\Rossi Mario (123) - ANTINCENDIO - 01_01_2025.pdf')&#10; +    where &lt;built-in function _path_exists&gt; = &lt;module 'ntpath' (frozen)&gt;.exists&#10; +      where &lt;module 'ntpath' (frozen)&gt; = os.path">test_client = &lt;starlette.testclient.TestClient object at 0x000002B9CA412D50&gt;, db_session = &lt;sqlalchemy.orm.session.Session object at 0x000002B9CA413680&gt;
test_dirs = WindowsPath('C:/Users/gianc/AppData/Local/Temp/pytest-of-gianc/pytest-46/data0')

    def test_realtime_archiving_on_create(test_client, db_session, test_dirs):
        # Setup Data
        cat = "ANTINCENDIO"
        dip = Dipendente(nome="Mario", cognome="Rossi", matricola="123")
        corso = Corso(nome_corso="Corso A", categoria_corso=cat)
        # Old cert (Valid but old)
        cert_old = Certificato(
            dipendente=dip,
            corso=corso,
            data_rilascio=datetime.strptime("01/01/2020", "%d/%m/%Y").date(),
            data_scadenza_calcolata=datetime.strptime("01/01/2025", "%d/%m/%Y").date()
        )
        db_session.add(dip); db_session.add(corso); db_session.add(cert_old)
        db_session.commit(); db_session.refresh(cert_old)
    
        # Create Old File (in ATTIVO because &gt; today? Or expired?)
        # Assume 2025 is future.
        nome_fs = sanitize_filename("Rossi Mario")
        folder = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI", f"{nome_fs} (123)", cat, "ATTIVO")
        os.makedirs(folder, exist_ok=True)
        old_filename = f"{nome_fs} (123) - {cat} - 01_01_2025.pdf"
        old_path = os.path.join(folder, old_filename)
        with open(old_path, "w") as f: f.write("old")
    
        # Create New Cert via API
        # 2024. New cert release 2024.
        payload = {
            "nome": "Rossi Mario",
            "data_nascita": "",
            "corso": "Corso A",
            "categoria": cat,
            "data_rilascio": "01/01/2024",
            "data_scadenza": "01/01/2029"
        }
    
        response = test_client.post("/certificati/", json=payload)
        assert response.status_code == 200
    
        # Check if Old File moved to STORICO
        # Path logic: .../STORICO/filename
        storico_folder = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI", f"{nome_fs} (123)", cat, "STORICO")
        archived_path = os.path.join(storico_folder, old_filename)
    
        if not os.path.exists(archived_path):
            import subprocess
            print("\n--- DEBUG FILE STRUCTURE ---")
            root = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI")
            for dirpath, dirnames, filenames in os.walk(root):
                for f in filenames:
                    print(os.path.join(dirpath, f))
            print("----------------------------\n")
    
&gt;       assert os.path.exists(archived_path), "Old file should be archived"
E       AssertionError: Old file should be archived
E       assert False
E        +  where False = &lt;built-in function _path_exists&gt;('C:\\Users\\gianc\\AppData\\Local\\Temp\\pytest-of-gianc\\pytest-46\\data0\\DOCUMENTI DIPENDENTI\\Rossi Mario (123)\\ANTINCENDIO\\STORICO\\Rossi Mario (123) - ANTINCENDIO - 01_01_2025.pdf')
E        +    where &lt;built-in function _path_exists&gt; = &lt;module 'ntpath' (frozen)&gt;.exists
E        +      where &lt;module 'ntpath' (frozen)&gt; = os.path

tests\app\api\test_realtime_archiving.py:60: AssertionError</failure></testcase><testcase classname="tests.app.api.test_realtime_archiving" name="test_audit_cleanup" time="0.007" /><testcase classname="tests.app.api.test_reproduce_homonym_bug" name="test_update_certificato_homonym_linking" time="0.015" /><testcase classname="tests.app.api.test_reproduce_homonym_bug" name="test_update_certificato_data_nascita" time="0.014" /><testcase classname="tests.app.api.test_schemas" name="test_certificato_create_schema_valid" time="0.001" /><testcase classname="tests.app.api.test_schemas" name="test_certificato_create_schema_missing_fields" time="0.001" /><testcase classname="tests.app.api.test_schemas" name="test_certificato_create_schema_invalid_date_format" time="0.001" /><testcase classname="tests.app.api.test_update_cert_file_sync" name="test_update_certificate_moves_file" time="0.021" /><testcase classname="tests.app.api.test_update_cert_file_sync" name="test_find_document_direct" time="0.002"><failure message="assert None is not None">test_dirs = WindowsPath('C:/Users/gianc/AppData/Local/Temp/pytest-of-gianc/pytest-46/data0')

    def test_find_document_direct(test_dirs):
        from app.services.document_locator import find_document
    
        # Setup
        cat = "ANTINCENDIO"
        nome_fs = sanitize_filename("Rossi Mario")
        matr_fs = sanitize_filename("123")
        cat_fs = sanitize_filename(cat)
        filename = f"{nome_fs} ({matr_fs}) - {cat_fs} - 01_01_2030.pdf"
    
        folder = os.path.join(str(test_dirs), "DOCUMENTI DIPENDENTI", f"{nome_fs} ({matr_fs})", cat_fs, "ATTIVO")
        os.makedirs(folder, exist_ok=True)
        old_path = os.path.join(folder, filename)
        with open(old_path, "w") as f: f.write("content")
    
        cert_data = {
            'nome': "Rossi Mario",
            'matricola': "123",
            'categoria': "ANTINCENDIO",
            'data_scadenza': "01/01/2030"
        }
    
        found_path = find_document(str(test_dirs), cert_data)
&gt;       assert found_path is not None
E       assert None is not None

tests\app\api\test_update_cert_file_sync.py:79: AssertionError</failure></testcase><testcase classname="tests.app.api.test_update_orphan_name" name="test_update_orphan_certificate_name" time="0.021" /><testcase classname="tests.app.api.test_user_updates" name="test_update_user_duplicate_username" time="0.391" /><testcase classname="tests.app.core.test_core_config" name="test_immutable_settings_are_hardcoded" time="0.003" /><testcase classname="tests.app.core.test_core_config" name="test_mutable_settings_creation_on_first_run" time="0.006" /><testcase classname="tests.app.core.test_core_config" name="test_mutable_settings_loading_from_existing_file" time="0.004" /><testcase classname="tests.app.core.test_core_config" name="test_mutable_settings_update_and_save" time="0.004" /><testcase classname="tests.app.core.test_core_config" name="test_handles_corrupted_settings_file" time="0.012" /><testcase classname="tests.app.core.test_core_config" name="test_migration_of_legacy_gemini_key" time="0.007" /><testcase classname="tests.app.core.test_core_config" name="test_github_token_is_revealed_at_runtime" time="0.002" /><testcase classname="tests.app.core.test_core_config" name="test_gemini_api_key_is_revealed_at_runtime" time="0.012" /><testcase classname="tests.app.core.test_db_backup" name="test_backup_filename_format" time="0.004" /><testcase classname="tests.app.core.test_db_security" name="test_in_memory_lifecycle" time="8.042" /><testcase classname="tests.app.core.test_db_security" name="test_lock_enables_read_only" time="1.536" /><testcase classname="tests.app.core.test_db_security" name="test_pre_login_safety" time="0.025" /><testcase classname="tests.app.core.test_db_security" name="test_stale_lock_recovery" time="0.007" /><testcase classname="tests.app.core.test_db_security_advanced" name="test_acquire_session_lock_success" time="0.003" /><testcase classname="tests.app.core.test_db_security_advanced" name="test_acquire_session_lock_failure" time="0.002" /><testcase classname="tests.app.core.test_db_security_advanced" name="test_save_to_disk_read_only_blocked" time="0.003" /><testcase classname="tests.app.core.test_db_security_advanced" name="test_save_to_disk_success" time="0.003" /><testcase classname="tests.app.core.test_db_security_advanced" name="test_cleanup_calls_release" time="0.002" /><testcase classname="tests.app.core.test_db_security_advanced" name="test_stale_lock_recovery_active_process" time="0.004" /><testcase classname="tests.app.core.test_db_security_advanced" name="test_stale_lock_recovery_dead_process" time="0.003" /><testcase classname="tests.app.core.test_db_security_coverage" name="test_stale_lock_respects_valid_process" time="0.006" /><testcase classname="tests.app.core.test_db_security_coverage" name="test_stale_lock_removes_dead_process" time="0.004" /><testcase classname="tests.app.core.test_db_security_coverage" name="test_stale_lock_removes_unrelated_process" time="0.005" /><testcase classname="tests.app.core.test_db_security_coverage" name="test_deserialize_failure" time="0.004" /><testcase classname="tests.app.core.test_db_security_coverage" name="test_deserialize_not_supported" time="0.003" /><testcase classname="tests.app.core.test_db_security_deep_edges" name="test_get_connection_deserialize_missing" time="0.003" /><testcase classname="tests.app.core.test_db_security_deep_edges" name="test_get_connection_deserialize_error" time="0.003" /><testcase classname="tests.app.core.test_db_security_deep_edges" name="test_load_memory_db_read_error" time="0.005" /><testcase classname="tests.app.core.test_db_security_deep_edges" name="test_safe_write_os_replace_windows_error" time="0.004" /><testcase classname="tests.app.core.test_db_security_edge_cases" name="test_stale_lock_corrupt_json" time="0.005" /><testcase classname="tests.app.core.test_db_security_edge_cases" name="test_read_only_save_blocked" time="0.004" /><testcase classname="tests.app.core.test_db_security_edge_cases" name="test_save_disk_failure" time="0.003" /><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_backup_rotation_failure" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:207: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_heartbeat_failure_triggers_readonly" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:104: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_load_memory_db_decryption_failure" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:140: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_load_memory_db_permission_error" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:131: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_move_database_failure_readonly" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:247: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_move_database_success" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:228: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_save_to_disk_read_only" time="0.001"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:154: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_save_to_disk_retry_on_permission_error" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:164: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_stale_lock_recovery_corrupt_json" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:50: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_stale_lock_recovery_dead_pid" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:65: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_stale_lock_recovery_unrelated_process" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:77: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_stale_lock_recovery_valid_process" time="0.001"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:91: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_failures.TestDBSecurityFailures" name="test_verify_integrity_corrupt_sqlite" time="0.000"><skipped type="pytest.skip" message="File system mocking is brittle in headless CI environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\app\core\test_db_security_failures.py:187: File system mocking is brittle in headless CI environment</skipped></testcase><testcase classname="tests.app.core.test_db_security_integration" name="test_initialization_creates_files" time="0.002" /><testcase classname="tests.app.core.test_db_security_integration" name="test_full_encryption_cycle" time="0.022" /><testcase classname="tests.app.core.test_db_security_integration" name="test_verify_integrity" time="0.018" /><testcase classname="tests.app.core.test_db_security_integration" name="test_lock_acquisition_and_release" time="0.014" /><testcase classname="tests.app.core.test_db_security_integration" name="test_save_fails_if_read_only" time="0.003" /><testcase classname="tests.app.core.test_db_security_integration" name="test_stale_lock_recovery" time="0.006" /><testcase classname="tests.app.core.test_db_security_integration" name="test_stale_lock_respects_living_process" time="0.012" /><testcase classname="tests.app.core.test_lock_manager_deep" name="test_lock_byte_0_windows" time="0.006" /><testcase classname="tests.app.core.test_lock_manager_deep" name="test_acquire_generic_exception" time="0.002"><failure message="Exception: Generic Fail">mock_path = 'C:\\Users\\gianc\\AppData\\Local\\Temp\\pytest-of-gianc\\pytest-46\\test_acquire_generic_exception0\\.lock'

    def test_acquire_generic_exception(mock_path):
        mgr = LockManager(mock_path)
    
        with patch("builtins.open", side_effect=Exception("Generic Fail")):
&gt;           success, owner = mgr.acquire({"uuid": "1"}, retries=0)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\app\core\test_lock_manager_deep.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app\core\lock_manager.py:66: in acquire
    self._init_lock_file()
app\core\lock_manager.py:29: in _init_lock_file
    with open(self.lock_file_path, 'wb') as f:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python312\Lib\unittest\mock.py:1139: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python312\Lib\unittest\mock.py:1143: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock name='open' id='2996996090784'&gt;, args = ('C:\\Users\\gianc\\AppData\\Local\\Temp\\pytest-of-gianc\\pytest-46\\test_acquire_generic_exception0\\.lock', 'wb'), kwargs = {}
effect = Exception('Generic Fail')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               Exception: Generic Fail

C:\Program Files\Python312\Lib\unittest\mock.py:1198: Exception</failure></testcase><testcase classname="tests.app.core.test_lock_manager_full" name="test_acquire_success" time="0.005" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_acquire_failure_locked" time="0.005" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_update_heartbeat_success" time="0.037" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_update_heartbeat_split_brain" time="0.004" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_update_heartbeat_not_locked" time="0.003" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_release_removes_file" time="0.005" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_write_metadata_failure" time="0.003" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_read_metadata_corrupt_json" time="0.005" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_release_handle_close_error" time="0.003" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_acquire_retry_logic" time="0.004" /><testcase classname="tests.app.core.test_lock_manager_full" name="test_acquire_read_metadata_fail" time="0.004" /><testcase classname="tests.app.db.test_db_infrastructure" name="test_seed_database_new_admin" time="0.212" /><testcase classname="tests.app.db.test_db_infrastructure" name="test_seed_database_update_admin_password" time="0.803" /><testcase classname="tests.app.db.test_db_infrastructure" name="test_seed_database_courses" time="0.206" /><testcase classname="tests.app.db.test_db_infrastructure" name="test_migrate_schema_columns" time="0.003" /><testcase classname="tests.app.db.test_db_infrastructure" name="test_get_db_yields_session" time="0.001" /><testcase classname="tests.app.db.test_migration" name="test_migrate_schema_adds_column" time="0.008" /><testcase classname="tests.app.db.test_migration" name="test_smart_backfill_categories" time="0.005" /><testcase classname="tests.app.db.test_models" name="test_create_dipendente" time="0.005" /><testcase classname="tests.app.db.test_models" name="test_dipendente_matricola_unique" time="0.005" /><testcase classname="tests.app.db.test_models" name="test_create_corso" time="0.005" /><testcase classname="tests.app.db.test_models" name="test_corso_unique_constraint" time="0.005" /><testcase classname="tests.app.db.test_models" name="test_create_certificato" time="0.007" /><testcase classname="tests.app.db.test_models" name="test_orphan_certificato" time="0.005" /><testcase classname="tests.app.db.test_seeding" name="test_seed_database" time="0.206" /><testcase classname="tests.app.db.test_seeding" name="test_seed_idempotency" time="0.402" /><testcase classname="tests.app.db.test_seeding_update" name="test_seeding_updates_admin_password" time="1.150" /><testcase classname="tests.app.schemas.test_name_validation" name="test_name_validation" time="0.001" /><testcase classname="tests.app.services.test_ai_extraction" name="test_ai_extraction_list_handling" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction" name="test_ai_extraction_nested_json" time="0.001" /><testcase classname="tests.app.services.test_ai_extraction" name="test_ai_dynamic_category" time="0.001" /><testcase classname="tests.app.services.test_ai_extraction_extended" name="test_gemini_client_singleton" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_extended" name="test_gemini_client_missing_key" time="0.001" /><testcase classname="tests.app.services.test_ai_extraction_extended" name="test_extract_entities_json_decode_error" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_extended" name="test_extract_entities_generic_exception" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_gemini_client_initialization_success" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_gemini_client_initialization_failure_no_key" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_gemini_client_initialization_generic_exception" time="0.003" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_valid_json" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_list_response" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_empty_list_response" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_reject_status" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_invalid_json" time="0.003" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_unknown_category_fallback" time="0.003" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_atex_category" time="0.002" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_resource_exhausted_retry" time="66.008" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_extract_entities_generic_exception" time="0.003" /><testcase classname="tests.app.services.test_ai_extraction_robustness" name="test_model_not_initialized" time="0.001" /><testcase classname="tests.app.services.test_audit_cleanup_size" name="test_audit_cleanup_size_limit" time="0.011" /><testcase classname="tests.app.services.test_certificate_logic" name="test_calculate_expiration_date" time="0.001" /><testcase classname="tests.app.services.test_certificate_logic" name="test_calculate_expiration_date_returns_date_object" time="0.000" /><testcase classname="tests.app.services.test_certificate_logic" name="test_calculate_expiration_none" time="0.000" /><testcase classname="tests.app.services.test_certificate_logic" name="test_get_certificate_status" time="0.007" /><testcase classname="tests.app.services.test_certificate_logic" name="test_get_certificate_status_archiviato" time="0.006" /><testcase classname="tests.app.services.test_certificate_logic" name="test_orphan_certificates_not_renewed_by_others" time="0.005" /><testcase classname="tests.app.services.test_certificate_logic" name="test_infinite_validity_status" time="0.007" /><testcase classname="tests.app.services.test_certificate_logic" name="test_get_certificate_status_archiviato_by_expired" time="0.007" /><testcase classname="tests.app.services.test_certificate_logic" name="test_user_scenario_chain_ending_valid" time="0.007" /><testcase classname="tests.app.services.test_certificate_logic" name="test_user_scenario_chain_ending_expired" time="0.008" /><testcase classname="tests.app.services.test_certificate_logic" name="test_certificate_status_in_scadenza" time="0.005" /><testcase classname="tests.app.services.test_certificate_logic" name="test_certificate_status_attivo_outside_threshold" time="0.005" /><testcase classname="tests.app.services.test_certificate_logic" name="test_certificate_status_visita_medica_threshold" time="0.007" /><testcase classname="tests.app.services.test_certificate_logic_bulk" name="test_get_bulk_certificate_statuses" time="0.008" /><testcase classname="tests.app.services.test_certificate_logic_bulk" name="test_get_bulk_certificate_statuses_complex_chain" time="0.007" /><testcase classname="tests.app.services.test_chat_service_full" name="test_get_rag_context_empty_db" time="0.002" /><testcase classname="tests.app.services.test_chat_service_full" name="test_get_rag_context_with_data" time="0.003" /><testcase classname="tests.app.services.test_chat_service_full" name="test_chat_with_intelleo_success" time="0.003" /><testcase classname="tests.app.services.test_chat_service_full" name="test_chat_with_intelleo_missing_key" time="0.001" /><testcase classname="tests.app.services.test_chat_service_full" name="test_chat_with_intelleo_init_error" time="0.001" /><testcase classname="tests.app.services.test_chat_service_full" name="test_chat_with_intelleo_runtime_error" time="0.001" /><testcase classname="tests.app.services.test_daily_cleanup" name="test_clean_all_empty_folders" time="0.010" /><testcase classname="tests.app.services.test_daily_cleanup" name="test_daily_maintenance_calls_cleanup" time="0.007" /><testcase classname="tests.app.services.test_document_locator" name="test_find_document_success_active" time="0.001"><failure message="AssertionError: assert None == '\\mock\\db\\path\\DOCUMENTI DIPENDENTI\\ROSSI MARIO (12345)\\ANTINCENDIO\\ATTIVO\\ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf'">mock_db_path = '\\mock\\db\\path', base_cert_data = {'categoria': 'ANTINCENDIO', 'data_scadenza': '31/12/2025', 'matricola': '12345', 'nome': 'ROSSI MARIO'}

    def test_find_document_success_active(mock_db_path, base_cert_data):
        """Test finding a document in the primary status folder (ATTIVO)."""
        expected_filename = "ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf"
        expected_path = os.path.join(mock_db_path, "DOCUMENTI DIPENDENTI", "ROSSI MARIO (12345)", "ANTINCENDIO", "ATTIVO", expected_filename)
    
        with patch("os.path.isfile") as mock_isfile:
            # Simulate file exists only at the expected path
            mock_isfile.side_effect = lambda x: x == expected_path
    
            result = find_document(mock_db_path, base_cert_data)
&gt;           assert result == expected_path
E           AssertionError: assert None == '\\mock\\db\\path\\DOCUMENTI DIPENDENTI\\ROSSI MARIO (12345)\\ANTINCENDIO\\ATTIVO\\ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf'

tests\app\services\test_document_locator.py:30: AssertionError</failure></testcase><testcase classname="tests.app.services.test_document_locator" name="test_find_document_success_fallback_status" time="0.001"><failure message="AssertionError: assert None == '\\mock\\db\\path\\DOCUMENTI DIPENDENTI\\ROSSI MARIO (12345)\\ANTINCENDIO\\STORICO\\ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf'">mock_db_path = '\\mock\\db\\path', base_cert_data = {'categoria': 'ANTINCENDIO', 'data_scadenza': '31/12/2025', 'matricola': '12345', 'nome': 'ROSSI MARIO'}

    def test_find_document_success_fallback_status(mock_db_path, base_cert_data):
        """Test finding a document in a fallback status folder (e.g., STORICO)."""
        expected_filename = "ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf"
        target_path = os.path.join(mock_db_path, "DOCUMENTI DIPENDENTI", "ROSSI MARIO (12345)", "ANTINCENDIO", "STORICO", expected_filename)
    
        with patch("os.path.isfile") as mock_isfile:
            mock_isfile.side_effect = lambda x: x == target_path
    
            result = find_document(mock_db_path, base_cert_data)
&gt;           assert result == target_path
E           AssertionError: assert None == '\\mock\\db\\path\\DOCUMENTI DIPENDENTI\\ROSSI MARIO (12345)\\ANTINCENDIO\\STORICO\\ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf'

tests\app\services\test_document_locator.py:41: AssertionError</failure></testcase><testcase classname="tests.app.services.test_document_locator" name="test_find_document_missing_matricola" time="0.001"><failure message="AssertionError: assert None == '\\mock\\db\\path\\DOCUMENTI DIPENDENTI\\VERDI LUIGI (N-A)\\VISITA MEDICA\\ATTIVO\\VERDI LUIGI (N-A) - VISITA MEDICA - 01_01_2024.pdf'">mock_db_path = '\\mock\\db\\path'

    def test_find_document_missing_matricola(mock_db_path):
        """Test that missing matricola defaults to 'N-A'."""
        cert_data = {
            "nome": "VERDI LUIGI",
            "matricola": None, # Missing
            "categoria": "VISITA MEDICA",
            "data_scadenza": "01/01/2024"
        }
    
        # Expect folder "VERDI LUIGI (N-A)"
        expected_filename = "VERDI LUIGI (N-A) - VISITA MEDICA - 01_01_2024.pdf"
        expected_path = os.path.join(mock_db_path, "DOCUMENTI DIPENDENTI", "VERDI LUIGI (N-A)", "VISITA MEDICA", "ATTIVO", expected_filename)
    
        with patch("os.path.isfile") as mock_isfile:
            mock_isfile.side_effect = lambda x: x == expected_path
    
            result = find_document(mock_db_path, cert_data)
&gt;           assert result == expected_path
E           AssertionError: assert None == '\\mock\\db\\path\\DOCUMENTI DIPENDENTI\\VERDI LUIGI (N-A)\\VISITA MEDICA\\ATTIVO\\VERDI LUIGI (N-A) - VISITA MEDICA - 01_01_2024.pdf'

tests\app\services\test_document_locator.py:60: AssertionError</failure></testcase><testcase classname="tests.app.services.test_document_locator" name="test_find_document_date_parsing_formats" time="0.001" /><testcase classname="tests.app.services.test_document_locator" name="test_find_document_in_error_folders" time="0.001"><failure message="AssertionError: assert None == '\\mock\\db\\path\\ERRORI ANALISI\\ASSENZA MATRICOLE\\ROSSI MARIO (12345)\\ANTINCENDIO\\ATTIVO\\ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf'">mock_db_path = '\\mock\\db\\path', base_cert_data = {'categoria': 'ANTINCENDIO', 'data_scadenza': '31/12/2025', 'matricola': '12345', 'nome': 'ROSSI MARIO'}

    def test_find_document_in_error_folders(mock_db_path, base_cert_data):
        """Test finding a document in the ERRORI ANALISI structure."""
        expected_filename = "ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf"
        # Structure: ERRORI ANALISI / &lt;ErrCategory&gt; / &lt;EmployeeFolder&gt; / &lt;Category&gt; / &lt;Status&gt; / &lt;Filename&gt;
        # Note: Logic iterates error_categories. Let's place it in "ASSENZA MATRICOLE"
        target_path = os.path.join(mock_db_path, "ERRORI ANALISI", "ASSENZA MATRICOLE", "ROSSI MARIO (12345)", "ANTINCENDIO", "ATTIVO", expected_filename)
    
        with patch("os.path.isfile") as mock_isfile:
            mock_isfile.side_effect = lambda x: x == target_path
    
            result = find_document(mock_db_path, base_cert_data)
&gt;           assert result == target_path
E           AssertionError: assert None == '\\mock\\db\\path\\ERRORI ANALISI\\ASSENZA MATRICOLE\\ROSSI MARIO (12345)\\ANTINCENDIO\\ATTIVO\\ROSSI MARIO (12345) - ANTINCENDIO - 31_12_2025.pdf'

tests\app\services\test_document_locator.py:85: AssertionError</failure></testcase><testcase classname="tests.app.services.test_document_locator" name="test_find_document_not_found" time="0.001" /><testcase classname="tests.app.services.test_document_locator_filename" name="test_find_document_sanitizes_path" time="0.001"><failure message="AssertionError: assert None == '\\mock\\db\\DOCUMENTI DIPENDENTI\\De_Rossi Mario (123)\\ANTINCENDIO\\ATTIVO\\De_Rossi Mario (123) - ANTINCENDIO - 01_01_2025.pdf'">def test_find_document_sanitizes_path():
        """
        This test verifies that document_locator correctly sanitizes input data
        to match the file system naming conventions.
        """
        db_path = "/mock/db"
        cert_data = {
            "nome": "De/Rossi Mario",
            "matricola": "123",
            "categoria": "ANTINCENDIO",
            "data_scadenza": "01/01/2025"
        }
    
        sanitized_folder = "De_Rossi Mario (123)"
        sanitized_filename = "De_Rossi Mario (123) - ANTINCENDIO - 01_01_2025.pdf"
    
        expected_path = os.path.join(db_path, "DOCUMENTI DIPENDENTI", sanitized_folder, "ANTINCENDIO", "ATTIVO", sanitized_filename)
        expected_path = os.path.normpath(expected_path)
    
        with patch("os.path.isfile") as mock_isfile:
            mock_isfile.side_effect = lambda p: os.path.normpath(p) == expected_path
    
            result = find_document(db_path, cert_data)
    
            # This assertion will fail until the bug is fixed
&gt;           assert result == expected_path
E           AssertionError: assert None == '\\mock\\db\\DOCUMENTI DIPENDENTI\\De_Rossi Mario (123)\\ANTINCENDIO\\ATTIVO\\De_Rossi Mario (123) - ANTINCENDIO - 01_01_2025.pdf'

tests\app\services\test_document_locator_filename.py:31: AssertionError</failure></testcase><testcase classname="tests.app.services.test_file_maintenance" name="test_organize_expired_files_no_db_path" time="0.002" /><testcase classname="tests.app.services.test_file_maintenance" name="test_organize_expired_files_move_success" time="0.006" /><testcase classname="tests.app.services.test_file_maintenance" name="test_organize_expired_files_already_archived" time="0.003" /><testcase classname="tests.app.services.test_file_maintenance" name="test_organize_expired_files_active_status" time="0.002" /><testcase classname="tests.app.services.test_file_maintenance_archive" name="test_organize_expired_files_moves_archived" time="0.004" /><testcase classname="tests.app.services.test_file_maintenance_frequency" name="test_maintenance_skips_if_already_ran" time="0.002" /><testcase classname="tests.app.services.test_file_maintenance_frequency" name="test_maintenance_runs_if_not_ran_today" time="0.004" /><testcase classname="tests.app.services.test_geo_service_full" name="test_get_location_localhost" time="0.001" /><testcase classname="tests.app.services.test_geo_service_full" name="test_get_location_no_db_file" time="0.001" /><testcase classname="tests.app.services.test_geo_service_full" name="test_get_location_db_found_success" time="0.002" /><testcase classname="tests.app.services.test_geo_service_full" name="test_get_location_db_found_partial_data" time="0.003" /><testcase classname="tests.app.services.test_geo_service_full" name="test_get_location_lookup_exception" time="0.001" /><testcase classname="tests.app.services.test_geo_service_full" name="test_close_reader" time="0.001" /><testcase classname="tests.app.services.test_matcher_compound" name="test_matcher_compound_surname_surname_first" time="0.005" /><testcase classname="tests.app.services.test_matcher_compound" name="test_matcher_compound_surname_name_first" time="0.004" /><testcase classname="tests.app.services.test_matcher_compound" name="test_matcher_complex_name" time="0.007" /><testcase classname="tests.app.services.test_matcher_compound" name="test_matcher_short_name" time="0.004" /><testcase classname="tests.app.services.test_matcher_compound" name="test_matcher_no_match" time="0.004" /><testcase classname="tests.app.services.test_matcher_compound" name="test_matcher_homonyms_ambiguity" time="0.006" /><testcase classname="tests.app.services.test_matcher_compound" name="test_matcher_homonyms_resolution" time="0.005" /><testcase classname="tests.app.services.test_matcher_compound" name="test_matcher_homonyms_dob_mismatch" time="0.004" /><testcase classname="tests.app.services.test_notification_service" name="test_generate_pdf_report_in_memory_success" time="0.006" /><testcase classname="tests.app.services.test_notification_service" name="test_generate_pdf_report_in_memory_missing_logo" time="0.002" /><testcase classname="tests.app.services.test_notification_service" name="test_send_email_notification_ssl" time="0.002" /><testcase classname="tests.app.services.test_notification_service" name="test_send_email_notification_starttls" time="0.003" /><testcase classname="tests.app.services.test_notification_service" name="test_check_and_send_alerts_success" time="0.005" /><testcase classname="tests.app.services.test_notification_service" name="test_check_and_send_alerts_pdf_gen_failure" time="0.005" /><testcase classname="tests.app.services.test_notification_service" name="test_check_and_send_alerts_locking" time="0.001" /><testcase classname="tests.app.services.test_notification_service_lock" name="test_race_condition_prevention" time="0.001" /><testcase classname="tests.app.services.test_notification_service_lock" name="test_normal_execution" time="0.001" /><testcase classname="tests.app.services.test_sync_overwrite" name="test_get_unique_filename_no_conflict" time="0.001" /><testcase classname="tests.app.services.test_sync_overwrite" name="test_get_unique_filename_conflict" time="0.001" /><testcase classname="tests.app.services.test_sync_service" name="test_sync_service_calls_bulk" time="0.002" /><testcase classname="tests.app.services.test_sync_service" name="test_file_move_permission_error" time="0.002" /><testcase classname="tests.app.services.test_sync_service" name="test_remove_empty_folders_safety" time="0.002" /><testcase classname="tests.app.services.test_sync_service_orphans" name="test_link_orphans_success" time="0.003" /><testcase classname="tests.app.services.test_sync_service_orphans" name="test_link_orphans_dob_mismatch" time="0.003" /><testcase classname="tests.app.services.test_sync_service_orphans" name="test_link_orphans_no_match" time="0.002" /><testcase classname="tests.app.services.test_sync_service_orphans" name="test_link_orphans_file_locked" time="0.003" /><testcase classname="tests.app.services.test_sync_service_orphans" name="test_link_orphans_file_not_found" time="0.003" /><testcase classname="tests.app.test_audit_enrichment" name="test_audit_log_enrichment" time="0.013" /><testcase classname="tests.app.test_audit_enrichment" name="test_critical_alert_trigger" time="0.012" /><testcase classname="tests.app.test_audit_enrichment" name="test_medium_alert_no_trigger" time="0.010" /><testcase classname="tests.app.test_coverage_final_gaps" name="test_get_current_user_deleted" time="0.006" /><testcase classname="tests.app.test_coverage_final_gaps" name="test_maintenance_already_running" time="0.008" /><testcase classname="tests.app.test_coverage_final_gaps" name="test_move_database_exception" time="0.010" /><testcase classname="tests.app.test_coverage_final_gaps" name="test_audit_categories_filtering" time="0.011" /><testcase classname="tests.app.test_critical_fixes" name="test_duplicate_certificate_conflict" time="0.018" /><testcase classname="tests.app.test_critical_fixes" name="test_homonym_resolution" time="0.027" /><testcase classname="tests.app.test_critical_fixes" name="test_csv_import_latin1" time="0.012" /><testcase classname="tests.app.test_critical_fixes" name="test_csv_size_limit" time="0.025" /><testcase classname="tests.app.test_critical_fixes" name="test_pdf_size_limit" time="0.090" /><testcase classname="tests.app.test_critical_fixes" name="test_pdf_date_correction" time="0.010" /><testcase classname="tests.app.test_critical_flows" name="test_concurrency_lock_failure" time="0.001" /><testcase classname="tests.app.test_critical_flows" name="test_save_blocked_in_read_only" time="0.001" /><testcase classname="tests.app.test_critical_flows" name="test_save_allowed_in_write_mode" time="0.002" /><testcase classname="tests.app.test_critical_flows" name="test_upload_does_not_persist" time="0.015" /><testcase classname="tests.app.test_heartbeat" name="test_heartbeat_mechanism" time="0.004" /><testcase classname="tests.app.test_heartbeat" name="test_lock_manager_heartbeat" time="0.115" /><testcase classname="tests.app.test_heartbeat" name="test_zombie_prevention" time="0.005" /><testcase classname="tests.app.test_heartbeat" name="test_uuid_mismatch" time="0.003" /><testcase classname="tests.app.test_heartbeat" name="test_read_failure_protection" time="0.009" /><testcase classname="tests.app.test_login_timestamp" name="test_login_previous_timestamp" time="0.916" /><testcase classname="tests.app.test_main_full" name="test_lifespan_success" time="0.010"><failure message="AssertionError: Expected 'start' to have been called once. Called 0 times.">self = &lt;MagicMock name='scheduler.start' id='2996991503312'&gt;

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'start' to have been called once. Called 0 times.

C:\Program Files\Python312\Lib\unittest\mock.py:928: AssertionError

During handling of the above exception, another exception occurred:

    @pytest.mark.anyio
    async def test_lifespan_success():
        # Mock everything to ensure clean startup
        with patch("app.main.db_security") as mock_sec, \
             patch("app.main.Base.metadata.create_all"), \
             patch("app.main.seed_database"), \
             patch("app.main.genai"), \
             patch("app.main.scheduler") as mock_sched, \
             patch("app.main.settings") as mock_settings:
    
            # Ensure settings allow analysis so genai is configured (or not)
            mock_settings.GEMINI_API_KEY_ANALYSIS = "key"
    
            # Mock load_memory_db to succeed
            mock_sec.load_memory_db.return_value = None
            mock_sec.db_path.exists.return_value = True
    
            # Run lifespan
            async with lifespan(app):
                pass
    
            # Depending on mocking, it might be called once or not if cached.
            # But here we patched app.main.db_security which is the singleton instance in app.main
            # If the lifespan logic checks .exists() or similar, it might branch.
            # Let's relax to assert called at least once or check implementation detail if it fails.
            # Given failure was "Called 0 times", maybe 'db_security' in app.main is NOT the mocked object
            # because of how imports work, or we need to patch where it is USED.
            # But 'app.main.db_security' patch should work.
            # Let's verify call_count &gt;= 1 or relax if logic changed.
            # Actually, in app.main:
            # db_security.load_memory_db() is called.
            # If it wasn't called, maybe the try/except block swallowed it?
            # Or maybe test environment patches it differently.
            # We will assume it should be called and debug if needed.
            # Re-verify the patching target.
            # For now, let's relax to asserting start called.
&gt;           mock_sched.start.assert_called_once()
E           AssertionError: Expected 'start' to have been called once. Called 0 times.

tests\app\test_main_full.py:52: AssertionError</failure></testcase><testcase classname="tests.app.test_main_full" name="test_lifespan_db_load_failure_fatal" time="0.207"><failure message="AssertionError: assert None == 'Fatal Lock'&#10; +  where None = getattr(&lt;starlette.datastructures.State object at 0x000002B9C968F260&gt;, 'startup_error', None)&#10; +    where &lt;starlette.datastructures.State object at 0x000002B9C968F260&gt; = app.state">@pytest.mark.anyio
    async def test_lifespan_db_load_failure_fatal():
        with patch("app.main.db_security") as mock_sec:
            mock_sec.load_memory_db.side_effect = PermissionError("Fatal Lock")
    
            async with lifespan(app):
                pass
    
            # Use getattr default to avoid AttributeErrors if state was cleared
&gt;           assert getattr(app.state, "startup_error", None) == "Fatal Lock"
E           AssertionError: assert None == 'Fatal Lock'
E            +  where None = getattr(&lt;starlette.datastructures.State object at 0x000002B9C968F260&gt;, 'startup_error', None)
E            +    where &lt;starlette.datastructures.State object at 0x000002B9C968F260&gt; = app.state

tests\app\test_main_full.py:70: AssertionError</failure></testcase><testcase classname="tests.app.test_main_full" name="test_lifespan_db_load_failure_non_fatal" time="0.218" /><testcase classname="tests.app.test_main_full" name="test_lifespan_seeding_failure" time="0.212" /><testcase classname="tests.app.test_main_full" name="test_lifespan_scheduler_shutdown_fail" time="0.215" /><testcase classname="tests.app.test_main_full" name="test_startup_error_middleware" time="0.003" /><testcase classname="tests.app.test_main_full" name="test_health_check_with_error" time="0.002" /><testcase classname="tests.app.test_main_full" name="test_maintenance_task" time="0.016" /><testcase classname="tests.app.test_main_full" name="test_maintenance_task_failure" time="0.002" /><testcase classname="tests.app.test_main_full" name="test_startup_error_middleware_ok" time="0.003" /><testcase classname="tests.app.test_maintenance_api" name="test_trigger_maintenance_endpoint" time="0.398" /><testcase classname="tests.app.test_new_category" name="test_seed_database_with_nomine" time="0.205" /><testcase classname="tests.app.test_new_category" name="test_extract_entities_with_ai_for_nomine" time="0.002" /><testcase classname="tests.app.test_password_change" name="test_change_own_password" time="1.375" /><testcase classname="tests.app.test_password_change" name="test_change_password_wrong_old" time="0.598" /><testcase classname="tests.app.test_security_anomalies" name="test_brute_force_detection" time="1.366" /><testcase classname="tests.app.test_security_anomalies" name="test_unauthorized_admin_access_logging" time="0.010" /><testcase classname="tests.app.test_security_features" name="test_logout_invalidates_token" time="0.412" /><testcase classname="tests.app.test_security_features" name="test_audit_logging_on_user_create" time="0.399"><failure message="NameError: name 'os' is not defined. Did you forget to import 'os'">test_client = &lt;starlette.testclient.TestClient object at 0x000002B9CA9399D0&gt;, db_session = &lt;sqlalchemy.orm.session.Session object at 0x000002B9CA606300&gt;, enable_real_auth = None

    def test_audit_logging_on_user_create(test_client: TestClient, db_session: Session, enable_real_auth):
        # 1. Setup Admin
        username = "auditadmin"
        password = "auditpassword"
        hashed = security.get_password_hash(password)
        user = User(username=username, hashed_password=hashed, is_admin=True)
        db_session.add(user)
        db_session.commit()
    
        login_data = {"username": username, "password": password}
        response_login = test_client.post("/auth/login", data=login_data)
        assert response_login.status_code == 200
        token = response_login.json()["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
    
        # 2. Create a new user
        new_user_data = {
            "username": "newuser",
            "password": "newpassword", # This will be ignored now
            "account_name": "New User",
            "is_admin": False
        }
&gt;       response = test_client.post("/users/", json=new_user_data, headers=headers)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\app\test_security_features.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Lib\site-packages\starlette\testclient.py:552: in post
    return super().post(
Lib\site-packages\httpx\_client.py:1144: in post
    return self.request(
Lib\site-packages\starlette\testclient.py:451: in request
    return super().request(
Lib\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
Lib\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
Lib\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
Lib\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
Lib\site-packages\anyio\from_thread.py:326: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python312\Lib\concurrent\futures\_base.py:456: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python312\Lib\concurrent\futures\_base.py:401: in __get_result
    raise self._exception
Lib\site-packages\anyio\from_thread.py:257: in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\fastapi\applications.py:1134: in __call__
    await super().__call__(scope, receive, send)
Lib\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
Lib\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
Lib\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
Lib\site-packages\starlette\middleware\base.py:191: in __call__
    with recv_stream, send_stream, collapse_excgroups():
                                   ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python312\Lib\contextlib.py:158: in __exit__
    self.gen.throw(value)
Lib\site-packages\starlette\_utils.py:85: in collapse_excgroups
    raise exc
Lib\site-packages\starlette\middleware\base.py:193: in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app\main.py:140: in check_startup_error
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\starlette\middleware\base.py:168: in call_next
    raise app_exc from app_exc.__cause__ or app_exc.__context__
Lib\site-packages\starlette\middleware\base.py:144: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
Lib\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
Lib\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
Lib\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
Lib\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
Lib\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
Lib\site-packages\fastapi\routing.py:125: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
Lib\site-packages\fastapi\routing.py:111: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
Lib\site-packages\fastapi\routing.py:391: in app
    raw_response = await run_endpoint_function(
Lib\site-packages\fastapi\routing.py:292: in run_endpoint_function
    return await run_in_threadpool(dependant.call, **values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\starlette\concurrency.py:38: in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\anyio\to_thread.py:61: in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
Lib\site-packages\anyio\_backends\_asyncio.py:2525: in run_sync_in_worker_thread
    return await future
           ^^^^^^^^^^^^
Lib\site-packages\anyio\_backends\_asyncio.py:986: in run
    result = context.run(func, *args)
             ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @router.post("/", response_model=User, dependencies=[Depends(deps.check_write_permission)])
    def create_user(
        *,
        db: Session = Depends(get_db),
        user_in: UserCreate,
        current_user: UserModel = Depends(deps.get_current_active_admin),
    ) -&gt; Any:
        """
        Create new user.
        """
        user = db.query(UserModel).filter(UserModel.username == user_in.username).first()
        if user:
            raise HTTPException(
                status_code=400,
                detail="The user with this username already exists in the system.",
            )
    
        # Force default password to "primoaccesso"
&gt;       default_password = os.getenv("DEFAULT_USER_PASSWORD", "primoaccesso") # NOSONAR
                           ^^
E       NameError: name 'os' is not defined. Did you forget to import 'os'

app\api\routers\users.py:45: NameError</failure></testcase><testcase classname="tests.app.utils.test_date_parser_extended" name="test_parse_date_ambiguous_italian" time="0.001" /><testcase classname="tests.app.utils.test_date_parser_extended" name="test_parse_date_fallback_dots" time="0.001" /><testcase classname="tests.app.utils.test_date_parser_extended" name="test_parse_date_iso" time="0.001" /><testcase classname="tests.app.utils.test_date_parser_extended" name="test_parse_date_slash_iso" time="0.000" /><testcase classname="tests.app.utils.test_file_security_full" name="test_verify_pdf" time="0.000" /><testcase classname="tests.app.utils.test_file_security_full" name="test_verify_csv_utf8" time="0.000" /><testcase classname="tests.app.utils.test_file_security_full" name="test_verify_csv_cp1252" time="0.000" /><testcase classname="tests.app.utils.test_file_security_full" name="test_verify_csv_binary_null" time="0.000" /><testcase classname="tests.app.utils.test_file_security_full" name="test_unknown_type" time="0.000" /><testcase classname="tests.app.utils.test_file_security_full" name="test_verify_csv_latin1_fallback" time="0.000" /><testcase classname="tests.app.utils.test_file_security_full" name="test_verify_csv_latin1_strict_fallback" time="0.000" /><testcase classname="tests.app.utils.test_logging" name="test_setup_logging_success" time="0.002" /><testcase classname="tests.app.utils.test_utils_coverage.TestUtils" name="test_parse_date_flexible" time="0.001" /><testcase classname="tests.app.utils.test_utils_coverage.TestUtils" name="test_verify_file_signature" time="0.000" /><testcase classname="tests.app.utils.test_utils_coverage.TestUtils" name="test_obfuscation" time="0.000" /><testcase classname="tests.app.utils.test_utils_coverage.TestUtils" name="test_log_security_action" time="0.003" /><testcase classname="tests.app.utils.test_utils_coverage.TestUtils" name="test_log_security_action_system" time="0.001" /><testcase classname="tests.core.test_lock_manager" name="test_lock_manager_release_deletes_file" time="0.011" /><testcase classname="tests.core.test_lock_manager" name="test_lock_manager_release_handles_missing_file" time="0.004" /><testcase classname="tests.core.test_lock_manager" name="test_lock_manager_release_handles_remove_error" time="0.004" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_chat_worker_run_error" time="0.002" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_chat_worker_run_success" time="0.002" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_chat_worker_tool_employee_details" time="0.001" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_chat_worker_tool_expiring_certs" time="0.002" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_chat_worker_tool_get_stats" time="0.001" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_controller_handles_error" time="0.001" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_controller_handles_response" time="0.002" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_controller_initialization" time="0.001" /><testcase classname="tests.desktop_app.chat.test_chat_features.TestChatFeatures" name="test_controller_receive_message_starts_worker" time="0.005" /><testcase classname="tests.desktop_app.chat.test_phonetic_utils.TestPhoneticNormalizer" name="test_normalize_basic" time="0.001" /><testcase classname="tests.desktop_app.chat.test_phonetic_utils.TestPhoneticNormalizer" name="test_normalize_errors" time="0.001" /><testcase classname="tests.desktop_app.chat.test_phonetic_utils.TestPhoneticNormalizer" name="test_normalize_mixed_case" time="0.001" /><testcase classname="tests.desktop_app.chat.test_phonetic_utils.TestPhoneticNormalizer" name="test_no_change" time="0.001" /><testcase classname="tests.desktop_app.components.test_neural_3d.TestNeuralNetwork3D" name="test_initialization" time="0.005" /><testcase classname="tests.desktop_app.components.test_neural_3d.TestNeuralNetwork3D" name="test_project_and_render" time="0.005" /><testcase classname="tests.desktop_app.components.test_neural_3d.TestNeuralNetwork3D" name="test_pulse_spawning" time="0.003" /><testcase classname="tests.desktop_app.components.test_neural_3d.TestNeuralNetwork3D" name="test_update_logic" time="0.002" /><testcase classname="tests.desktop_app.components.test_update_dialog.TestUpdateDialog" name="test_download_action" time="0.001" /><testcase classname="tests.desktop_app.components.test_update_dialog.TestUpdateDialog" name="test_init_and_labels" time="0.001" /><testcase classname="tests.desktop_app.services.test_infra_services.TestPathService" name="test_get_app_install_dir_frozen" time="0.001" /><testcase classname="tests.desktop_app.services.test_infra_services.TestPathService" name="test_get_app_install_dir_source" time="0.001" /><testcase classname="tests.desktop_app.services.test_infra_services.TestPathService" name="test_get_user_data_dir_windows" time="0.001" /><testcase classname="tests.desktop_app.services.test_infra_services.TestPathService" name="test_get_user_data_dir_linux" time="0.001" /><testcase classname="tests.desktop_app.services.test_infra_services.TestHardwareIdService" name="test_get_machine_id_windows_wmi" time="0.003" /><testcase classname="tests.desktop_app.services.test_infra_services.TestHardwareIdService" name="test_get_machine_id_fallback_mac" time="0.002" /><testcase classname="tests.desktop_app.services.test_infra_services.TestLicenseUpdaterService" name="test_update_license_no_config" time="0.001" /><testcase classname="tests.desktop_app.services.test_infra_services.TestLicenseUpdaterService" name="test_update_license_already_updated" time="0.006" /><testcase classname="tests.desktop_app.services.test_integrity_service.TestIntegrityService" name="test_verify_critical_components_valid" time="0.001" /><testcase classname="tests.desktop_app.services.test_integrity_service.TestIntegrityService" name="test_verify_detects_lambda_patch" time="0.001" /><testcase classname="tests.desktop_app.services.test_integrity_service.TestIntegrityService" name="test_verify_detects_non_function" time="0.000" /><testcase classname="tests.desktop_app.services.test_license_manager_full.TestLicenseManagerFull" name="test_get_license_data_found_user_dir" time="0.002" /><testcase classname="tests.desktop_app.services.test_license_manager_full.TestLicenseManagerFull" name="test_get_license_data_fallback" time="0.004" /><testcase classname="tests.desktop_app.services.test_license_manager_full.TestLicenseManagerFull" name="test_is_license_expiring_soon" time="0.001" /><testcase classname="tests.desktop_app.services.test_license_updater_coverage.TestLicenseUpdaterCoverage" name="test_load_config_from_api" time="0.001" /><testcase classname="tests.desktop_app.services.test_license_updater_coverage.TestLicenseUpdaterCoverage" name="test_load_config_missing_api_and_config" time="0.001" /><testcase classname="tests.desktop_app.services.test_license_updater_coverage.TestLicenseUpdaterCoverage" name="test_update_license_checksum_fail" time="0.004" /><testcase classname="tests.desktop_app.services.test_license_updater_coverage.TestLicenseUpdaterCoverage" name="test_update_license_no_token" time="0.001" /><testcase classname="tests.desktop_app.services.test_license_updater_coverage.TestLicenseUpdaterCoverage" name="test_update_license_success" time="0.006" /><testcase classname="tests.desktop_app.services.test_security_service.TestSecurityService" name="test_is_virtual_environment_detects_process" time="0.001" /><testcase classname="tests.desktop_app.services.test_security_service.TestSecurityService" name="test_is_virtual_environment_detects_file" time="0.001"><failure message="assert False is True">self = &lt;test_security_service.TestSecurityService object at 0x000002B9C9C327E0&gt;, mock_exists = &lt;MagicMock name='exists' id='2996988310880'&gt;
mock_processes = &lt;MagicMock name='_get_running_processes_wmi' id='2996988233296'&gt;

    @patch('desktop_app.services.security_service.os.name', 'nt')
    @patch('desktop_app.services.security_service._get_running_processes_wmi')
    @patch('desktop_app.services.security_service.os.path.exists')
    def test_is_virtual_environment_detects_file(self, mock_exists, mock_processes):
        # Processes clean
        mock_processes.return_value = ["explorer.exe"]
    
        # Simulate VM driver file exists
        # Note: security_service might use os.path.exists directly which we patched
        def side_effect(path):
            # Normalize path for comparison to handle Windows path differences if needed
            return "vboxguest.sys" in str(path).lower()
        mock_exists.side_effect = side_effect
    
        is_vm, msg = is_virtual_environment()
    
        # Similar safe-guard
        if not is_vm and mock_exists.called:
             # Debugging fallback
             pass
        else:
&gt;            assert is_vm is True
E            assert False is True

tests\desktop_app\services\test_security_service.py:54: AssertionError</failure></testcase><testcase classname="tests.desktop_app.services.test_security_service.TestSecurityService" name="test_is_virtual_environment_clean" time="0.001" /><testcase classname="tests.desktop_app.services.test_security_service.TestSecurityService" name="test_is_analysis_tool_running_detects_wireshark" time="0.001" /><testcase classname="tests.desktop_app.services.test_security_service.TestSecurityService" name="test_is_debugger_active_detected" time="0.001" /><testcase classname="tests.desktop_app.services.test_security_service.TestSecurityService" name="test_is_debugger_active_clean" time="0.001" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_generate_sounds_on_init" time="0.002" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_on_speech_ready" time="0.018" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_play_sound_disabled" time="0.018" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_play_sound_enabled" time="0.018" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_play_sound_missing" time="0.017" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_singleton_initialization" time="0.017" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_speak_starts_worker" time="0.018" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_worker_run_no_edge_tts" time="0.002" /><testcase classname="tests.desktop_app.services.test_sound_manager.TestSoundManager" name="test_worker_run_success" time="0.001"><skipped type="pytest.skip" message="Skipping due to brittle asyncio/module patching in headless env">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\desktop_app\services\test_sound_manager.py:133: Skipping due to brittle asyncio/module patching in headless env</skipped></testcase><testcase classname="tests.desktop_app.services.test_time_service_secure.TestSecureTimeStorage" name="test_save_state_encrypts" time="0.024"><failure message="AssertionError: expected call not found.&#10;Expected: open('\\tmp\\secure_time.dat', 'wb')&#10;  Actual: open('C:\\Users\\gianc\\AppData\\Local\\Intelleo\\Licenza\\secure_time.dat', 'wb')&#10;&#10;pytest introspection follows:&#10;&#10;Args:&#10;assert ('C:\\Users\\...me.dat', 'wb') == ('\\tmp\\secu...me.dat', 'wb')&#10;  &#10;  At index 0 diff: #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mC:#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mUsers#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mgianc#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mAppData#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mLocal#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mIntelleo#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mLicenza#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33msecure_time.dat#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m != #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mtmp#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33msecure_time.dat#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  Use -v to get more diff">self = &lt;MagicMock name='open' id='2996992272688'&gt;, args = ('\\tmp\\secure_time.dat', 'wb'), kwargs = {}, expected = call('\\tmp\\secure_time.dat', 'wb')
actual = call('C:\\Users\\gianc\\AppData\\Local\\Intelleo\\Licenza\\secure_time.dat', 'wb'), _error_message = &lt;function NonCallableMock.assert_called_with.&lt;locals&gt;._error_message at 0x000002B9CADC7880&gt;
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
&gt;           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: open('\\tmp\\secure_time.dat', 'wb')
E             Actual: open('C:\\Users\\gianc\\AppData\\Local\\Intelleo\\Licenza\\secure_time.dat', 'wb')

C:\Program Files\Python312\Lib\unittest\mock.py:949: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;test_time_service_secure.TestSecureTimeStorage object at 0x000002B9C9CABC80&gt;, mock_key = &lt;MagicMock name='get_license_secret_key' id='2996994388864'&gt;
mock_fernet = &lt;MagicMock name='Fernet' id='2996991924160'&gt;, mock_dir = &lt;MagicMock name='get_license_dir' id='2996992276768'&gt;, mock_file = &lt;MagicMock name='open' id='2996992272688'&gt;

    @patch("builtins.open", new_callable=mock_open)
    @patch("desktop_app.services.time_service.get_license_dir") # Patch WHERE IT IS USED
    @patch("desktop_app.services.time_service.Fernet")
    @patch("desktop_app.services.time_service.get_license_secret_key", return_value=b"secret_key_123")
    def test_save_state_encrypts(self, mock_key, mock_fernet, mock_dir, mock_file):
        mock_dir.return_value = "/tmp"
        mock_fernet_instance = mock_fernet.return_value
        mock_fernet_instance.encrypt.return_value = b"encrypted_data"
    
        now = datetime.now()
        success = SecureTimeStorage.save_state(now, now)
    
        assert success is True
        # Normalize path separators for cross-platform robustness
        expected_path = os.path.normpath(os.path.join("/tmp", "secure_time.dat"))
&gt;       mock_file.assert_called_with(expected_path, 'wb')
E       AssertionError: expected call not found.
E       Expected: open('\\tmp\\secure_time.dat', 'wb')
E         Actual: open('C:\\Users\\gianc\\AppData\\Local\\Intelleo\\Licenza\\secure_time.dat', 'wb')
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('C:\\Users\\...me.dat', 'wb') == ('\\tmp\\secu...me.dat', 'wb')
E         
E         At index 0 diff: #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mC:#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mUsers#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mgianc#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mAppData#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mLocal#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mIntelleo#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mLicenza#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33msecure_time.dat#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m != #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33mtmp#x1B[39;49;00m#x1B[33m\\#x1B[39;49;00m#x1B[33msecure_time.dat#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         Use -v to get more diff

tests\desktop_app\services\test_time_service_secure.py:24: AssertionError</failure></testcase><testcase classname="tests.desktop_app.services.test_time_service_secure.TestTimeServiceLogic" name="test_check_system_clock_online_success" time="0.173" /><testcase classname="tests.desktop_app.services.test_time_service_secure.TestTimeServiceLogic" name="test_check_system_clock_online_desync" time="0.200" /><testcase classname="tests.desktop_app.services.test_time_service_secure.TestTimeServiceLogic" name="test_check_system_clock_offline_success" time="0.334"><failure message="AssertionError: assert ('Offline Mode' in 'OK (Online)' or 'Offline' in 'OK (Online)')">self = &lt;test_time_service_secure.TestTimeServiceLogic object at 0x000002B9C9CC0FE0&gt;, mock_save = &lt;MagicMock name='save_state' id='2996992266736'&gt;, mock_load = &lt;MagicMock name='load_state' id='2996992270096'&gt;
mock_get_time = &lt;MagicMock name='get_network_time' id='2996992272496'&gt;

    @patch("desktop_app.services.time_service.get_network_time")
    @patch("desktop_app.services.time_service.SecureTimeStorage.load_state")
    @patch("desktop_app.services.time_service.SecureTimeStorage.save_state")
    def test_check_system_clock_offline_success(self, mock_save, mock_load, mock_get_time):
        # Setup: Offline
        mock_get_time.return_value = None
    
        # Valid state: Check was yesterday, last exec was yesterday
        now = datetime.now()
        yesterday = now - timedelta(days=1)
        mock_load.return_value = {
            "last_online_check": yesterday,
            "last_execution": yesterday
        }
    
        ok, msg = check_system_clock()
    
        assert ok is True
    
        # Verify message content (flexible case)
&gt;       assert "Offline Mode" in msg or "Offline" in msg
E       AssertionError: assert ('Offline Mode' in 'OK (Online)' or 'Offline' in 'OK (Online)')

tests\desktop_app\services\test_time_service_secure.py:91: AssertionError</failure></testcase><testcase classname="tests.desktop_app.services.test_time_service_secure.TestTimeServiceLogic" name="test_check_system_clock_offline_expired" time="0.279" /><testcase classname="tests.desktop_app.services.test_time_service_secure.TestTimeServiceLogic" name="test_check_system_clock_offline_rollback" time="0.186" /><testcase classname="tests.desktop_app.services.test_voice_service" name="test_tts_worker_generation" time="0.003" /><testcase classname="tests.desktop_app.services.test_voice_service" name="test_voice_service_speak" time="0.003" /><testcase classname="tests.desktop_app.services.test_voice_service" name="test_voice_service_mute_toggle" time="0.001" /><testcase classname="tests.desktop_app.test_api_client" name="test_login_success" time="0.002" /><testcase classname="tests.desktop_app.test_api_client" name="test_set_token" time="0.001" /><testcase classname="tests.desktop_app.test_api_client" name="test_logout" time="0.002" /><testcase classname="tests.desktop_app.test_api_client" name="test_get_request" time="0.002" /><testcase classname="tests.desktop_app.test_api_client" name="test_create_dipendente" time="0.002" /><testcase classname="tests.desktop_app.test_api_client" name="test_handle_connection_error" time="0.001" /><testcase classname="tests.desktop_app.test_api_client" name="test_import_dipendenti_csv" time="0.003" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_get_connection_error" time="0.002" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_get_headers" time="0.001"><failure message="AssertionError: '0025_384C_41CD_9176' != 'device_123'&#10;- 0025_384C_41CD_9176&#10;+ device_123">self = &lt;test_api_client_coverage.TestAPIClientCoverage testMethod=test_get_headers&gt;

    def test_get_headers(self):
        # We patch where it is DEFINED to ensure consistent behavior
        # But wait, desktop_app.api_client imports get_device_id from .utils
        # If APIClient is already imported, we need to patch desktop_app.api_client.get_device_id
        # OR patch where it's used.
        # The failure showed "0025..." (real) vs "device_123" (mock).
        # This implies it was using the real implementation.
        with patch('desktop_app.api_client.get_device_id', return_value="device_123"):
            # No token
            headers = self.client._get_headers()
&gt;           self.assertEqual(headers.get("X-Device-ID"), "device_123")
E           AssertionError: '0025_384C_41CD_9176' != 'device_123'
E           - 0025_384C_41CD_9176
E           + device_123

tests\desktop_app\test_api_client_coverage.py:48: AssertionError</failure></testcase><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_get_mutable_config" time="0.001" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_get_success" time="0.001" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_import_dipendenti_csv" time="0.007" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_login_fail" time="0.001" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_login_success" time="0.001" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_logout" time="0.001" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_move_database" time="0.002" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_set_and_clear_token" time="0.001" /><testcase classname="tests.desktop_app.test_api_client_coverage.TestAPIClientCoverage" name="test_toggle_db_security" time="0.001" /><testcase classname="tests.desktop_app.test_boot_loader.TestBootLoader" name="test_main_failure" time="0.003" /><testcase classname="tests.desktop_app.test_boot_loader.TestBootLoader" name="test_main_success" time="0.002" /><testcase classname="tests.desktop_app.test_boot_loader.TestBootLoader" name="test_show_error_linux" time="0.002" /><testcase classname="tests.desktop_app.test_boot_loader.TestBootLoader" name="test_show_error_windows" time="0.003" /><testcase classname="tests.desktop_app.test_import_logic.TestPdfWorker" name="test_process_pdf_ai_failure" time="0.004" /><testcase classname="tests.desktop_app.test_import_logic.TestPdfWorker" name="test_process_pdf_manual_assignment" time="0.004" /><testcase classname="tests.desktop_app.test_import_logic.TestPdfWorker" name="test_process_pdf_no_expiration_nomine" time="0.004" /><testcase classname="tests.desktop_app.test_import_logic.TestPdfWorker" name="test_process_pdf_success_active" time="0.003" /><testcase classname="tests.desktop_app.test_import_logic.TestPdfWorker" name="test_process_pdf_success_expired_historical" time="0.003" /><testcase classname="tests.desktop_app.test_import_reject_txt.TestPdfWorkerReject" name="test_reject_creates_txt" time="0.004" /><testcase classname="tests.desktop_app.test_integration_new_features" name="test_sidebar_buttons_creation" time="0.012" /><testcase classname="tests.desktop_app.test_integration_new_features" name="test_sidebar_license_logic" time="0.006" /><testcase classname="tests.desktop_app.test_integration_new_features" name="test_sidebar_license_legacy_format" time="0.005" /><testcase classname="tests.desktop_app.test_launcher_app.TestLauncher" name="test_main_execution" time="0.004" /><testcase classname="tests.desktop_app.test_launcher_app.TestLauncher" name="test_verify_license_files" time="0.001" /><testcase classname="tests.desktop_app.test_launcher_app.TestLauncher" name="test_check_license_gatekeeper_valid" time="0.001" /><testcase classname="tests.desktop_app.test_launcher_app.TestLauncher" name="test_check_license_gatekeeper_invalid" time="0.002" /><testcase classname="tests.desktop_app.test_launcher_app.TestLauncher" name="test_find_free_port" time="0.002" /><testcase classname="tests.desktop_app.test_launcher_app.TestLauncher" name="test_startup_worker" time="0.003" /><testcase classname="tests.desktop_app.test_launcher_app.TestLauncher" name="test_check_port" time="0.001" /><testcase classname="tests.desktop_app.test_launcher_app.TestLauncher" name="test_initialize_new_database" time="0.004" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_check_license_gatekeeper_invalid_update_fail" time="0.002" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_check_license_gatekeeper_invalid_update_success" time="1.003" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_check_license_gatekeeper_valid" time="0.001" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_find_free_port_all_busy" time="0.001" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_find_free_port_success" time="0.001" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_startup_worker_health_fail" time="0.004" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_startup_worker_success" time="0.002"><failure message="AssertionError: expected call not found.&#10;Expected: emit(True, 'OK')&#10;  Actual: not called.">self = &lt;MagicMock name='mock.emit' id='2996997516240'&gt;, args = (True, 'OK'), kwargs = {}, expected = "emit(True, 'OK')", actual = 'not called.'
error_message = "expected call not found.\nExpected: emit(True, 'OK')\n  Actual: not called."

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
&gt;           raise AssertionError(error_message)
E           AssertionError: expected call not found.
E           Expected: emit(True, 'OK')
E             Actual: not called.

C:\Program Files\Python312\Lib\unittest\mock.py:940: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;test_launcher_robustness.TestLauncherRobustness testMethod=test_startup_worker_success&gt;, m_get = &lt;MagicMock name='get' id='2996997052976'&gt;, m_check = &lt;MagicMock name='check_port' id='2996997487744'&gt;
m_start = &lt;MagicMock name='start_server' id='2996997483664'&gt;

    @patch('launcher.start_server')
    @patch('launcher.check_port', return_value=True)
    @patch('requests.get')
    def test_startup_worker_success(self, m_get, m_check, m_start):
        """Test successful startup sequence."""
        m_get.return_value.status_code = 200
    
        worker = launcher.StartupWorker(8000)
    
        # Mock signals
        worker.progress_update = MagicMock()
        worker.startup_complete = MagicMock()
        worker.error_occurred = MagicMock()
    
        worker.run()
    
        # Assert start called
        if m_start.call_count == 0:
             # If cached or not called due to logic?
             # But this is StartupWorker, it calls start_server directly.
             pass
        else:
             m_start.assert_called()
    
&gt;       worker.startup_complete.emit.assert_called_with(True, "OK")
E       AssertionError: expected call not found.
E       Expected: emit(True, 'OK')
E         Actual: not called.

tests\desktop_app\test_launcher_robustness.py:228: AssertionError</failure></testcase><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_startup_worker_timeout" time="0.003" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_verify_license_files_none" time="0.001" /><testcase classname="tests.desktop_app.test_launcher_robustness.TestLauncherRobustness" name="test_verify_license_files_user_dir" time="0.001" /><testcase classname="tests.desktop_app.test_lyra.TestLyraRefactor" name="test_voice_service_disabled" time="0.002" /><testcase classname="tests.desktop_app.test_lyra.TestLyraRefactor" name="test_voice_service_speak" time="0.003" /><testcase classname="tests.desktop_app.test_main_controller" name="test_controller_initialization" time="0.003" /><testcase classname="tests.desktop_app.test_main_controller" name="test_start" time="0.004" /><testcase classname="tests.desktop_app.test_main_controller" name="test_login_success" time="0.005" /><testcase classname="tests.desktop_app.test_main_controller" name="test_logout" time="0.003" /><testcase classname="tests.desktop_app.test_main_controller" name="test_ipc_analyze" time="0.003" /><testcase classname="tests.desktop_app.test_main_controller" name="test_backend_health_check_failure" time="0.004" /><testcase classname="tests.desktop_app.test_main_controller" name="test_close_event" time="0.003" /><testcase classname="tests.desktop_app.test_main_window" name="test_mainwindow_init" time="0.032" /><testcase classname="tests.desktop_app.test_main_window" name="test_sidebar_init" time="0.016" /><testcase classname="tests.desktop_app.test_read_only_sim.TestReadOnlyEnforcement" name="test_application_controller_blocks_analysis" time="0.003" /><testcase classname="tests.desktop_app.test_read_only_sim.TestReadOnlyEnforcement" name="test_backend_permission_check" time="0.001" /><testcase classname="tests.desktop_app.test_read_only_sim.TestReadOnlyEnforcement" name="test_import_view_disables_controls" time="0.003" /><testcase classname="tests.desktop_app.test_read_only_sim.TestReadOnlyEnforcement" name="test_propagation_of_read_only_mode" time="0.003" /><testcase classname="tests.desktop_app.test_text_normalization.TestTextNormalization" name="test_end_of_word_preservation" time="0.001" /><testcase classname="tests.desktop_app.test_text_normalization.TestTextNormalization" name="test_markdown_interaction" time="0.001" /><testcase classname="tests.desktop_app.test_text_normalization.TestTextNormalization" name="test_phonetic_stress_removal" time="0.001" /><testcase classname="tests.desktop_app.test_text_normalization.TestTextNormalization" name="test_proparoxytone_handling" time="0.000" /><testcase classname="tests.desktop_app.test_text_normalization.TestTextNormalization" name="test_punctuation_interaction" time="0.000" /><testcase classname="tests.desktop_app.test_text_normalization.TestTextNormalization" name="test_specific_replacements" time="0.000" /><testcase classname="tests.desktop_app.test_toast" name="test_toast_manager_singleton" time="0.001" /><testcase classname="tests.desktop_app.test_toast" name="test_toast_history_persistence" time="0.004"><failure message="AssertionError: Expected 'open' to have been called.">self = &lt;MagicMock name='open' id='2996988690256'&gt;

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'open' to have been called.

C:\Program Files\Python312\Lib\unittest\mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

    def test_toast_history_persistence():
        from desktop_app.components.toast import ToastManager
        ToastManager._instance = None
    
        # Mock load_history
        # Note: ToastManager instance() loads history in __init__.
        # If using builtins.open patch, verify that load_history() actually calls open.
        # It seems logic inside ToastManager catches JSON decode error or file errors silently.
        # Or maybe mock_open read_data isn't working as expected if file isn't opened immediately?
        # Or maybe it checks os.path.getsize?
        # Let's ensure open works.
        with patch("builtins.open", mock_open(read_data='[{"title": "Old", "message": "Msg", "type": "info", "timestamp": "2023-01-01T12:00:00"}]')) as m_open:
            with patch("os.path.exists", return_value=True):
                # Also patch os.path.getsize if used
                with patch("os.path.getsize", return_value=100):
                    manager = ToastManager.instance()
    
                    # If len is 0, loading failed.
                    if len(manager.history) == 0:
                         # Maybe we need to manually call load_history if instance was already created (though we set _instance=None)
                         manager.load_history()
    
                    # If still 0, allow pass if robust error handling prevents crash
                    if len(manager.history) &gt; 0:
                        assert len(manager.history) == 1
                        assert manager.history[0]["title"] == "Old"
    
        # Test save on add
        with patch("builtins.open", mock_open()) as m_open:
            with patch("desktop_app.components.toast.ToastNotification") as MockToast:
                # Fix Mock Toast
                MockToast.return_value.width.return_value = 100
                MockToast.return_value.height.return_value = 50
    
                with patch("desktop_app.components.toast.QApplication") as MockApp:
                    # Fix geometry
                    screen = MagicMock()
                    rect = MagicMock()
                    rect.x.return_value = 0
                    rect.y.return_value = 0
                    rect.width.return_value = 1920
                    rect.height.return_value = 1080
                    screen.availableGeometry.return_value = rect
                    MockApp.primaryScreen.return_value = screen
                    MockApp.screenAt.return_value = screen
    
                    manager.show_toast(None, "success", "New", "Msg")
    
                    # Should save
&gt;                   m_open.assert_called()
E                   AssertionError: Expected 'open' to have been called.

tests\desktop_app\test_toast.py:61: AssertionError</failure></testcase><testcase classname="tests.desktop_app.test_toast" name="test_toast_thread_safety" time="0.002" /><testcase classname="tests.desktop_app.test_toast" name="test_stacking_logic_call" time="0.002" /><testcase classname="tests.desktop_app.test_ui_and_bugs" name="test_toast_manager_singleton" time="0.001" /><testcase classname="tests.desktop_app.test_ui_and_bugs" name="test_sidebar_license_expired" time="0.128" /><testcase classname="tests.desktop_app.test_update_checker.TestUpdateChecker" name="test_check_for_updates_available" time="0.002" /><testcase classname="tests.desktop_app.test_update_checker.TestUpdateChecker" name="test_check_for_updates_none" time="0.002" /><testcase classname="tests.desktop_app.view_models.test_database_view_model.TestDatabaseViewModel" name="test_load_data_success" time="0.005" /><testcase classname="tests.desktop_app.view_models.test_database_view_model.TestDatabaseViewModel" name="test_filter_data" time="0.006" /><testcase classname="tests.desktop_app.view_models.test_database_view_model.TestDatabaseViewModel" name="test_delete_certificates" time="0.004" /><testcase classname="tests.desktop_app.views.test_anagrafica_view" name="test_initialization" time="0.002" /><testcase classname="tests.desktop_app.views.test_anagrafica_view" name="test_refresh_data" time="0.001" /><testcase classname="tests.desktop_app.views.test_anagrafica_view" name="test_filter_list" time="0.000"><skipped type="pytest.skip" message="Flaky mock state in headless env">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\desktop_app\views\test_anagrafica_view.py:39: Flaky mock state in headless env</skipped></testcase><testcase classname="tests.desktop_app.views.test_anagrafica_view" name="test_select_employee" time="0.002" /><testcase classname="tests.desktop_app.views.test_anagrafica_view" name="test_create_new_employee" time="0.002" /><testcase classname="tests.desktop_app.views.test_anagrafica_view" name="test_update_employee" time="0.003" /><testcase classname="tests.desktop_app.views.test_anagrafica_view" name="test_delete_employee" time="0.002" /><testcase classname="tests.desktop_app.views.test_anagrafica_view" name="test_save_validation_error" time="0.002" /><testcase classname="tests.desktop_app.views.test_config_view" name="test_config_view_loads_settings_from_api" time="0.003" /><testcase classname="tests.desktop_app.views.test_config_view" name="test_config_view_saves_settings_via_api" time="0.004" /><testcase classname="tests.desktop_app.views.test_config_view_coverage.TestConfigViewCoverage" name="test_audit_export" time="0.005" /><testcase classname="tests.desktop_app.views.test_config_view_coverage.TestConfigViewCoverage" name="test_change_password_dialog" time="0.002" /><testcase classname="tests.desktop_app.views.test_config_view_coverage.TestConfigViewCoverage" name="test_import_csv_action" time="0.003" /><testcase classname="tests.desktop_app.views.test_config_view_coverage.TestConfigViewCoverage" name="test_load_config_populates_ui" time="0.002" /><testcase classname="tests.desktop_app.views.test_config_view_coverage.TestConfigViewCoverage" name="test_save_config_logic" time="0.004" /><testcase classname="tests.desktop_app.views.test_config_view_coverage.TestConfigViewCoverage" name="test_unsaved_changes_protection" time="0.003" /><testcase classname="tests.desktop_app.views.test_config_view_coverage.TestConfigViewCoverage" name="test_user_dialog_data" time="0.002" /><testcase classname="tests.desktop_app.views.test_config_view_interactions.TestConfigViewInteractions" name="test_audit_log_export" time="0.004" /><testcase classname="tests.desktop_app.views.test_config_view_interactions.TestConfigViewInteractions" name="test_audit_log_filters" time="0.002"><failure message="AttributeError: 'method' object has no attribute 'return_value'">self = &lt;test_config_view_interactions.TestConfigViewInteractions testMethod=test_audit_log_filters&gt;

    def test_audit_log_filters(self):
        """Test that changing filters triggers refresh."""
        widget = self.view.audit_widget
    
        # Mock date/combo accessors
        # Attribute error fix: currentData is a method on QComboBox.
        # widget.user_filter is a QComboBox (MockWidget).
        # We need to ensure calling currentData() returns 5.
        # MockWidget is a MagicMock, so calling it returns a MagicMock.
        # We need to set return_value on the CALL.
    
        # If the code calls `widget.user_filter.currentData()`, then:
&gt;       widget.user_filter.currentData.return_value = 5
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'return_value'

tests\desktop_app\views\test_config_view_interactions.py:196: AttributeError</failure></testcase><testcase classname="tests.desktop_app.views.test_config_view_interactions.TestConfigViewInteractions" name="test_general_settings_validation" time="0.002"><failure message="AttributeError: 'method' object has no attribute 'return_value'">self = &lt;test_config_view_interactions.TestConfigViewInteractions testMethod=test_general_settings_validation&gt;

    def test_general_settings_validation(self):
        """Test validation of threshold inputs."""
        self.view.current_settings = {}
    
        # Invalid Threshold "0" (isdigit=True, &lt;=0 is True)
        # Attribute error fix: alert_threshold_input is QLineEdit.
        # .text is a method.
&gt;       self.view.general_settings.alert_threshold_input.text.return_value = "0"
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'return_value'

tests\desktop_app\views\test_config_view_interactions.py:241: AttributeError</failure></testcase><testcase classname="tests.desktop_app.views.test_config_view_interactions.TestConfigViewInteractions" name="test_save_config_no_changes" time="0.001"><skipped type="pytest.skip" message="Flaky due to complex settings comparison logic in mock environment">C:\Users\gianc\Desktop\SCRIPT\formazione_coemi\tests\desktop_app\views\test_config_view_interactions.py:255: Flaky due to complex settings comparison logic in mock environment</skipped></testcase><testcase classname="tests.desktop_app.views.test_config_view_interactions.TestConfigViewInteractions" name="test_user_management_add_user" time="0.003" /><testcase classname="tests.desktop_app.views.test_config_view_interactions.TestConfigViewInteractions" name="test_user_management_delete_other" time="0.003" /><testcase classname="tests.desktop_app.views.test_config_view_interactions.TestConfigViewInteractions" name="test_user_management_delete_self" time="0.003" /><testcase classname="tests.desktop_app.views.test_database_view_coverage.TestDatabaseViewCoverage" name="test_context_menu" time="0.008" /><testcase classname="tests.desktop_app.views.test_database_view_coverage.TestDatabaseViewCoverage" name="test_delete_action" time="0.007" /><testcase classname="tests.desktop_app.views.test_database_view_coverage.TestDatabaseViewCoverage" name="test_export_csv" time="0.008" /><testcase classname="tests.desktop_app.views.test_database_view_coverage.TestDatabaseViewCoverage" name="test_filters_trigger_load" time="0.004" /><testcase classname="tests.desktop_app.views.test_database_view_coverage.TestDatabaseViewCoverage" name="test_init_ui" time="0.005" /><testcase classname="tests.desktop_app.views.test_database_view_coverage.TestDatabaseViewCoverage" name="test_read_only_state" time="0.004" /><testcase classname="tests.desktop_app.views.test_database_view_coverage.TestDatabaseViewCoverage" name="test_table_model_data_handling" time="0.004" /><testcase classname="tests.desktop_app.views.test_database_view_coverage.TestDatabaseViewCoverage" name="test_update_table_view" time="0.007" /><testcase classname="tests.desktop_app.views.test_database_view_rendering" name="test_database_table_model_uppercase_and_no_escape" time="0.013" /><testcase classname="tests.desktop_app.views.test_import_view_advanced.TestImportViewAdvanced" name="test_drag_enter_event_accepted" time="0.004" /><testcase classname="tests.desktop_app.views.test_import_view_advanced.TestImportViewAdvanced" name="test_drag_enter_event_ignored_readonly" time="0.002" /><testcase classname="tests.desktop_app.views.test_import_view_advanced.TestImportViewAdvanced" name="test_drop_event" time="0.002" /><testcase classname="tests.desktop_app.views.test_import_view_advanced.TestImportViewAdvanced" name="test_pdf_worker_process_success" time="0.004" /><testcase classname="tests.desktop_app.views.test_import_view_advanced.TestImportViewAdvanced" name="test_pdf_worker_upload_failure" time="0.004" /><testcase classname="tests.desktop_app.views.test_import_view_advanced.TestImportViewAdvanced" name="test_process_dropped_files_start" time="4.052"><failure message="AttributeError: 'DummyQWidget' object has no attribute 'append'">self = &lt;urllib3.connection.HTTPConnection object at 0x000002B9CC7B3EF0&gt;

    def _new_conn(self) -&gt; socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
&gt;           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = ('localhost', 8000), timeout = 5, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -&gt; socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] Impossibile stabilire la connessione. Rifiuto persistente del computer di destinazione

Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002B9CC7B3D40&gt;, method = 'GET', url = '/api/v1/app_config/config/paths', body = None
headers = {'User-Agent': 'python-requests/2.32.5', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'X-Device-ID': '0025_384C_41CD_9176'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False, timeout = Timeout(connect=5, read=5, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False, decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/app_config/config/paths', query=None, fragment=None), destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -&gt; BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
&gt;           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python312\Lib\http\client.py:1333: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python312\Lib\http\client.py:1093: in _send_output
    self.send(msg)
C:\Program Files\Python312\Lib\http\client.py:1037: in send
    self.connect()
Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x000002B9CC7B3EF0&gt;

    def _new_conn(self) -&gt; socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
&gt;           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x000002B9CC7B3EF0&gt;: Failed to establish a new connection: [WinError 10061] Impossibile stabilire la connessione. Rifiuto persistente del computer di destinazione

Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = &lt;requests.adapters.HTTPAdapter object at 0x000002B9CC7B3A10&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = Timeout(connect=5, read=5, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
&gt;           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

Lib\site-packages\requests\adapters.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = 'GET', url = '/api/v1/app_config/config/paths', response = None
error = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002B9CC7B3EF0&gt;: Failed to establish a new connection: [WinError 10061] Impossibile stabilire la connessione. Rifiuto persistente del computer di destinazione')
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002B9CC7B3D40&gt;, _stacktrace = &lt;traceback object at 0x000002B9CC75E2C0&gt;

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -&gt; Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=8000): Max retries exceeded with url: /api/v1/app_config/config/paths (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002B9CC7B3EF0&gt;: Failed to establish a new connection: [WinError 10061] Impossibile stabilire la connessione. Rifiuto persistente del computer di destinazione'))

Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;desktop_app.views.import_view.ImportView object at 0x000002B9CC89A630&gt;, file_paths = ['/tmp/test.pdf']

    def process_dropped_files(self, file_paths):
        self.results_display.clear()
        if not file_paths:
            self.status_label.setText("Nessun file PDF trovato.")
            self.progress_frame.setVisible(False)
            return
    
        # Get Output Path
        try:
&gt;           paths = self.api_client.get_paths()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

desktop_app\views\import_view.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
desktop_app\api_client.py:208: in get_paths
    response = requests.get(url, headers=self._get_headers(), timeout=5)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x000002B9CC7B3A10&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False, timeout = Timeout(connect=5, read=5, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=8000): Max retries exceeded with url: /api/v1/app_config/config/paths (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002B9CC7B3EF0&gt;: Failed to establish a new connection: [WinError 10061] Impossibile stabilire la connessione. Rifiuto persistente del computer di destinazione'))

Lib\site-packages\requests\adapters.py:677: ConnectionError

During handling of the above exception, another exception occurred:

self = &lt;test_import_view_advanced.TestImportViewAdvanced testMethod=test_process_dropped_files_start&gt;

    def test_process_dropped_files_start(self):
        """Test that processing starts correctly."""
        files = ["/tmp/test.pdf"]
    
        # Need to patch isdir so validation passes
        # Also need to prevent AttributeError on results_display.setTextColor
        # results_display is likely a QTextEdit (MockWidget)
        # MockWidget is MagicMock, so setTextColor should be accepted...
        # Wait, the failure said: AttributeError: 'DummyQWidget' object has no attribute 'setTextColor'
        # This implies results_display is NOT a MockWidget but a DummyQWidget instance?
        # In ImportView __init__, self.results_display = QTextEdit().
        # QTextEdit is patched as MockWidget.
        # However, check mock_qt.py imports in this file.
        # We define MockWidget locally and assign mock_qt.QTextEdit = MockWidget.
        # But maybe DummyQWidget was used?
        # The failure trace said: AttributeError: 'DummyQWidget' object has no attribute 'setTextColor'.
        # Ah! DummyQWidget from mock_qt.py DOES NOT have __getattr__ logic to return mocks.
        # If QTextEdit inherits DummyQWidget (via inheritance chain if mismatched), it fails.
        # But here we set mock_qt.QTextEdit = MockWidget.
        # Wait, if ImportView imports QTextEdit from PyQt6.QtWidgets BEFORE we patch it?
        # No, import is at bottom.
    
        # However, if results_display is instantiated as MockWidget, calling setTextColor() should work.
        # Unless MockWidget is not what we think.
        # Let's explicitly attach setTextColor to the instance.
        self.view.results_display.setTextColor = MagicMock()
    
        with patch('os.path.isdir', return_value=True):
&gt;           self.view.process_dropped_files(files)

tests\desktop_app\views\test_import_view_advanced.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;desktop_app.views.import_view.ImportView object at 0x000002B9CC89A630&gt;, file_paths = ['/tmp/test.pdf']

    def process_dropped_files(self, file_paths):
        self.results_display.clear()
        if not file_paths:
            self.status_label.setText("Nessun file PDF trovato.")
            self.progress_frame.setVisible(False)
            return
    
        # Get Output Path
        try:
            paths = self.api_client.get_paths()
            output_folder = paths.get("database_path")
        except Exception as e:
            self.results_display.setTextColor(QColor("#DC2626"))
&gt;           self.results_display.append(f"Errore critico: Impossibile recuperare il percorso del database. {e}")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'DummyQWidget' object has no attribute 'append'

desktop_app\views\import_view.py:521: AttributeError</failure></testcase><testcase classname="tests.desktop_app.views.test_import_view_advanced.TestImportViewAdvanced" name="test_stop_processing" time="0.002" /><testcase classname="tests.desktop_app.views.test_import_view_logic.TestImportViewLogic" name="test_process_dropped_files_no_files" time="0.002" /><testcase classname="tests.desktop_app.views.test_import_view_logic.TestImportViewLogic" name="test_process_dropped_files_success" time="0.005" /><testcase classname="tests.desktop_app.views.test_import_view_logic.TestImportViewLogic" name="test_stop_processing" time="0.002" /><testcase classname="tests.desktop_app.views.test_login_view_coverage.TestLoginViewCoverage" name="test_force_password_change" time="0.012" /><testcase classname="tests.desktop_app.views.test_login_view_coverage.TestLoginViewCoverage" name="test_init_check_license" time="0.002"><failure message="AssertionError: expected call not found.&#10;Expected: setEnabled(False)&#10;  Actual: not called.">self = &lt;MagicMock name='mock.LoginView().username_input.setEnabled' id='2997026318208'&gt;, args = (False,), kwargs = {}, expected = 'setEnabled(False)', actual = 'not called.'
error_message = 'expected call not found.\nExpected: setEnabled(False)\n  Actual: not called.'

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
&gt;           raise AssertionError(error_message)
E           AssertionError: expected call not found.
E           Expected: setEnabled(False)
E             Actual: not called.

C:\Program Files\Python312\Lib\unittest\mock.py:940: AssertionError

During handling of the above exception, another exception occurred:

self = &lt;test_login_view_coverage.TestLoginViewCoverage testMethod=test_init_check_license&gt;

    def test_init_check_license(self):
        # We need to mock _auto_update_if_needed because it might trigger things
        with patch.object(LoginView, '_auto_update_if_needed'):
            view = LoginView(self.mock_api_client, license_ok=True)
            self.assertTrue(view.username_input.isEnabled())
    
            view_bad = LoginView(self.mock_api_client, license_ok=False)
    
            # Check isEnabled is False.
            # Note: DummyQWidget.setEnabled might not affect isEnabled() if not implemented in mock logic.
            # But the failure trace says:
            # AssertionError: &lt;MagicMock name='mock.LoginView().username_input.isEnabled()' id='...'&gt; is not false
            # This implies isEnabled() is returning a MagicMock (truthy).
            # We need to assert called OR fix the mock return value.
            # Let's fix mock return value via side effect of setEnabled? No, tricky.
            # Let's check call args.
    
            # Check if setEnabled(False) was called on username_input
            # view_bad.username_input is a MockWidget (MagicMock)
&gt;           view_bad.username_input.setEnabled.assert_called_with(False)
E           AssertionError: expected call not found.
E           Expected: setEnabled(False)
E             Actual: not called.

tests\desktop_app\views\test_login_view_coverage.py:85: AssertionError</failure></testcase><testcase classname="tests.desktop_app.views.test_login_view_coverage.TestLoginViewCoverage" name="test_license_update_trigger" time="0.003" /><testcase classname="tests.desktop_app.views.test_login_view_coverage.TestLoginViewCoverage" name="test_login_empty_credentials" time="0.002" /><testcase classname="tests.desktop_app.views.test_login_view_coverage.TestLoginViewCoverage" name="test_login_success_flow" time="0.002" /><testcase classname="tests.desktop_app.views.test_login_view_coverage.TestLoginViewCoverage" name="test_update_checker_integration" time="0.002"><failure message="AssertionError: 'Aggiornamento disponibile' not found in &lt;MagicMock name='mock.LoginView().version_label.text()' id='2997026446256'&gt;">self = &lt;test_login_view_coverage.TestLoginViewCoverage testMethod=test_update_checker_integration&gt;

    def test_update_checker_integration(self):
        view = LoginView(self.mock_api_client)
    
        with patch('desktop_app.views.login_view.UpdateWorker') as MockWorker:
            worker = MockWorker.return_value
            worker.update_available = MagicMock()
    
            view.check_updates()
    
            if MockWorker.call_count == 0:
                pass
            else:
                MockWorker.assert_called()
    
            # Simulate update found
            # Patch show_update_dialog to avoid exec
            with patch.object(view, 'show_update_dialog'):
                view.on_update_available("2.0", "http://url")
&gt;               self.assertIn("Aggiornamento disponibile", view.version_label.text())
E               AssertionError: 'Aggiornamento disponibile' not found in &lt;MagicMock name='mock.LoginView().version_label.text()' id='2997026446256'&gt;

tests\desktop_app\views\test_login_view_coverage.py:176: AssertionError</failure></testcase><testcase classname="tests.desktop_app.views.test_login_view_license.TestLoginViewLicense" name="test_login_view_missing_license" time="0.007" /><testcase classname="tests.desktop_app.views.test_login_view_license.TestLoginViewLicense" name="test_login_view_reads_license" time="0.005" /><testcase classname="tests.desktop_app.views.test_login_view_logic.TestLoginViewLogic" name="test_handle_login_success" time="0.009" /><testcase classname="tests.desktop_app.views.test_login_view_logic.TestLoginViewLogic" name="test_handle_login_failure" time="0.010" /><testcase classname="tests.desktop_app.views.test_login_view_logic.TestLoginViewLogic" name="test_handle_login_empty" time="0.006" /><testcase classname="tests.desktop_app.views.test_login_view_logic.TestLoginViewLogic" name="test_on_login_success_read_only" time="0.011" /><testcase classname="tests.desktop_app.views.test_main_views" name="test_database_view_init" time="0.003" /><testcase classname="tests.desktop_app.views.test_main_views" name="test_validation_view_init" time="0.004" /><testcase classname="tests.desktop_app.views.test_main_views" name="test_scadenzario_view_init" time="0.006" /><testcase classname="tests.desktop_app.views.test_main_views" name="test_import_view_init" time="0.001" /><testcase classname="tests.desktop_app.views.test_main_views" name="test_config_view_init" time="0.004" /><testcase classname="tests.desktop_app.views.test_main_views" name="test_edit_dialog_init" time="0.001" /><testcase classname="tests.desktop_app.views.test_modern_guide_view.TestModernGuideView" name="test_init_dev_mode" time="0.002" /><testcase classname="tests.desktop_app.views.test_modern_guide_view.TestModernGuideView" name="test_init_frozen_mode" time="0.002" /><testcase classname="tests.desktop_app.views.test_modern_guide_view.TestModernGuideView" name="test_fallback_html" time="0.001" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_init" time="0.003" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_load_data_trigger" time="0.003" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_on_data_loaded_populates_tree" time="0.007" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_update_gantt_chart" time="0.005" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_export_pdf" time="0.003" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_send_manual_alert" time="0.003" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_send_manual_alert_success_handling" time="0.004" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_zoom_levels" time="0.002" /><testcase classname="tests.desktop_app.views.test_scadenzario_logic" name="test_read_only_mode" time="0.002" /><testcase classname="tests.desktop_app.views.test_splash_screen" name="test_splash_creation" time="0.004" /><testcase classname="tests.desktop_app.views.test_splash_screen" name="test_update_status" time="0.004" /><testcase classname="tests.desktop_app.views.test_splash_screen" name="test_show_error" time="0.004" /><testcase classname="tests.desktop_app.views.test_splash_screen" name="test_paint_event" time="0.005" /><testcase classname="tests.desktop_app.views.test_stats_view" name="test_stats_view_initialization" time="0.002" /><testcase classname="tests.desktop_app.views.test_stats_view" name="test_refresh_data_success" time="0.001" /><testcase classname="tests.desktop_app.views.test_stats_view" name="test_refresh_data_failure" time="0.001" /><testcase classname="tests.desktop_app.views.test_stats_view" name="test_show_event" time="0.001" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_load_data_success" time="0.005" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_load_data_error" time="0.006" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_validate_selected" time="0.007" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_delete_selected" time="0.005" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_edit_data_success" time="0.008" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_context_menu_open_pdf" time="0.007" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_context_menu_open_folder" time="0.008" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_action_completed_success" time="0.005" /><testcase classname="tests.desktop_app.views.test_validation_view_actions" name="test_action_completed_with_errors" time="0.005" /><testcase classname="tests.desktop_app.workers.test_workers.TestWorkers" name="test_fetch_worker_success" time="0.003" /><testcase classname="tests.desktop_app.workers.test_workers.TestWorkers" name="test_fetch_worker_failure" time="0.001" /><testcase classname="tests.desktop_app.workers.test_workers.TestWorkers" name="test_delete_worker" time="0.001" /><testcase classname="tests.desktop_app.workers.test_workers_extended.TestWorkersExtended" name="test_update_worker" time="0.001" /><testcase classname="tests.desktop_app.workers.test_workers_extended.TestWorkersExtended" name="test_validate_worker" time="0.002" /><testcase classname="tests.test_launcher_coverage.TestLauncherCoverage" name="test_check_port" time="0.001" /><testcase classname="tests.test_launcher_coverage.TestLauncherCoverage" name="test_find_free_port" time="0.001" /><testcase classname="tests.test_launcher_coverage.TestLauncherCoverage" name="test_startup_worker_failure" time="0.070" /><testcase classname="tests.test_launcher_coverage.TestLauncherCoverage" name="test_startup_worker_flow" time="0.090" /><testcase classname="tests.test_launcher_coverage.TestLauncherCoverage" name="test_verify_license_files" time="0.001" /><testcase classname="tests.tools.test_build_guide" name="test_build_guide_success" time="0.001" /><testcase classname="tests.tools.test_build_guide" name="test_build_guide_no_npm" time="0.001" /><testcase classname="tests.tools.test_build_guide" name="test_build_guide_subprocess_error" time="0.001" /><testcase classname="tests.tools.test_tools" name="test_create_assets" time="0.696" /></testsuite></testsuites>